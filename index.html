<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Parlay & Wager Tracker</title>
  
  <!-- PWA Configuration -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#140d52">
  
  <!-- Android specific -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Parlay Tracker">
  
  <!-- iOS specific -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Parlays">
  
  <!-- App Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="/media/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/media/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/media/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="512x512" href="/media/icons/icon-512x512.png">
  
  <!-- Description for search engines and sharing -->
  <meta name="description" content="Track your sports betting parlays and monitor live stats in real-time">
  
  <!-- App Version for Cache Busting -->
  <meta name="app-version" content="2.0.0">
  
  <!-- Roboto Font Import -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  
  <!-- Design System Stylesheets -->
  <link rel="stylesheet" href="design-system.css">
  <link rel="stylesheet" href="bottom-nav.css">
  <link rel="stylesheet" href="icons.css">
  
  <!-- DataTables CSS -->
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.7/css/dataTables.tailwindcss.min.css">
  
  <!-- jQuery and DataTables JavaScript -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.7/js/dataTables.tailwindcss.min.js"></script>
  
  <style>
    :root {
      /* Dark mode colors (default) */
      --bg:#121212;--surface:#252525;--primary:#140d52;
      --text:#e0e0e0;--border:#ffcc00a4;--green:#4caf50;
      --orange:#ff9800;--yellow:#ffeb3b;--pregame:#ffc107;
      --error:#f44336;--progress-bg:#444;--section-bg:#1a1a1a;
      --outline-blue: #03a9f4; --title-color: #e657ff;
      --tab-active: #2a2a2a;
      
      /* Betting site colors */
      --draftkings: #4caf50;
      --fanduel: #2196f3;
      --dabble: #ffc107;
      --bet365: #ffcc00;
    }
    
    /* Light mode colors */
    body.light-mode {
      --bg:#f5f5f5;--surface:#f0f0f0;--primary:#5e35b1;
      --text:#212121;--border:#ffcc00;--green:#388e3c;
      --orange:#f57c00;--yellow:#fbc02d;--pregame:#ff6f00;
      --error:#c62828;--progress-bg:#e0e0e0;--section-bg:#ffffff;
      --outline-blue: #0288d1; --title-color: #7b1fa2;
      --tab-active: #e0e0e0;
    }
    
    /* Page Header with Title and Hamburger Menu */
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--primary);
      z-index: 100;
      padding: 0;
      height: 50px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      border-radius: 0;
    }
    
    h1 {
      color: #fff;
      margin: 0;
      flex: 1;
      text-align: center;
      font-size: var(--text-lg);
      font-weight: var(--weight-bold);
      line-height: 50px;
      padding: 0 1rem;
      margin-left: -3rem;
    }
    
    /* Hamburger Menu Button - 75% size, inline with title */
    .menu-button {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      width: 30px;  /* 75% of 50px */
      height: 30px; /* 75% of 50px */
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 3px;     /* 75% of 5px */
      box-shadow: none;
      transition: transform 0.2s, opacity 0.3s;
      flex-shrink: 0;
      margin-right: 0.5rem;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .menu-button:hover {
      transform: scale(1.05);
    }
    
    .menu-button span {
      width: 15px;  /* 75% of 20px */
      height: 2px; /* 75% of 2.4px */
      background: #fff;
      border-radius: 2px;
      transition: all 0.3s;
    }
    
    /* Menu button animation when open */
    .menu-button.active span:nth-child(1) {
      transform: rotate(45deg) translate(4.2px, 4.2px); /* 75% of 5.6px */
    }
    
    .menu-button.active span:nth-child(2) {
      opacity: 0;
    }
    
    .menu-button.active span:nth-child(3) {
      transform: rotate(-45deg) translate(4.2px, -4.2px); /* 75% of 5.6px */
    }
    
    /* Scroll to Top Button */
    .scroll-top-btn {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 50px;
      height: 50px;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 50%;
      font-size: var(--text-2xl);
      font-weight: var(--weight-bold);
      line-height: 1; /* Prevent vertical misalignment */
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1001; /* Higher z-index to ensure it's always on top */
      display: none; /* Hidden by default */
      align-items: center;
      justify-content: center;
      transition: opacity 0.3s; /* Only opacity transition, no transform */
      /* iOS-specific fixes for stable positioning */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      will-change: opacity;
    }
    
    .scroll-top-btn.visible {
      display: flex;
    }
    
    .scroll-top-btn:hover {
      transform: scale(1.1);
    }
    
    /* Reduce opacity when scrolling */
    body.scrolling .scroll-top-btn {
      opacity: 0.2;
    }
    
    /* Side Menu Panel - Compact half-width design */
    .side-menu {
      position: fixed;
      top: 0;
      right: -50vw;
      width: 50vw;
      max-width: 250px;
      height: 100vh;
      background: var(--surface);
      box-shadow: -4px 0 20px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: right 0.3s ease;
      padding: 4rem 1rem 1rem;
      overflow-y: auto;
    }
    
    .side-menu.open {
      right: 0;
    }
    
    /* Menu overlay */
    .menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    
    .menu-overlay.active {
      opacity: 1;
      pointer-events: all;
    }
    
    /* Menu items - Compact design */
    .menu-item {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.65rem 0.8rem;
      background: var(--section-bg);
      border-radius: 6px;
      margin-bottom: 0.4rem;
      cursor: pointer;
      transition: background 0.2s;
      border: 1px solid transparent;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .menu-item:focus {
      outline: none;
    }
    
    .menu-item:hover {
      background: var(--yellow);
      border-color: var(--yellow);
      color: var(--primary);
    }
    
    .menu-item:hover .menu-item-text {
      color: var(--primary);
    }
    
    .menu-item:hover svg {
      color: var(--primary);
      stroke: var(--primary);
    }
    
    .menu-item-icon {
      font-size: var(--text-lg);
      width: 22px;
      height: 22px;
      text-align: center;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      stroke: currentColor;
    }
    
    .menu-item-text {
      font-size: var(--text-xs);
      font-weight: var(--weight-medium);
    }
    
    .menu-divider {
      height: 1px;
      background: var(--border);
      margin: 0.5rem 0;
      opacity: 0.3;
    }
    
    /* Filter button - inline with Refresh button */
    .filter-button {
      display: inline-block;
      position: static;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.6rem 1.2rem; /* Match toolbar-button padding */
      cursor: pointer;
      font-weight: 600; /* Match toolbar-button weight */
      margin: 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); /* Match toolbar-button shadow */
      transition: opacity 0.2s;
      height: 40px; /* Match toolbar-button height */
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      line-height: 1;
    }
    
    .filter-button:hover {
      opacity: 0.9;
    }
    
    /* New toolbar styles */
    .toolbar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0 1rem 0; /* Consistent margin */
      flex-wrap: wrap;
      min-height: 40px; /* Ensure minimum height matches button height */
    }
    
    .toolbar-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      height: 40px;
    }
    
    .toolbar-controls > div {
      display: flex;
      align-items: center;
      height: 40px;
    }
    
    .toolbar-search {
      display: flex;
      align-items: center;
      height: 40px;
    }
    
    .toolbar-button {
      padding: 0.6rem 1.2rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.2s;
      position: relative;
      height: 40px; /* Fixed height for alignment */
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      line-height: 1;
    }
    
    .toolbar-button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
    
    .search-input {
      padding: 0.6rem 1rem;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.9rem;
      width: 250px;
      transition: border-color 0.2s;
      height: 40px; /* Fixed height for alignment */
      box-sizing: border-box;
      line-height: 1;
      vertical-align: middle;
    }
    
    .search-input:focus {
      outline: none;
      border-color: var(--primary);
    }
    
    /* Sub-panel for filter options - smaller dropdown to the right */
    .filter-sub-panel {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 0;
      width: 150px; /* Match collapse-menu width */
      max-height: 400px;
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 1001;
      overflow-y: auto;
      display: none;
    }
    
    .filter-sub-panel.active {
      display: block;
    }
    
    .filter-panel-header {
      padding: 0.3rem 0.5rem; /* Reduced vertical padding by 33% (from 0.5rem to 0.3rem) */
      background: var(--primary);
      color: #fff;
      font-weight: bold;
      font-size: 0.9rem; /* Match dropdown font size */
      display: flex;
      justify-content: center;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
      border-radius: 6px 6px 0 0;
      min-height: 30px; /* Reduced from default */
    }
    
    .filter-panel-back {
      background: none;
      border: none;
      color: #fff;
      font-size: 1rem; /* Slightly smaller for narrow panel */
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      left: 0.5rem; /* Position in top-left corner */
      top: 50%;
      transform: translateY(-50%);
    }
    
    .filter-panel-close {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      right: 0.5rem; /* Position in top-right corner */
      top: 50%;
      transform: translateY(-50%);
    }
    
    .filter-panel-content {
      padding: 0.5rem; /* Match collapse-menu padding */
      font-size: 0.9rem; /* Match dropdown font size */
    }
    
    .filter-category {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--section-bg);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .filter-category:hover {
      background: var(--parlay-bg);
    }
    
    .filter-category-title {
      font-weight: bold;
      font-size: 1rem;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .filter-category-desc {
      font-size: 0.85rem;
      opacity: 0.7;
    }
    
    .filter-option-item {
      padding: 0.6rem 1rem; /* Match collapse-option padding */
      margin: 0.25rem 0; /* Match collapse-option margin */
      background: var(--section-bg);
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
      font-size: 0.9rem; /* Match dropdown font size */
    }
    
    .filter-option-item:hover {
      background: var(--parlay-bg);
      border-color: var(--primary);
    }
    
    .filter-option-item.selected {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    
    .filter-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    
    .filter-overlay.active {
      display: block;
    }
    
    /* Collapse menu */
    .collapse-menu {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      z-index: 998;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      display: none;
      min-width: 150px;
    }
    
    .collapse-menu.active {
      display: block;
    }
    
    .collapse-option {
      padding: 0.6rem 0.2rem;
      margin: 0.25rem 0;
      background: var(--section-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text);
      display: block;
      width: 100%;
      text-align: left;
      transition: background 0.2s;
      font-size: 0.9rem;
    }
    
    .collapse-option:hover {
      background: var(--primary);
      color: #fff;
    }
    
    /* Old filter menu - keeping for compatibility but will hide */
    .filter-menu {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      display: none;
      min-width: 200px;
    }
    
    .filter-menu.active {
      display: block;
    }
    
    /* Button container for centering */
    .button-container {
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
    }
    
    #refresh-button,
    #add-bet-button {
      display: inline-block;
      margin: 0;
      padding: 0.75rem 1.5rem;
      background: var(--primary);
      color: #fff;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    
    .button-container > div {
      display: flex;
      align-items: center;
      margin: 0;
    }
    
    .filter-option {
      padding: 0.5rem 1rem;
      margin: 0.25rem 0;
      background: var(--section-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text);
      display: block;
      width: 100%;
      text-align: left;
      transition: background 0.2s;
    }
    
    .filter-option:hover, .filter-option.active {
      background: var(--primary);
      color: #fff;
    }
    
    /* Collapsible parlay */
    .parlay-section.collapsed .parlay-body {
      display: none;
    }
    
    .parlay-section.collapsed {
      padding: 0 !important;
    }
    
    .parlay-section.collapsed .parlay-header {
      margin: 0 !important;
      border-radius: 12px 12px 0 0 !important;
    }
    
    .parlay-section.collapsed .parlay-footer {
      margin: 0 !important;
      border-radius: 0 0 12px 12px !important;
    }
    
    .parlay-header {
      cursor: pointer;
      user-select: none;
      position: relative;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    
    /* Selected bet styling */
    /* Winning bet styling - with 20% opacity yellow border */
    .parlay-section.won {
      border: 3px solid rgba(255, 215, 0, 0.2) !important; /* 20% opacity yellow/gold border */
    }
    
    .parlay-section.won .parlay-header,
    .parlay-section.won .parlay-footer {
      background: rgba(70, 130, 180, 0.3) !important; /* Light blue tint for dark mode */
    }
    
    /* Dark green for light mode winning bets */
    body:not(.dark-mode) .parlay-section.won .parlay-header,
    body:not(.dark-mode) .parlay-section.won .parlay-footer {
      background: rgba(34, 139, 34, 0.4) !important; /* Dark green tint for light mode */
    }
    
    /* Selected state - must come after .won to override */
    .parlay-section.selected {
      transform: scale(0.95);
      border: 3px solid #fff !important; /* White border overrides yellow */
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5) !important;
      transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
    }
    
    /* Select button with selection */
    #select-dropdown-btn.has-selection {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    
    /* Filter button with active filters */
    #filter-dropdown-btn.has-filters {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    
    .parlay-title {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      position: relative;
      z-index: 1;
      width: 100%;
    }
    
    .collapse-icon {
      display: inline-block;
      margin-right: 0.5rem;
      transition: transform 0.3s;
      width: 20px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .parlay-section.collapsed .collapse-icon {
      transform: rotate(-180deg);
    }
    
    .parlay-title-text {
      display: flex;
      align-items: center;
    }
    
    /* Sortable column headers */
    thead th {
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    
    thead th:hover {
      background: var(--primary) !important;
    }
    
    thead th.sorted::after {
      content: ' ▼';
      font-size: 0.7em;
    }
    
    thead th.sorted.asc::after {
      content: ' ▲';
    }
    
    /* Pull to refresh indicator */
    .pull-refresh {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: #fff;
      padding: 0.5rem 1rem;
      border-radius: 0 0 8px 8px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 99;
      pointer-events: none;
    }
    
    .pull-refresh.active {
      opacity: 1;
    }
    
    /* Profile page styles */
    .profile-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }
    
    .back-button {
      padding: 0.5rem 1rem;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    
    .back-button:hover {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    
    .profile-header h2 {
      margin: 0;
      color: var(--text);
      font-size: 1.5rem;
    }
    
    .profile-content {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .profile-section {
      background: var(--surface);
      padding: 1.5rem;
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    
    .profile-label {
      font-size: 0.85rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
    }
    
    .profile-value {
      font-size: 1.1rem;
      color: var(--text);
      font-weight: 500;
    }
    
    /* Issues Page Styling */
    .issues-header {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    .issues-header h2 {
      color: var(--text);
      margin-bottom: 0.5rem;
      font-size: 1.8rem;
    }
    
    .issues-header p {
      color: var(--text);
      opacity: 0.8;
      font-size: 1rem;
    }
    
    .issues-content {
      max-width: 800px;
      margin: 0 auto;
    }
    
    .issue-item {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }
    
    .issue-item h3 {
      color: var(--error);
      margin: 0 0 0.5rem 0;
      font-size: 1.1rem;
      font-weight: 600;
    }
    
    .issue-item p {
      color: var(--text);
      margin: 0.5rem 0;
      line-height: 1.5;
    }
    
    .issue-timestamp {
      color: var(--text);
      opacity: 0.6;
      font-size: 0.85rem;
      text-align: right;
    }
    
    .tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      justify-content: center;
    }
    
    .tab {
      padding: 0.75rem 1.5rem;
      background: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    .tab:hover {
      opacity: 0.9;
    }
    
    .tab.active {
      background: var(--tab-active);
      color: var(--title-color);
    }
    
    /* Reduce header sizes in My Bets sections */
    #parlay-sections h2,
    #historical-sections h2,
    #archived-sections h2 {
      font-size: var(--text-lg);
      margin: 1rem 0 0.75rem 0;
    }
    
    #parlay-sections h3,
    #historical-sections h3,
    #archived-sections h3 {
      font-size: var(--text-base);
      margin: 0.75rem 0 0.5rem 0;
    }
    
    body{background:var(--bg);color:var(--text);
      font-family:Roboto,sans-serif;
      margin:0;
      padding:1rem;
      /* iOS safe area insets for notch/Dynamic Island */
      padding-top: max(1rem, env(safe-area-inset-top));
      padding-bottom: max(1rem, env(safe-area-inset-bottom));
      padding-left: max(1rem, env(safe-area-inset-left));
      padding-right: max(1rem, env(safe-area-inset-right));
      zoom: 0.8;}
    .container{max-width:1200px;margin:auto;padding:2rem;
      padding-top: calc(2rem + 50px);
      padding-bottom:calc(2rem + 80px);
      background:var(--surface);border-radius:12px;
      box-shadow:0 4px 20px rgba(0,0,0,0.25);}
    
    button{display:block;margin:0 auto 1.5rem;padding:.75rem 1.5rem;
      background:var(--primary);color:#fff;font-weight:bold;
      border:none;border-radius:8px;cursor:pointer;}
    button:hover{opacity:.9;}
    #status-message{text-align:center;margin:0.5rem 0 1.5rem 0;color:#aaa;} /* Added bottom margin for spacing */
    .parlay-section{background:var(--section-bg);margin-bottom:2rem;
      border-radius:12px;padding:1.5rem 1.5rem 1.125rem;border:1px solid #cccccc;}
    .parlay-header{
      background:linear-gradient(135deg, var(--primary) 0%, rgba(20, 13, 82, 0.7) 100%);
      color:#fff;
      margin:-1.5rem -1.5rem 1.125rem -1.5rem;padding:1rem 1.5rem;
      border-radius:12px 12px 0 0;display:flex; flex-wrap: wrap;
      justify-content:space-between;align-items:flex-start;font-weight:bold;
      position:relative;
      cursor: pointer;
      user-select: none;
      gap: 1rem;
      overflow: hidden;
    }
    /* Single scoreboard: keep header on one line */
    .parlay-header:has(.game-info-wrapper .game-info:only-child) {
      flex-wrap: nowrap;
    }
    .parlay-footer{
      background:linear-gradient(135deg, var(--primary) 0%, rgba(20, 13, 82, 0.7) 100%);
      color:#fff;
      margin:1.125rem -1.5rem -1.125rem -1.5rem;padding:0.375rem 1.5rem;
      border-radius:0 0 12px 12px;display:flex;
      justify-content:space-between;align-items:center;
      font-size:0.75rem;min-height:1.5rem;
      position: relative;
      overflow: hidden;
    }
    
    /* Footer logo styling */
    .footer-logo {
      position: absolute;
      right: 0.5rem;
      top: 0;
      bottom: 0;
      height: 120%;
      width: auto;
      opacity: 0.15;
      object-fit: contain;
      pointer-events: none;
      transform: translateY(-10%);
    }
    
    /* Ensure footer content stays above logo */
    .footer-left, .footer-right {
      position: relative;
      z-index: 1;
    }
    
    .footer-left{display:flex;flex-direction:column;gap:0.25rem;}
    .footer-right{display:flex;flex-direction:column;gap:0.25rem;text-align:right;}
    .footer-odds{font-weight:bold;color:#FFD700;}
    .footer-wager{color:#ddd;}
    .footer-betid{color:#ddd;}
    .footer-site{color:#fff;font-weight:500;}
    .trophy-icon{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%, -50%) scale(1.25) rotate(-30deg);
      height:100%;
      width:auto;
      opacity:0.3;
      pointer-events:none;
      z-index:0;
      object-fit:contain;}
    /* Trophy theme switching */
    body.dark-mode .trophy-light {display: none;}
    body.dark-mode .trophy-dark {display: block;}
    body:not(.dark-mode) .trophy-dark {display: none;}
    body:not(.dark-mode) .trophy-light {display: block;}
    .parlay-title{display:flex;flex-direction:column;gap:0.25rem;position:relative;z-index:1;flex:1 1 auto;min-width:0;}
    .parlay-date{font-size:0.85rem;font-weight:normal;opacity:0.8;}
    .game-info-wrapper{display:flex;gap:0.5rem;flex-wrap:wrap;position:relative;z-index:1;justify-content:flex-end;align-items:flex-start;flex:0 1 100%;flex-direction:row;}
    /* Single game: align scoreboards to the right, no reversal, no size constraints */
    .game-info-wrapper:has(.game-info:only-child) {
      justify-content:flex-end;
      width:auto;
      flex:0 0 auto;
      flex-direction:row;
      flex-wrap:nowrap;
    }
    .game-info-wrapper:has(.game-info:only-child) .game-info {
      flex: 0 0 auto;
      max-width: none;
    }
    /* Multiple games: keep right-aligned, limit to 10 per row on desktop */
    .game-info-wrapper:not(:has(.game-info:only-child)) {
      width: 100%;
      justify-content: flex-end; /* Keep scoreboards aligned to the right */
    }
    .game-info-wrapper:not(:has(.game-info:only-child)) .game-info {
      flex: 0 0 calc((100% - 4.5rem) / 10); /* 10 items with 9 gaps of 0.5rem */
      max-width: calc((100% - 4.5rem) / 10);
    }
    /* Center items that wrap to second row (11th item onwards) */
    .game-info-wrapper:not(:has(.game-info:only-child)) .game-info:nth-child(n+11) {
      flex: 0 0 auto;
    }
    .game-info{display:flex;flex-direction:column;align-items:center;
      gap:.25rem;font-size:.9rem;border:1px solid var(--border);
      padding:.5rem;border-radius:6px;background:rgba(0,0,0,0.2);
      position:relative;overflow:hidden;
      width: 12ch; /* Fixed width: 12 characters (e.g., "LAC 13 - 99 LAR") */
      min-width: 12ch;
      max-width: 12ch;
    }
    /* Reduce scoreboard font size (web view only) */
    .game-info * {
      font-size: 0.8rem;
    }
    
    /* Show Scores toggle button */
    .show-scores-btn {
      position: absolute;
      bottom: 0.5rem;
      right: 0.5rem;
      background: rgba(20, 13, 82, 0.8);
      color: #fff;
      border: 1px solid rgba(255, 204, 0, 0.3);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      z-index: 10;
      transition: background 0.2s;
      min-width: 95px; /* Fixed width to prevent button movement */
      text-align: center; /* Center text within fixed width */
    }
    .show-scores-btn:hover {
      background: rgba(20, 13, 82, 1);
    }
    
    /* Scoreboard block - hidden by default */
    .scoreboard-block {
      display: none;
      width: 100%;
      margin-top: 1rem;
      padding: 0.75rem 0;
      border-top: 1px solid rgba(255, 204, 0, 0.2);
    }
    .scoreboard-block.active {
      display: block;
    }
    
    /* Scoreboard rows */
    .scoreboard-row {
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      flex-wrap: nowrap;
    }
    .scoreboard-row:last-child {
      margin-bottom: 0;
    }
    
    /* Second and subsequent rows centered */
    .scoreboard-row:not(:first-child) {
      justify-content: center;
    }
    /* NFL logo in scoreboards - positioned in background with low opacity */
    .nfl-logo-bg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1.5);
      width: 100%;
      height: 100%;
      opacity: 0.1;
      pointer-events: none;
      z-index: 0;
    }
    /* Larger zoom for 2-line scoreboards (FINAL games) */
    .game-info.two-line .nfl-logo-bg {
      transform: translate(-50%, -50%) scale(2.25);
    }
    /* Theme-aware NFL logo display */
    body:not(.light-mode) .nfl-logo-light {
      display: none;
    }
    body.light-mode .nfl-logo-dark {
      display: none;
    }
    /* Ensure scoreboard content is above logo */
    .game-info > div {
      position: relative;
      z-index: 1;
    }
    table{width:100%;border-collapse:separate;border-spacing:0;border-radius:12px;overflow:hidden;}
    /* Reduce vertical padding significantly for tighter rows (0.375rem -> 0.25rem) */
    th,td{padding:0.25rem 0.375rem;border-bottom:1px solid var(--border);
      vertical-align:middle;text-align:left;}
    /* Double padding for Player column (column 1) - header and data */
    th:nth-child(1){padding-left:0.75rem !important;}
    td:nth-child(1){padding-left:0.75rem !important;}
    td { background: var(--surface); }
    th:first-child { border-top-left-radius: 12px !important; }
    th:last-child { border-top-right-radius: 12px !important; }
    /* Desktop body: Player column (3) - left aligned */
    td:nth-child(3){text-align:left !important;}
    /* Desktop body: Stat Type, Current, Target, Progress columns (4-7) - centered */
    td:nth-child(4),td:nth-child(5),td:nth-child(6),td:nth-child(7){text-align:center !important;}
    /* Desktop body: Status column (8) - centered */
    td:nth-child(8){text-align:center !important;}
    /* Headers: Player (th1) - left, Stat Type through Status (th2-6) - centered */
    thead th:nth-child(1){text-align:left !important;}
    thead th:nth-child(2),thead th:nth-child(3),thead th:nth-child(4),thead th:nth-child(5),thead th:nth-child(6){text-align:center !important;}
    tbody tr:last-child td { border-bottom: none; }
    /* Round table corners to match footer underneath */
    tbody tr:last-child td:first-child { border-bottom-left-radius: 12px !important; }
    tbody tr:last-child td:last-child { border-bottom-right-radius: 12px !important; }
    th{background:#2a2a2a;color:#fff;}
    
    /* Ensure table headers are white in light mode */
    body.light-mode th {
      color: #fff !important;
    }
    .progress-bar{background:var(--progress-bg);border-radius:13px;position:relative;height:1.25rem;border:2px solid var(--outline-blue);padding:2px;}
    .progress-bar.pct-vlow { border-color: #f44336; }  /* Red */
    .progress-bar.pct-low { border-color: #ff9800; }   /* Orange */
    .progress-bar.pct-mid { border-color: #ffeb3b; }   /* Yellow */
    .progress-bar.pct-full { border-color: #4caf50; }  /* Green */
    .progress{height:100%;transition:width .5s ease-in-out;border-radius:8px;}
    .progress-text{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;}
    .progress.pct-vlow{background:linear-gradient(to right, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 1));}
    .progress.pct-low{background:linear-gradient(to right, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 1));}
    .progress.pct-mid{background:linear-gradient(to right, rgba(255, 235, 59, 0.2), rgba(255, 235, 59, 1));}
    .progress.pct-full{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));}
    /* Reverse colors for UNDER bets (0-60% green, 60-80% yellow, 80-99% orange, 100% red) */
    .progress.pct-under-vlow{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));} /* Green */
    .progress.pct-under-low{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));} /* Green */
    .progress.pct-under-mid{background:linear-gradient(to right, rgba(255, 235, 59, 0.2), rgba(255, 235, 59, 1));} /* Yellow */
    .progress.pct-under-high{background:linear-gradient(to right, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 1));} /* Orange */
    .progress.pct-under-full{background:linear-gradient(to right, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 1));} /* Red */
    .progress-bar.pct-under-vlow { border-color: #4caf50; }  /* Green */
    .progress-bar.pct-under-low { border-color: #4caf50; }   /* Green */
    .progress-bar.pct-under-mid { border-color: #ffeb3b; }   /* Yellow */
    .progress-bar.pct-under-high { border-color: #ff9800; }  /* Orange */
    .progress-bar.pct-under-full { border-color: #f44336; }  /* Red */
    .badge{display:inline-block;font-size:.75rem;font-weight:bold;
      margin-bottom:.25rem;padding:2px 6px;border-radius:4px;}
    .status-pregame{background:var(--pregame);color:#ffffff;}
    .status-live{background:var(--error);color:#ffffff;}
    .status-halftime{background:transparent;color:#ffffff;border:1px solid #ffffff;}
    .status-final{background:#808080;color:#ffffff;}
    
    /* Reduce status badge font size by 10% (0.75rem -> 0.675rem) */
    .status-badge {
      font-size: 0.675rem;
    }
    
    /* Mobile-specific layout classes (hidden on desktop) */
    .mobile-line-1,
    .mobile-line-2,
    .mobile-line-2-header {
      display: none;
    }
    
    /* Hide mobile cells 1-2 on desktop */
    table tbody tr td:nth-child(1),
    table tbody tr td:nth-child(2) {
      display: none;
    }
    
    .mobile-line-1 {
      justify-content: space-between;
      align-items: flex-start; /* Changed from center to flex-start for consistent top alignment */
      font-weight: 500;
    }
    
    .mobile-line-2-header {
      display: grid;
      grid-template-columns: 3.75rem 1fr 3.75rem;
      gap: 0.25rem;
      align-items: end;
      font-size: 0.45rem;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 0.125rem;
    }
    
    .mobile-line-2-header span:first-child {
      text-align: left;
    }
    
    .mobile-line-2-header span:nth-child(2) {
      text-align: center;
    }
    
    .mobile-line-2-header span:last-child {
      text-align: right;
    }
    
    .mobile-line-2 {
      grid-template-columns: 3.75rem 1fr 3.75rem;
      gap: 0.25rem;
      align-items: center;
    }
    
    .mobile-line-2 span:first-child {
      text-align: left;
      max-width: 3.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .mobile-line-2 span:nth-child(2) {
      text-align: center;
    }
    
    .mobile-line-2 span:last-child {
      text-align: right;
      max-width: 3.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 0;
        /* iOS safe area insets for notch/Dynamic Island on mobile */
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        zoom: 1; /* Reset zoom on mobile for better readability */
      }
      
      .container {
        padding: 0.5rem;
        padding-top: calc(0.5rem + 50px);
        padding-bottom: calc(0.5rem + 80px);
        border-radius: 0;
      }
      
      h1 {
        font-size: 1.5rem;
        padding: 0 0.5rem;
      }
      
      /* Mobile toolbar adjustments */
      .toolbar {
        gap: 0.2rem; /* Reduced gap by 80% from 1rem */
        margin: 0.5rem 0;
      }
      
      .toolbar-button {
        font-size: 0.85rem;
        padding: 0.5rem 1rem;
      }
      
      .search-input {
        width: 100%;
        font-size: 0.85rem;
      }
      
      .parlay-section {
        padding: 1rem 0.5rem;
        overflow-x: hidden; /* Prevent horizontal scroll */
        margin: 0.5625rem 0; /* Reduced by 50% from 1.125rem to match tighter spacing */
        border-radius: 8px;
        border-color: rgba(204, 204, 204, 0.5);
      }
      
      .parlay-header {
        margin: -1rem -0.5rem 0.40rem -0.5rem; /* Bottom margin increased from 0.25rem to 0.40rem */
        padding: 0.5625rem 0.5rem; /* Reduced by 25% from 0.75rem */
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.375rem; /* Reduced by 25% from 0.5rem */
        align-items: flex-start;
        justify-content: space-between;
      }
      
      .parlay-title {
        flex: 1;
        min-width: 0;
        font-size: 0.9rem; /* Reduced by 1 font size for mobile */
      }
      
      .parlay-date {
        font-size: 0.7rem !important; /* Match footer font size on mobile */
      }
      
      .parlay-footer {
        margin: 0.40rem -0.5rem -1rem -0.5rem; /* Top margin increased from 0.25rem to 0.40rem */
        padding: 0.3375rem 0.5rem; /* Reduced by 10% from 0.375rem to 0.3375rem */
        font-size: 0.7rem;
      }
      
      /* Reduce line spacing in footer for mobile - halved from desktop */
      .footer-left, .footer-right {
        gap: 0.125rem; /* Reduced by 50% from 0.25rem for tighter line spacing */
      }
      
      /* Adjust trophy icon for mobile */
      .trophy-icon {
        opacity: 0.25;
      }

      /* Mobile scoreboard styling */
      .game-info {
        width: auto; /* Override fixed width on mobile */
        min-width: auto;
        max-width: none;
        font-size: 0.65rem;
        padding: 0.35rem; /* Equal padding all around */
        gap: 0.15rem;
      }
      
      /* Show Scores button smaller on mobile */
      .show-scores-btn {
        font-size: 0.6rem;
        padding: 0.2rem 0.4rem;
        bottom: 0.35rem;
        right: 0.35rem;
      }
      
      /* Scoreboard block - 3 per row on mobile */
      .scoreboard-row {
        flex-wrap: wrap;
        justify-content: space-evenly;
      }
      
      .scoreboard-row .game-info {
        flex: 0 0 calc(28% - 0.5rem); /* 3 per row, balanced width */
        max-width: calc(28% - 0.5rem);
      }
      
      /* Multiple games: center items that wrap to second row (4th item onwards) */
      .game-info-wrapper:not(:has(.game-info:only-child)) .game-info:nth-child(n+4) {
        margin: 0 auto;
      }
      
      .game-info {
        font-size: 0.65rem;
        padding: 0.35rem; /* Equal padding all around */
        gap: 0.15rem;
      }
      
      .game-info .badge {
        font-size: 0.6rem;
        padding: 1px 4px;
      }

      /* Mobile: Stack bet legs vertically with compact layout */
      table {
        display: block;
      }
      
      thead {
        display: none; /* Hide table headers on mobile */
      }
      
      tbody {
        display: block;
      }
      
      tr {
        display: block;
        margin-bottom: 0.40rem; /* Increased from 0.25rem to 0.40rem */
        padding: 0.40rem; /* Increased from 0.3rem to 0.40rem for side padding */
        background: var(--surface);
        border-radius: 8px;
        border: 1px solid rgba(255, 204, 0, 0.2);
      }
      
      /* Remove negative margins since header/footer margins now handle gaps */
      tr:first-child {
        margin-top: 0; /* Changed from -0.25rem to allow header margin to work */
      }
      
      /* Remove negative margins since header/footer margins now handle gaps */
      tr:last-child {
        margin-bottom: 0.40rem; /* Increased from 0.25rem to 0.40rem */
      }
      
      td {
        display: block;
        padding: 0.1rem 0; /* Reduced from 0.15rem to further compact */
        border: none;
        background: transparent;
        text-align: left !important;
      }
      
      /* Remove desktop padding override for mobile - keep consistent padding */
      td:nth-child(1) {
        padding-left: 0 !important;
      }
      
      /* Hide desktop columns 3-8 (individual cells) */
      tr td:nth-child(n+3) {
        display: none !important;
      }
      
      /* Show mobile columns 1-2 */
      tr td:nth-child(1),
      tr td:nth-child(2) {
        display: block !important;
      }
      
      /* Make mobile-specific content visible */
      .mobile-line-1 {
        display: flex !important;
        font-size: 0.85rem; /* Reduced by 0.05rem for tighter display */
      }
      
      .mobile-line-2-header {
        display: grid !important;
        font-size: 0.45rem;
      }
      
      .mobile-line-2 {
        display: grid !important;
        font-size: 0.8rem; /* Reduced by 0.05rem for consistency */
      }
      
      /* Line 1 styling */
      tr td:nth-child(1) {
        margin-bottom: 0.15rem; /* Further reduced for tighter spacing */
      }

      .progress-bar {
        height: 2.5rem;
      }
      
      .progress-bar .progress-text {
        font-size: 0.75rem;
      }
      
      .tabs {
        gap: 0.5rem;
        padding: 0 0.5rem;
      }
      
      .tab {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      #refresh-button,
      #move-completed-button {
        margin-left: 0.5rem !important;
      }
      
      #status-message {
        margin: 0.5rem 0.5rem 1.5rem 0.5rem; /* Increased bottom margin for mobile */
      }
      
      /* Mobile: Toolbar layout - buttons on one line, search below */
      .toolbar {
        flex-direction: column;
        padding: 0 0.5rem;
        gap: 0.5rem;
        align-items: stretch;
      }
      
      .toolbar-controls {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        width: 100%;
      }
      
      .toolbar-search {
        width: 100%;
      }
      
      /* Mobile: Make search bar full width */
      .search-input {
        width: 100% !important;
        max-width: none !important;
      }
    }
    
    /* Extra small screens */
    @media (max-width: 480px) {
      h1 {
        font-size: 1.25rem;
      }
      
      .progress-bar {
        height: 1rem;
        font-size: 0.65rem;
      }
      
      .button-container {
        justify-content: center;
        padding: 0 1rem;
      }
      
      #refresh-button, .filter-button {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
      
      /* Mobile menu adjustments - Compact */
      .menu-button {
        width: 45px;
        height: 45px;
        top: 0.75rem;
        right: 0.75rem;
      }
      
      .side-menu {
        width: 55vw;
        max-width: 200px;
        right: -55vw;
        padding: 3.5rem 0.8rem 1rem;
      }
      
      .menu-item {
        padding: 0.6rem 0.7rem;
        margin-bottom: 0.35rem;
      }
      
      .menu-item-icon {
        font-size: 1rem;
        width: 20px;
      }
      
      .menu-item-text {
        font-size: 0.8rem;
      }
      
      /* OCR Modal - Mobile specific */
      .modal-content {
        width: 95% !important;
        max-width: none !important;
        padding: 0.8rem !important;
        max-height: 90vh !important;
      }
    }
    
    @media (max-width: 360px) {
      .modal-content {
        width: 98% !important;
        padding: 0.6rem !important;
        font-size: 0.85rem !important;
      }
    }
    
    /* OCR Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10000;
      overflow-y: auto;
    }
    
    .modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    
    .modal-content {
      background: var(--surface);
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      position: relative;
      width: 90%;
      max-width: 450px;
      max-height: 80vh;
      overflow-y: auto;
      box-sizing: border-box;
      margin: auto;
    }
    
    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      color: var(--text);
      cursor: pointer;
      font-weight: bold;
      line-height: 1;
      z-index: 1;
    }
    
    .close-modal:hover {
      color: var(--error);
    }
    
    /* Loading Spinner */
    .loading-spinner {
      border: 4px solid var(--progress-bg);
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Issues page styles */
    .issues-list {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .issue-item {
      display: flex;
      margin-bottom: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #007bff;
    }
    
    .issue-number {
      font-weight: bold;
      color: #007bff;
      min-width: 30px;
      margin-right: 15px;
    }
    
    .issue-text {
      flex: 1;
      line-height: 1.4;
    }
    
    .no-issues {
      text-align: center;
      padding: 40px;
      color: #666;
      font-style: italic;
    }
  </style>
</head>
<body>
  <!-- Menu Overlay -->
  <div class="menu-overlay" id="menu-overlay"></div>
  
  <!-- Side Menu -->
  <div class="side-menu" id="side-menu">
    <div class="menu-item" id="add-bet-item">
      <svg class="menu-item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
      <span class="menu-item-text">Add New Bet</span>
    </div>
    
    <div class="menu-item" id="admin-item" style="display:none;">
      <svg class="menu-item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>
      </svg>
      <span class="menu-item-text">Admin Tools</span>
    </div>
    
    <div class="menu-item" id="issues-item">
      <svg class="menu-item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3.05h16.94a2 2 0 0 0 1.71-3.05L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
      <span class="menu-item-text">Issues</span>
    </div>
    
    <div class="menu-item" id="theme-toggle">
      <svg class="menu-item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
      </svg>
      <span class="menu-item-text" id="theme-text">Light Mode</span>
    </div>
    
    <div class="menu-divider"></div>
    
    <div class="menu-item" id="profile-item" style="display:none;">
      <svg class="menu-item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>
      </svg>
      <span class="menu-item-text">Profile</span>
    </div>
    
    <div class="menu-item" id="logout-item" style="display:none;">
      <svg class="menu-item-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>
      </svg>
      <span class="menu-item-text">Logout</span>
    </div>
  </div>
  
  <!-- Pull to Refresh Indicator -->
  <div class="pull-refresh" id="pull-refresh">Release to refresh...</div>
  
  <!-- Scroll to Top Button -->
  <button class="scroll-top-btn" id="scroll-top-btn">↑</button>
  
  <div class="container">
    <!-- Page Header with Title and Hamburger Menu -->
    <div class="page-header">
      <h1>Parlay & Wager Tracker</h1>
      <button class="menu-button" id="menu-button">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    
    <div class="tabs">
      <button class="tab active" data-tab="current">Live Bets</button>
      <button class="tab" data-tab="historical">Historical Bets</button>
      <button class="tab" data-tab="archived">Archived Bets</button>
    </div>
    <div class="button-container">
      <button id="refresh-button">Refresh Stats</button>
      <div style="position: relative; display: inline-block;">
        <button id="add-bet-button">➕ Add Bet</button>
        <div id="add-bet-dropdown" class="collapse-menu">
          <button id="upload-betslip-option" class="collapse-option">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 18px; height: 18px; display: inline-block; margin-right: 0.5rem; vertical-align: middle;">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/>
            </svg><strong>Upload Bet Slip</strong>
          </button>
          <button id="manual-entry-option" class="collapse-option">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 18px; height: 18px; display: inline-block; margin-right: 0.5rem; vertical-align: middle;">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg><strong>Manual Entry</strong>
          </button>
        </div>
      </div>
      <button id="clear-cache-button" style="display: none;">Clear Cache 🗑️</button>
    </div>
    <div id="status-message"></div>
    
    <!-- Hidden file input for bet slip upload (removed capture attribute) -->
    <input type="file" id="betslip-file-input" accept="image/*" style="display: none;">
    
    <!-- Bet Slip OCR Modal -->
    <div id="ocr-modal" class="modal" style="display: none;">
      <div class="modal-content">
        <span class="close-modal" id="close-ocr-modal" style="color: var(--text); top: 8px; right: 12px; font-size: 24px;">&times;</span>
        <h2 style="color: var(--text); margin-bottom: 0.5rem; font-size: 1rem;">📋 Review Extracted Bet</h2>
        
        <div id="ocr-loading" style="display: none; text-align: center; padding: 1.5rem;">
          <div class="loading-spinner"></div>
          <p style="font-size: 0.85rem; color: var(--text); margin-top: 0.75rem; opacity: 0.8;">Processing bet slip with AI...</p>
        </div>
        
        <div id="ocr-error" style="display: none; padding: 0.75rem; background: rgba(244, 67, 54, 0.1); border: 2px solid #f44336; border-radius: 6px; margin: 0.5rem 0; color: #f44336;">
          <strong style="font-size: 0.9rem;">❌ Error:</strong> <span id="ocr-error-message" style="display: block; margin-top: 0.4rem; font-size: 0.8rem;"></span>
        </div>
        
        <div id="ocr-results" style="display: none;">
          <!-- Editable Bet Details -->
          <div style="background: var(--section-bg); padding: 0.6rem; border-radius: 6px; margin-bottom: 0.6rem; border: 1px solid var(--border);">
            <h3 style="margin-top: 0; color: var(--text); font-size: 0.85rem; margin-bottom: 0.4rem; font-weight: 600;">📊 Bet Details</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem;">
              <div>
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Betting Site</label>
                <input type="text" id="extracted-site" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
              </div>
              <div>
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Bet Name</label>
                <input type="text" id="extracted-bet-name" placeholder="e.g., Sunday NFL Parlay" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
              </div>
              <div>
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Odds</label>
                <input type="text" id="extracted-odds" placeholder="+450" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
              </div>
              <div>
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Bet Date</label>
                <input type="date" id="extracted-date" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
              </div>
              <div>
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Wager ($)</label>
                <input type="number" id="extracted-wager" step="0.01" min="0" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
              </div>
              <div>
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Payout ($)</label>
                <input type="number" id="extracted-payout" step="0.01" min="0" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
              </div>
              <div style="grid-column: 1 / -1;">
                <label style="display: block; font-weight: 600; color: var(--text); margin-bottom: 0.15rem; font-size: 0.7rem;">Type</label>
                <select id="extracted-type" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; background: var(--bg); color: var(--text); box-sizing: border-box;">
                  <option value="parlay">Parlay</option>
                  <option value="single">Single Bet</option>
                  <option value="teaser">Teaser</option>
                  <option value="round_robin">Round Robin</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- Secondary Bettors Section -->
          <div style="background: var(--section-bg); padding: 0.6rem; border-radius: 6px; margin-bottom: 0.6rem; border: 1px solid var(--border);">
            <h3 style="margin-top: 0; color: var(--text); font-size: 0.85rem; margin-bottom: 0.3rem; font-weight: 600;">👥 Secondary Bettors</h3>
            <p style="color: var(--text); opacity: 0.7; font-size: 0.65rem; margin-bottom: 0.4rem;">Add other users part of this bet:</p>
            <div style="position: relative;">
              <input type="text" id="bettor-search" placeholder="Search username..." style="width: 100%; padding: 0.4rem; border: 1px solid var(--border); border-radius: 4px; font-size: 0.8rem; background: var(--bg); color: var(--text); box-sizing: border-box;" autocomplete="off">
              <div id="bettor-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--surface); border: 1px solid var(--border); border-top: none; border-radius: 0 0 4px 4px; max-height: 120px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 8px rgba(0,0,0,0.3);"></div>
            </div>
            <div id="selected-bettors" style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.4rem;"></div>
          </div>
          
          <!-- Bet Legs Section -->
          <div style="background: var(--section-bg); padding: 0.6rem; border-radius: 6px; margin-bottom: 0.6rem; border: 1px solid var(--border);">
            <h3 style="margin-top: 0; color: var(--text); font-size: 0.85rem; margin-bottom: 0.4rem; font-weight: 600;">🎯 Bet Legs (<span id="leg-count" style="color: var(--primary); font-weight: bold;"></span>)</h3>
            <div id="extracted-legs-list" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
          
          <div style="margin-top: 0.6rem; text-align: center; padding: 0.6rem; background: var(--section-bg); border-radius: 6px; border: 1px solid var(--border);">
            <p style="margin: 0 0 0.5rem 0; font-size: 0.7rem; color: var(--text); opacity: 0.8;"><strong>⚠️ Review before saving</strong></p>
            <button id="confirm-save-bet" style="background: var(--primary); color: #000; padding: 0.5rem 1rem; font-size: 0.8rem; font-weight: 600; border: none; border-radius: 6px; cursor: pointer; margin-right: 0.4rem; transition: transform 0.2s;">✓ Save Bet</button>
            <button id="cancel-ocr" style="background: var(--section-bg); color: var(--text); padding: 0.5rem 1rem; font-size: 0.8rem; font-weight: 600; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; transition: transform 0.2s;">✗ Cancel</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- New Toolbar -->
    <div class="toolbar">
      <div class="toolbar-controls">
        <div style="position: relative;">
          <button class="toolbar-button" id="filter-dropdown-btn">Filter ▼</button>
          <div class="collapse-menu" id="filter-main-menu">
            <button class="collapse-option" data-category="status">Status</button>
            <button class="collapse-option" data-category="site">Betting Site</button>
            <button class="collapse-option" data-category="sport">Sport</button>
            <button class="collapse-option" data-category="last30">Last 30 Days</button>
            <button class="collapse-option" id="clear-all-filters">Clear All</button>
          </div>
          
          <!-- Filter Sub-Panel -->
          <div class="filter-sub-panel" id="filter-sub-panel">
            <div class="filter-panel-header">
              <button class="filter-panel-back" id="back-to-filters">←</button>
              <span id="sub-panel-title">Filter Options</span>
              <button class="filter-panel-close" id="close-sub-panel">×</button>
            </div>
            <div class="filter-panel-content" id="sub-panel-content"></div>
          </div>
        </div>
        
        <div style="position: relative;">
          <button class="toolbar-button" id="collapse-dropdown-btn">Collapse ▼</button>
          <div class="collapse-menu" id="collapse-menu">
            <button class="collapse-option" id="collapse-all">All</button>
            <button class="collapse-option" id="uncollapse-all">None</button>
          </div>
        </div>
        
        <div style="position: relative;">
          <button class="toolbar-button" id="select-dropdown-btn">Select ▼</button>
          <div class="collapse-menu" id="select-menu">
            <button class="collapse-option" id="archive-selected">Archive Selected</button>
            <button class="collapse-option" id="unselect-all">Unselect All</button>
          </div>
        </div>
      </div>
      
      <div class="toolbar-search">
        <input type="text" class="search-input" id="search-input" placeholder="Search bets...">
      </div>
    </div>
    
    <div id="cache-info" style="text-align: center; margin-bottom: 1rem; color: #888; font-size: 0.85rem; display: none;"></div>
    <div id="parlay-sections" class="tab-content active" data-tab="current"></div>
    <div id="historical-sections" class="tab-content" data-tab="historical" style="display:none"></div>
    <div id="archived-sections" class="tab-content" data-tab="archived" style="display:none"></div>
    <div id="issues-sections" class="tab-content" data-tab="issues" style="display:none">
      <div class="issues-header">
        <h2>🐛 Debugging Issues</h2>
        <p>Track and monitor system issues, errors, and debugging information.</p>
      </div>
      <div class="issues-content">
        <div id="issues-list">
          <!-- Issues will be loaded here -->
        </div>
        <div id="issues-loading" style="text-align: center; padding: 2rem; display: none;">
          <div class="loading-spinner"></div>
          <p>Loading issues...</p>
        </div>
        <div id="issues-empty" style="text-align: center; padding: 2rem; color: var(--text); opacity: 0.7;">
          <p>No issues found. System is running smoothly! ✅</p>
        </div>
      </div>
    </div>
    
    <!-- Profile Page -->
    <div id="profile-page" style="display:none;">
      <div class="profile-header">
        <button class="back-button" id="back-to-bets">← Back to Bets</button>
        <h2>Profile</h2>
      </div>
      <div class="profile-content">
        <div class="profile-section">
          <div class="profile-label">Username</div>
          <div class="profile-value" id="profile-username">-</div>
        </div>
        <div class="profile-section">
          <div class="profile-label">Email</div>
          <div class="profile-value" id="profile-email">-</div>
        </div>
        
        <!-- Password Change Section -->
        <div class="profile-section">
          <h3 style="color: var(--primary); margin-bottom: 15px; margin-top: 20px;">Change Password</h3>
          <form id="password-change-form">
            <div style="margin-bottom: 15px;">
              <label for="current-password" style="display: block; margin-bottom: 5px; color: var(--text);">Current Password</label>
              <input type="password" id="current-password" required style="width: 100%; padding: 8px; border: 1px solid rgba(255, 204, 0, 0.3); border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: var(--text);">
            </div>
            <div style="margin-bottom: 15px;">
              <label for="new-password" style="display: block; margin-bottom: 5px; color: var(--text);">New Password</label>
              <input type="password" id="new-password" required minlength="6" style="width: 100%; padding: 8px; border: 1px solid rgba(255, 204, 0, 0.3); border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: var(--text);">
            </div>
            <div style="margin-bottom: 15px;">
              <label for="confirm-password" style="display: block; margin-bottom: 5px; color: var(--text);">Confirm New Password</label>
              <input type="password" id="confirm-password" required minlength="6" style="width: 100%; padding: 8px; border: 1px solid rgba(255, 204, 0, 0.3); border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: var(--text);">
            </div>
            <button type="submit" class="btn" id="change-password-btn" style="width: auto; padding: 10px 20px;">Change Password</button>
            <div id="password-status" class="status" style="margin-top: 15px;"></div>
          </form>
        </div>
      </div>
    </div>
    
    <div style="text-align: right; margin-top: 2rem;">
      <button id="move-completed-button">Move Completed to History</button>
    </div>
  </div>
  <script>
    // === AUTHENTICATION CHECK ===
    // Check if user is authenticated before loading the app
    let authCheckComplete = false;
    let isAuthenticated = false;
    let authCheckPromise = null;
    let isRedirecting = false;
    
    authCheckPromise = (async function checkAuth() {
      try {
        const response = await fetch('/auth/check', {
          credentials: 'include'
        });
        const data = await response.json();
        
        if (!data.authenticated) {
          // Not logged in, redirect to login page (only once)
          if (!isRedirecting) {
            isRedirecting = true;
            // Check if this is due to logout
            const params = new URLSearchParams(window.location.search);
            const loggedOut = params.get('logged_out');
            if (loggedOut === 'true') {
              window.location.replace('/login.html?message=logged_out');
            } else {
              window.location.replace('/login.html?message=auth_required');
            }
          }
          throw new Error('Not authenticated');
        }
        
        // User is authenticated, store user info
        window.currentUser = data.user;
        isAuthenticated = true;
        authCheckComplete = true;
        console.log('✅ Authenticated as:', data.user.username);
        
        // Update hamburger menu with username
        const logoutButton = document.querySelector('.menu-button:last-child');
        if (logoutButton && logoutButton.textContent.includes('Logout')) {
          logoutButton.textContent = `Logout (${data.user.username})`;
        }
        
        // Clear historical cache on first login to ensure fresh data from database
        // (in case user switched from JSON to database system)
        const cacheVersion = localStorage.getItem('parlay_tracker_cache_version');
        const CURRENT_CACHE_VERSION = '2.0'; // Increment when data structure changes
        if (cacheVersion !== CURRENT_CACHE_VERSION) {
          console.log('🔄 Cache version mismatch, clearing historical cache...');
          clearHistoricalCache();
          localStorage.setItem('parlay_tracker_cache_version', CURRENT_CACHE_VERSION);
        }
        
        return true;
      } catch (error) {
        console.error('Auth check failed:', error);
        // On error, redirect to login to be safe
        if (!isRedirecting) {
          window.location.replace('/login.html?message=auth_required');
        }
        throw error;
      }
    })();
    
    // Scroll detection for button opacity
    let scrollTimer;
    window.addEventListener('scroll', () => {
      document.body.classList.add('scrolling');
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        document.body.classList.remove('scrolling');
      }, 1000);
      
      // Show/hide scroll-to-top button
      const scrollTopBtn = document.getElementById('scroll-top-btn');
      if (scrollTopBtn) {
        // Show button when scrolled down more than 300px
        if (window.scrollY > 300) {
          scrollTopBtn.classList.add('visible');
        } else {
          scrollTopBtn.classList.remove('visible');
        }
      }
    });
    
    // Scroll to top button click handler
    const scrollTopBtn = document.getElementById('scroll-top-btn');
    if (scrollTopBtn) {
      scrollTopBtn.addEventListener('click', () => {
        // Custom fast scroll animation (2x speed)
        const startPosition = window.scrollY;
        const duration = 300; // 300ms instead of default ~600ms for 2x speed
        const startTime = performance.now();
        
        function easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }
        
        function animateScroll(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const ease = easeInOutQuad(progress);
          
          window.scrollTo(0, startPosition * (1 - ease));
          
          if (progress < 1) {
            requestAnimationFrame(animateScroll);
          }
        }
        
        requestAnimationFrame(animateScroll);
      });
    }
    
    // Helper to read query params
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // API base precedence: ?api=... (query param) -> window.API_BASE -> auto-detect (localhost = same origin, otherwise Render)
    const urlApi = getQueryParam('api');
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const defaultApi = isLocalhost ? '' : 'https://parlay-tracker-backend.onrender.com';
    const API_BASE = (urlApi ? urlApi.replace(/\/$/, '') : (window.API_BASE && window.API_BASE.replace(/\/$/, ''))) || defaultApi;
    const btn=document.getElementById('refresh-button'),
      sec=document.getElementById('parlay-sections'),
      histSec=document.getElementById('historical-sections'),
      msg=document.getElementById('status-message'),
      statsUrl = `${API_BASE}/stats`,
      liveUrl = `${API_BASE}/live`,
      histUrl = `${API_BASE}/historical`;
    
    // Client-side cache for faster tab switching
    let cachedLive = null;
    let cachedHistorical = null;
    
    // === SELECTION STATE FOR ARCHIVE/UNARCHIVE ===
    const selectedBets = new Set();
    let pressTimer = null;
    let selectionMode = false;
    
    function updateSelectButton() {
      const selectBtn = document.getElementById('select-dropdown-btn');
      const archiveBtn = document.getElementById('archive-selected');
      const count = selectedBets.size;
      
      // Check which tab we're on
      const activeTab = document.querySelector('.tab.active').dataset.tab;
      const isArchivedTab = activeTab === 'archived';
      
      if (count === 0) {
        selectBtn.textContent = 'Select ▼';
        selectBtn.classList.remove('has-selection');
        selectionMode = false;
      } else {
        selectBtn.textContent = `Selected (${count}) ▼`;
        selectBtn.classList.add('has-selection');
        selectionMode = true;
      }
      
      // Update dropdown text based on tab
      if (isArchivedTab) {
        archiveBtn.textContent = 'Unarchive Selected';
        archiveBtn.dataset.action = 'unarchive';
      } else {
        archiveBtn.textContent = 'Archive Selected';
        archiveBtn.dataset.action = 'archive';
      }
    }
    
    function selectBet(betId) {
      selectedBets.add(betId);
      const section = document.querySelector(`[data-bet-id="${betId}"]`);
      if (section) {
        section.classList.add('selected');
        section.classList.add('collapsed'); // Auto-collapse when selected
      }
      updateSelectButton();
    }
    
    function deselectBet(betId) {
      selectedBets.delete(betId);
      const section = document.querySelector(`[data-bet-id="${betId}"]`);
      if (section) {
        section.classList.remove('selected');
        section.classList.remove('collapsed'); // Auto-expand when deselected
      }
      updateSelectButton();
    }
    
    function toggleBetSelection(betId) {
      if (selectedBets.has(betId)) {
        deselectBet(betId);
      } else {
        selectBet(betId);
      }
    }
    
    function clearAllSelections() {
      document.querySelectorAll('.parlay-section.selected').forEach(section => {
        section.classList.remove('selected');
      });
      selectedBets.clear();
      updateSelectButton();
    }
    
    async function archiveSelectedBets() {
      if (selectedBets.size === 0) {
        alert('No bets selected');
        return;
      }
      
      const betIds = Array.from(selectedBets);
      const count = betIds.length;
      
      if (!confirm(`Archive ${count} bet${count > 1 ? 's' : ''}?`)) {
        return;
      }
      
      try {
        const response = await fetchWithAdminToken(`${API_BASE}/api/bets/bulk-archive`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bet_ids: betIds })
        });
        
        if (!response.ok) throw new Error('Failed to archive bets');
        
        const result = await response.json();
        msg.textContent = `✅ ${result.message}`;
        
        clearAllSelections();
        await update(); // Refresh display
      } catch (err) {
        console.error('Error archiving bets:', err);
        alert('Failed to archive bets: ' + err.message);
      }
    }
    
    async function unarchiveSelectedBets() {
      if (selectedBets.size === 0) {
        alert('No bets selected');
        return;
      }
      
      const betIds = Array.from(selectedBets);
      const count = betIds.length;
      
      if (!confirm(`Unarchive ${count} bet${count > 1 ? 's' : ''} and return to Historical?`)) {
        return;
      }
      
      try {
        const response = await fetchWithAdminToken(`${API_BASE}/api/bets/bulk-unarchive`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bet_ids: betIds })
        });
        
        if (!response.ok) throw new Error('Failed to unarchive bets');
        
        const result = await response.json();
        msg.textContent = `✅ ${result.message}`;
        
        clearAllSelections();
        await update(); // Refresh display
      } catch (err) {
        console.error('Error unarchiving bets:', err);
        alert('Failed to unarchive bets: ' + err.message);
      }
    }
    
    // === HISTORICAL BETS CACHE SYSTEM ===
    const HISTORICAL_CACHE_KEY = 'parlay_tracker_historical_cache';
    const HISTORICAL_CACHE_META_KEY = 'parlay_tracker_historical_cache_meta';
    
    function saveHistoricalCache(data) {
      try {
        // Filter out invalid parlays before saving
        const validData = data.filter(parlay => {
          return parlay && typeof parlay === 'object' &&
                 (!parlay.legs || (Array.isArray(parlay.legs) && parlay.legs.every(leg => leg && typeof leg === 'object')));
        });

        // Aggressive cache size limit to prevent QuotaExceededError
        // Keep only the most recent 50 bets to ensure it fits in localStorage
        const MAX_CACHE_SIZE = 50;
        let cacheDataToSave = validData;
        if (validData.length > MAX_CACHE_SIZE) {
          // Sort by most recent first (assuming higher db_id = more recent)
          cacheDataToSave = validData
            .sort((a, b) => (b.db_id || 0) - (a.db_id || 0))
            .slice(0, MAX_CACHE_SIZE);
          console.log(`📦 Limiting cache to ${MAX_CACHE_SIZE} most recent bets (had ${validData.length})`);
        }

        const cacheData = {
          timestamp: new Date().toISOString(),
          betCount: cacheDataToSave.length,
          totalAvailable: validData.length, // Track total available for UI feedback
          data: cacheDataToSave
        };

        // Try to save with very small cache size
        try {
          localStorage.setItem(HISTORICAL_CACHE_KEY, JSON.stringify(cacheData));
          localStorage.setItem(HISTORICAL_CACHE_META_KEY, JSON.stringify({
            timestamp: cacheData.timestamp,
            betCount: cacheData.betCount,
            totalAvailable: cacheData.totalAvailable
          }));
          console.log('✅ Historical cache saved:', cacheData.betCount, 'bets cached');
        } catch (storageError) {
          if (storageError.name === 'QuotaExceededError') {
            console.warn('⚠️ Cache quota exceeded even with', MAX_CACHE_SIZE, 'bets, disabling cache');
            // Disable caching entirely by clearing and not saving
            clearHistoricalCache();
            console.log('🛑 Historical caching disabled due to storage quota');
          } else {
            console.warn('Failed to save historical cache:', storageError);
          }
        }
      } catch (e) {
        console.warn('Failed to save historical cache:', e);
      }
    }    function loadHistoricalCache() {
      try {
        const cached = localStorage.getItem(HISTORICAL_CACHE_KEY);
        if (!cached) return null;
        
        const cacheData = JSON.parse(cached);
        
        // Validate that all parlays have valid legs arrays
        const validData = cacheData.data.filter(parlay => {
          return parlay && typeof parlay === 'object' && 
                 (!parlay.legs || (Array.isArray(parlay.legs) && parlay.legs.every(leg => leg && typeof leg === 'object')));
        });
        
        if (validData.length !== cacheData.data.length) {
          console.warn('⚠️ Filtered out', cacheData.data.length - validData.length, 'invalid parlays from cache');
        }
        
        // Ensure cache meta exists (for backward compatibility)
        const existingMeta = getHistoricalCacheMeta();
        if (!existingMeta) {
          localStorage.setItem(HISTORICAL_CACHE_META_KEY, JSON.stringify({
            timestamp: cacheData.timestamp,
            betCount: validData.length
          }));
          console.log('📦 Created missing cache meta for existing cached data');
        }
        
        console.log('📦 Historical cache loaded:', validData.length, 'valid bets from', new Date(cacheData.timestamp).toLocaleString());
        return validData;
      } catch (e) {
        console.warn('Failed to load historical cache:', e);
        return null;
      }
    }
    
    function clearHistoricalCache() {
      try {
        // Clear both cache keys
        localStorage.removeItem(HISTORICAL_CACHE_KEY);
        localStorage.removeItem(HISTORICAL_CACHE_META_KEY);

        // Also clear any other potential cache keys that might exist
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (key.includes('historical') || key.includes('parlay_tracker_historical'))) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));

        // Clear service worker caches for historical API endpoints
        if ('caches' in window) {
          caches.keys().then(names => {
            names.forEach(name => {
              caches.open(name).then(cache => {
                // Remove cached historical API responses
                cache.keys().then(requests => {
                  requests.forEach(request => {
                    if (request.url.includes('/api/historical') ||
                        request.url.includes('/api/archived')) {
                      cache.delete(request);
                      console.log('🗑️ Cleared service worker cache for:', request.url);
                    }
                  });
                });
              });
            });
          });
        }

        console.log('🗑️ Historical cache cleared completely (localStorage + service worker)');
      } catch (e) {
        console.warn('Failed to clear historical cache:', e);
      }
    }
    
    function getHistoricalCacheMeta() {
      try {
        const meta = localStorage.getItem(HISTORICAL_CACHE_META_KEY);
        return meta ? JSON.parse(meta) : null;
      } catch (e) {
        return null;
      }
    }
    
    // === 1. HAMBURGER MENU AND THEME TOGGLE ===
    const menuButton = document.getElementById('menu-button');
    const menuOverlay = document.getElementById('menu-overlay');
    const sideMenu = document.getElementById('side-menu');
    const themeToggle = document.getElementById('theme-toggle');
    const themeText = document.getElementById('theme-text');
    const themeIcon = themeToggle.querySelector('.menu-item-icon');
    
    // Initialize theme
    const savedTheme = localStorage.getItem('theme') || 'dark';
    if (savedTheme === 'light') {
      document.body.classList.add('light-mode');
      themeIcon.textContent = '☀️';
      themeText.textContent = 'Dark Mode';
    }
    
    // Toggle menu
    function toggleMenu() {
      const isOpen = sideMenu.classList.contains('open');
      if (isOpen) {
        closeMenu();
      } else {
        openMenu();
      }
    }
    
    function openMenu() {
      sideMenu.classList.add('open');
      menuOverlay.classList.add('active');
      menuButton.classList.add('active');
    }
    
    function closeMenu() {
      sideMenu.classList.remove('open');
      menuOverlay.classList.remove('active');
      menuButton.classList.remove('active');
    }
    
    menuButton.addEventListener('click', toggleMenu);
    menuOverlay.addEventListener('click', closeMenu);
    
    // Theme toggle
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      const isLight = document.body.classList.contains('light-mode');
      themeIcon.textContent = isLight ? '☀️' : '🌙';
      themeText.textContent = isLight ? 'Dark Mode' : 'Light Mode';
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      
      // Update all footer logos to match new theme
      const logoSuffix = isLight ? '2' : '1'; // 1=white (dark mode), 2=colored (light mode)
      document.querySelectorAll('.footer-logo').forEach(logo => {
        const currentSrc = logo.src;
        const newSrc = currentSrc.replace(/logo-[12]\.svg$/, `logo-${logoSuffix}.svg`);
        logo.src = newSrc;
      });
    });
    
    // === 2. NEW FILTER, COLLAPSE, AND SEARCH FUNCTIONALITY ===
    let activeFilters = {
      status: new Set(),
      site: new Set(),
      sport: new Set(),
      last30Days: false
    };
    let searchQuery = '';
    
    // Function to update filter button with count and gradient
    function updateFilterButton() {
      const filterBtn = document.getElementById('filter-dropdown-btn');
      
      // Count active filters
      const filterCount = activeFilters.status.size + 
                         activeFilters.site.size + 
                         activeFilters.sport.size + 
                         (activeFilters.last30Days ? 1 : 0) +
                         (searchQuery ? 1 : 0);
      
      // Count visible bets
      const visibleBets = Array.from(document.querySelectorAll('.parlay-section'))
        .filter(section => section.style.display !== 'none').length;
      
      // Update button text and styling
      if (filterCount > 0) {
        filterBtn.textContent = `Filter (${visibleBets}) ▼`;
        filterBtn.classList.add('has-filters');
      } else {
        filterBtn.textContent = 'Filter ▼';
        filterBtn.classList.remove('has-filters');
      }
    }
    
    // Filter dropdown menu toggle
    const filterDropdownBtn = document.getElementById('filter-dropdown-btn');
    const filterMainMenu = document.getElementById('filter-main-menu');
    const filterSubPanel = document.getElementById('filter-sub-panel');
    const subPanelTitle = document.getElementById('sub-panel-title');
    const subPanelContent = document.getElementById('sub-panel-content');
    const closeSubPanel = document.getElementById('close-sub-panel');
    
    filterDropdownBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close collapse menu and add bet dropdown if open
      collapseMenu.classList.remove('active');
      addBetDropdown.classList.remove('active');
      filterMainMenu.classList.toggle('active');
    });
    
    document.addEventListener('click', () => {
      filterMainMenu.classList.remove('active');
    });
    
    filterMainMenu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Filter category click handlers
    document.querySelectorAll('.collapse-option[data-category]').forEach(option => {
      option.addEventListener('click', () => {
        const category = option.dataset.category;
        filterMainMenu.classList.remove('active');
        
        if (category === 'last30') {
          // Toggle last 30 days filter
          activeFilters.last30Days = !activeFilters.last30Days;
          option.textContent = activeFilters.last30Days ? 'Last 30 Days ✓' : 'Last 30 Days';
          applyAllFilters();
        } else {
          // Open sub-panel for multi-select filters
          openFilterSubPanel(category);
        }
      });
    });
    
    function openFilterSubPanel(category) {
      let title = '';
      let options = [];
      
      if (category === 'status') {
        title = 'Status'; // Shortened from 'Filter by Status'
        options = ['Winning', 'Live', 'Losing', 'Not Started'];
      } else if (category === 'site') {
        title = 'Betting Site'; // Shortened from 'Filter by Betting Site'
        // Get unique betting sites from all visible parlays
        const sites = new Set();
        document.querySelectorAll('.parlay-section').forEach(section => {
          const site = section.dataset.site;
          if (site) sites.add(site);
        });
        options = Array.from(sites).sort();
      } else if (category === 'sport') {
        title = 'Sport'; // Shortened from 'Filter by Sport'
        options = ['NFL', 'NBA'];
      }
      
      subPanelTitle.textContent = title;
      subPanelContent.innerHTML = '';
      
      options.forEach(opt => {
        const item = document.createElement('div');
        item.className = 'filter-option-item';
        if (activeFilters[category].has(opt)) {
          item.classList.add('selected');
        }
        item.innerHTML = `<span>${opt}</span><span>${activeFilters[category].has(opt) ? '✓' : ''}</span>`;
        item.addEventListener('click', () => {
          if (activeFilters[category].has(opt)) {
            activeFilters[category].delete(opt);
            item.classList.remove('selected');
            item.querySelector('span:last-child').textContent = '';
          } else {
            activeFilters[category].add(opt);
            item.classList.add('selected');
            item.querySelector('span:last-child').textContent = '✓';
          }
          applyAllFilters();
        });
        subPanelContent.appendChild(item);
      });
      
      filterSubPanel.classList.add('active');
    }
    
    closeSubPanel.addEventListener('click', () => {
      filterSubPanel.classList.remove('active');
    });
    
    // Back button to return to main filter menu
    const backToFiltersBtn = document.getElementById('back-to-filters');
    backToFiltersBtn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent event bubbling
      filterSubPanel.classList.remove('active');
      filterMainMenu.classList.add('active');
    });
    
    // Close sub-panel when clicking outside
    document.addEventListener('click', (e) => {
      if (!filterSubPanel.contains(e.target) && 
          !filterDropdownBtn.contains(e.target) &&
          !filterMainMenu.contains(e.target)) {
        filterSubPanel.classList.remove('active');
      }
    });
    
    // Collapse functionality
    const collapseDropdownBtn = document.getElementById('collapse-dropdown-btn');
    const collapseMenu = document.getElementById('collapse-menu');
    const collapseAllBtn = document.getElementById('collapse-all');
    const uncollapseAllBtn = document.getElementById('uncollapse-all');
    
    collapseDropdownBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close filter menu, sub-panel, and add bet dropdown if open
      filterMainMenu.classList.remove('active');
      filterSubPanel.classList.remove('active');
      addBetDropdown.classList.remove('active');
      collapseMenu.classList.toggle('active');
    });
    
    document.addEventListener('click', () => {
      collapseMenu.classList.remove('active');
    });
    
    collapseMenu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    collapseAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.parlay-section').forEach(section => {
        if (section.style.display !== 'none') {
          if (!section.classList.contains('collapsed')) {
            section.classList.add('collapsed');
          }
        }
      });
      collapseMenu.classList.remove('active');
    });
    
    uncollapseAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.parlay-section').forEach(section => {
        if (section.style.display !== 'none') {
          if (section.classList.contains('collapsed')) {
            section.classList.remove('collapsed');
          }
        }
      });
      collapseMenu.classList.remove('active');
    });
    
    // === SELECT DROPDOWN HANDLERS ===
    const selectDropdownBtn = document.getElementById('select-dropdown-btn');
    const selectMenu = document.getElementById('select-menu');
    const archiveSelectedBtn = document.getElementById('archive-selected');
    const unselectAllBtn = document.getElementById('unselect-all');
    
    selectDropdownBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close other menus
      filterMainMenu.classList.remove('active');
      filterSubPanel.classList.remove('active');
      collapseMenu.classList.remove('active');
      addBetDropdown.classList.remove('active');
      selectMenu.classList.toggle('active');
    });
    
    document.addEventListener('click', () => {
      selectMenu.classList.remove('active');
    });
    
    selectMenu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    archiveSelectedBtn.addEventListener('click', async () => {
      const action = archiveSelectedBtn.dataset.action;
      if (action === 'archive') {
        await archiveSelectedBets();
      } else if (action === 'unarchive') {
        await unarchiveSelectedBets();
      }
      selectMenu.classList.remove('active');
    });
    
    unselectAllBtn.addEventListener('click', () => {
      clearAllSelections();
      selectMenu.classList.remove('active');
    });
    
    // Clear All Filters button
    const clearAllFiltersBtn = document.getElementById('clear-all-filters');
    clearAllFiltersBtn.addEventListener('click', () => {
      // Clear all filter sets
      activeFilters.status.clear();
      activeFilters.site.clear();
      activeFilters.sport.clear();
      activeFilters.last30Days = false;
      
      // Clear search query
      searchQuery = '';
      const searchInput = document.getElementById('search-input');
      if (searchInput) searchInput.value = '';
      
      // Reset "Last 30 Days" button text
      document.querySelector('.collapse-option[data-category="last30"]').textContent = 'Last 30 Days';
      
      // Apply filters to show all bets
      applyAllFilters();
      
      // Close menu
      filterMainMenu.classList.remove('active');
    });
    
    // Search functionality
    const searchInput = document.getElementById('search-input');
    searchInput.addEventListener('input', (e) => {
      searchQuery = e.target.value.toLowerCase().trim();
      applyAllFilters();
    });
    
    function applyAllFilters() {
      document.querySelectorAll('.parlay-section').forEach(section => {
        let shouldShow = true;
        
        // Get parlay data
        const site = section.dataset.site || '';
        const sport = section.dataset.sport || '';
        const betDate = section.dataset.betDate || '';
        const legs = section.querySelectorAll('tbody tr');
        
        // Status filter
        if (activeFilters.status.size > 0) {
          let statusMatch = false;
          
          if (activeFilters.status.has('Winning')) {
            const hasHit = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Hit');
            });
            const hasMiss = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Miss');
            });
            const allHitOrNotStarted = Array.from(legs).every(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && (status.includes('Hit') || status.includes('Not Started'));
            });
            if (hasHit && !hasMiss && allHitOrNotStarted) statusMatch = true;
          }
          
          if (activeFilters.status.has('Live')) {
            const hasLive = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('In Progress');
            });
            if (hasLive) statusMatch = true;
          }
          
          if (activeFilters.status.has('Losing')) {
            const hasMiss = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Miss');
            });
            if (hasMiss) statusMatch = true;
          }
          
          if (activeFilters.status.has('Not Started')) {
            const allNotStarted = Array.from(legs).every(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Not Started');
            });
            if (allNotStarted) statusMatch = true;
          }
          
          shouldShow = shouldShow && statusMatch;
        }
        
        // Betting site filter
        if (activeFilters.site.size > 0) {
          shouldShow = shouldShow && activeFilters.site.has(site);
        }
        
        // Sport filter
        if (activeFilters.sport.size > 0) {
          shouldShow = shouldShow && activeFilters.sport.has(sport);
        }
        
        // Last 30 days filter
        if (activeFilters.last30Days && betDate) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          const betDateObj = new Date(betDate);
          shouldShow = shouldShow && betDateObj >= thirtyDaysAgo;
        }
        
        // Search filter
        if (searchQuery) {
          const searchableText = section.textContent.toLowerCase();
          shouldShow = shouldShow && searchableText.includes(searchQuery);
        }
        
        section.style.display = shouldShow ? 'block' : 'none';
      });
      
      // Update filter button with count
      updateFilterButton();
    }
    
    // === 3. PULL TO REFRESH ===
    let startY = 0;
    let isPulling = false;
    const pullRefresh = document.getElementById('pull-refresh');
    
    document.addEventListener('touchstart', (e) => {
      if (window.scrollY === 0) {
        startY = e.touches[0].pageY;
        isPulling = true;
      }
    });
    
    document.addEventListener('touchmove', (e) => {
      if (!isPulling) return;
      const currentY = e.touches[0].pageY;
      const diff = currentY - startY;
      
      if (diff > 80) {
        pullRefresh.classList.add('active');
        pullRefresh.textContent = 'Release to refresh...';
      }
    });
    
    document.addEventListener('touchend', async (e) => {
      if (!isPulling) return;
      isPulling = false;
      
      if (pullRefresh.classList.contains('active')) {
        pullRefresh.textContent = 'Refreshing...';
        cachedLive = null; // Reset live bets cache before fetching
        await update();
        setTimeout(() => {
          pullRefresh.classList.remove('active');
        }, 1000);
      }
    });

    // Tab handling
    const clearCacheBtn = document.getElementById('clear-cache-button');
    const cacheInfo = document.getElementById('cache-info');
    
    function updateCacheDisplay() {
      const activeTab = document.querySelector('.tab.active').dataset.tab;
      if (activeTab === 'historical') {
        // Always show clear cache button on historical tab - it's always a valid operation
        clearCacheBtn.style.display = 'inline-block';

        const meta = getHistoricalCacheMeta();
        const hasCache = loadHistoricalCache() !== null;
        if (meta || hasCache) {
          cacheInfo.style.display = 'block';
          if (meta) {
            const cacheText = meta.totalAvailable && meta.totalAvailable > meta.betCount
              ? `📦 Using cached data (${meta.betCount}/${meta.totalAvailable} bets) from ${new Date(meta.timestamp).toLocaleString()}`
              : `📦 Using cached data (${meta.betCount} bets) from ${new Date(meta.timestamp).toLocaleString()}`;
            cacheInfo.textContent = cacheText;
          } else {
            cacheInfo.textContent = `📦 Cached data available`;
          }
        } else {
          cacheInfo.style.display = 'block';
          cacheInfo.textContent = `🔄 No cached data - fetching fresh from server`;
        }
      } else {
        clearCacheBtn.style.display = 'none';
        cacheInfo.style.display = 'none';
      }
    }
    
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', async () => {
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show/hide content
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(content => {
          if (content.dataset.tab === tabName) {
            content.style.display = 'block';
          } else {
            content.style.display = 'none';
          }
        });
        
        // Clear selections when switching tabs
        clearAllSelections();
        
        // Update cache display
        updateCacheDisplay();
        
        // Update select button text based on tab
        updateSelectButton();
        
        // Refresh data when switching tabs
        await update();
      });
    });
    
    // Clear Cache button handler
    clearCacheBtn.addEventListener('click', async () => {
      if (confirm('Clear cached historical data? This will re-fetch all historical bets from the server.')) {
        clearHistoricalCache();
        cachedHistorical = null;
        msg.textContent = 'Cache cleared. Refreshing...';
        updateCacheDisplay();
        await update();
      }
    });

    // --- Session Authentication (old token system removed) ---
    // Authentication is now handled via session cookies
    // See auth check at the top of the script

// Profile page functions
function showProfilePage() {
  // Hide main content areas
  document.getElementById('parlay-sections').style.display = 'none';
  document.getElementById('historical-sections').style.display = 'none';
  document.getElementById('archived-sections').style.display = 'none';
  document.querySelector('.tabs').style.display = 'none';
  document.querySelector('.toolbar').style.display = 'none';
  document.querySelector('.button-container').style.display = 'none';
  document.getElementById('move-completed-button').parentElement.style.display = 'none';
  
  // Show profile page
  const profilePage = document.getElementById('profile-page');
  profilePage.style.display = 'block';
  
  // Populate profile data
  if (window.currentUser) {
    document.getElementById('profile-username').textContent = window.currentUser.username || '-';
    document.getElementById('profile-email').textContent = window.currentUser.email || '-';
  }
  
  // Close side menu
  closeSideMenu();
}

// Password change functionality
document.getElementById('password-change-form').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  const currentPassword = document.getElementById('current-password').value;
  const newPassword = document.getElementById('new-password').value;
  const confirmPassword = document.getElementById('confirm-password').value;
  const statusDiv = document.getElementById('password-status');
  const submitBtn = document.getElementById('change-password-btn');
  
  // Reset status
  statusDiv.style.display = 'none';
  statusDiv.className = 'status';
  statusDiv.innerHTML = '';
  
  // Basic client-side validation
  if (newPassword !== confirmPassword) {
    statusDiv.style.display = 'block';
    statusDiv.className = 'status error';
    statusDiv.innerHTML = '❌ New password and confirmation do not match';
    return;
  }
  
  if (newPassword.length < 6) {
    statusDiv.style.display = 'block';
    statusDiv.className = 'status error';
    statusDiv.innerHTML = '❌ New password must be at least 6 characters long';
    return;
  }
  
  // Disable button and show loading
  submitBtn.disabled = true;
  submitBtn.innerHTML = 'Changing... <span class="spinner"></span>';
  
  try {
    const response = await fetch('/auth/change_password', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify({
        current_password: currentPassword,
        new_password: newPassword,
        confirm_password: confirmPassword
      })
    });
    
    const data = await response.json();
    
    if (response.ok) {
      statusDiv.style.display = 'block';
      statusDiv.className = 'status success';
      statusDiv.innerHTML = '✅ Password changed successfully!';
      
      // Clear form
      document.getElementById('current-password').value = '';
      document.getElementById('new-password').value = '';
      document.getElementById('confirm-password').value = '';
    } else {
      statusDiv.style.display = 'block';
      statusDiv.className = 'status error';
      statusDiv.innerHTML = `❌ ${data.error || 'Failed to change password'}`;
    }
  } catch (error) {
    statusDiv.style.display = 'block';
    statusDiv.className = 'status error';
    statusDiv.innerHTML = `❌ Error: ${error.message}`;
  } finally {
    // Re-enable button
    submitBtn.disabled = false;
    submitBtn.innerHTML = 'Change Password';
  }
});

function showBetsPage() {
  // Show main content areas
  const activeTab = document.querySelector('.tab.active');
  const activeTabName = activeTab ? activeTab.dataset.tab : 'current';
  
  document.querySelector('.tabs').style.display = 'flex';
  document.querySelector('.toolbar').style.display = 'block';
  document.querySelector('.button-container').style.display = 'flex';
  document.getElementById('move-completed-button').parentElement.style.display = 'block';
  
  // Show the correct tab content
  if (activeTabName === 'current') {
    document.getElementById('parlay-sections').style.display = 'block';
  } else if (activeTabName === 'historical') {
    document.getElementById('historical-sections').style.display = 'block';
  } else if (activeTabName === 'archived') {
    document.getElementById('archived-sections').style.display = 'block';
  }
  
  // Hide profile page
  document.getElementById('profile-page').style.display = 'none';
}

let isLoggingOut = false;

async function logoutToken() {
  if (isLoggingOut) {
    console.log('Logout already in progress');
    return; // Prevent double-clicks
  }
  isLoggingOut = true;
  
  console.log('Starting logout process...');
  
  try {
    const response = await fetch('/auth/logout', {
      method: 'POST',
      credentials: 'include',
      headers: {
        'Cache-Control': 'no-cache'
      }
    });
    
    console.log('Logout response status:', response.status);
    
    if (response.ok) {
      await response.json(); // Wait for response to complete
    }
    
    // Delay to ensure session is cleared and cookie removed
    await new Promise(resolve => setTimeout(resolve, 250));
    
    // Clear any cached data
    if ('caches' in window) {
      caches.keys().then(names => {
        names.forEach(name => caches.delete(name));
        console.log('Cleared', names.length, 'caches');
      });
    }
    
    console.log('Redirecting to login page...');
    // Use replace to prevent back button from showing authenticated page
    window.location.replace('/login.html?message=logged_out&t=' + Date.now());
  } catch (error) {
    console.error('Logout error:', error);
    // Still redirect on error with cache busting
    await new Promise(resolve => setTimeout(resolve, 250));
    console.log('Redirecting to login page after error...');
    window.location.replace('/login.html?message=logged_out&t=' + Date.now());
  } finally {
    // Reset flag in case redirect fails
    isLoggingOut = false;
  }
}

// Always show logout item since user must be authenticated to be on this page
(function setupLogout(){
  const logoutItem = document.getElementById('logout-item');
  logoutItem.style.display = 'flex';
  logoutItem.addEventListener('click', logoutToken);
})();

// Setup profile item
(function setupProfile(){
  const profileItem = document.getElementById('profile-item');
  profileItem.style.display = 'flex';
  profileItem.addEventListener('click', function() {
    showProfilePage();
  });
  
  // Setup back button
  const backButton = document.getElementById('back-to-bets');
  backButton.addEventListener('click', function() {
    showBetsPage();
  });
})();

// Setup add bet button
(function setupAddBet(){
  const addBetItem = document.getElementById('add-bet-item');
  addBetItem.addEventListener('click', function() {
    window.location.href = '/add-bet.html';
  });
})();

// Check if user is admin and show admin menu, also show Issues tab for user ID 1
(function setupAdmin(){
  fetch('/api/current_user', {
    credentials: 'include'
  })
  .then(response => response.json())
  .then(data => {
    if (data.success && data.user) {
      // Show admin menu for admin users OR user ID 1
      if (data.user.user_role === 'admin' || data.user.id === 1) {
        const adminItem = document.getElementById('admin-item');
        adminItem.style.display = 'flex';
        adminItem.addEventListener('click', function() {
          window.location.href = '/admin.html';
        });
      }
      
      // Show Issues tab for user ID 1 (manishslal)
      if (data.user.id === 1) {
        const issuesTab = document.getElementById('issues-tab');
        issuesTab.style.display = 'inline-block';
        
        const issuesItem = document.getElementById('issues-item');
        issuesItem.style.display = 'flex';
        issuesItem.addEventListener('click', async function() {
          // Switch to issues tab
          document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
          document.getElementById('issues-tab').classList.add('active');
          document.getElementById('issues-sections').style.display = 'block';
          
          // Load issues data
          try {
            const issuesList = document.getElementById('issues-list');
            const loadingDiv = document.getElementById('issues-loading');
            const emptyDiv = document.getElementById('issues-empty');
            
            loadingDiv.style.display = 'block';
            emptyDiv.style.display = 'none';
            issuesList.innerHTML = '';
            
            const issuesUrl = `${API_BASE}/issues?t=${Date.now()}`;
            const response = await fetch(issuesUrl, { credentials: 'include' });
            
            if (response.ok) {
              const issuesData = await response.json();
              const issues = issuesData.issues || [];
              
              if (issues.length > 0) {
                issues.forEach((issue, index) => {
                  const issueItem = document.createElement('div');
                  issueItem.className = 'issue-item';
                  issueItem.innerHTML = `
                    <h3>Issue ${index + 1}</h3>
                    <p>${issue}</p>
                    <div class="issue-timestamp">${new Date().toLocaleString()}</div>
                  `;
                  issuesList.appendChild(issueItem);
                });
                loadingDiv.style.display = 'none';
              } else {
                loadingDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
              }
            } else {
              loadingDiv.style.display = 'none';
              issuesList.innerHTML = '<div class="issue-item"><h3>Error</h3><p>Failed to load issues data</p></div>';
            }
          } catch (error) {
            console.error('Error loading issues:', error);
            document.getElementById('issues-loading').style.display = 'none';
            document.getElementById('issues-list').innerHTML = '<div class="issue-item"><h3>Error</h3><p>Failed to load issues data</p></div>';
          }
          
          closeMenu();
        });
      }
    }
  })
  .catch(error => {
    console.error('Error checking admin status:', error);
  });
})();

    function fetchWithAdminToken(url, options = {}) {
      // Use session authentication instead of token headers
      options.credentials = 'include';
      return fetch(url, options)
        .then(response => {
          // If we get a 401, redirect to login
          if (response.status === 401) {
            window.location.href = '/login.html';
            return Promise.reject(new Error('Authentication required'));
          }
          return response;
        });
    }

    // Prefetch historical data in the background AFTER main content loads
    function prefetchHistorical(){
      setTimeout(async () => {
        try{
          const r = await fetchWithAdminToken(histUrl);
          if(r.ok){ cachedHistorical = await r.json(); console.log('Prefetched historical:', cachedHistorical); }
        }catch(e){ console.warn('Prefetch historical failed', e); }
      }, 2000); // Wait 2 seconds after page load before prefetching
    }

    // Start prefetching after initial page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', prefetchHistorical);
    } else {
      prefetchHistorical();
    }

    function fmtType(stat, stat_add = null){
      const m={'passing_yards':'Pass Yds','passing_yards_alt':'Alt Pass Yds','receiving_yards':'Rec Yds','receiving_yards_alt':'Alt Rec Yds','rushing_yards':'Rush Yds','rushing_yards_alt':'Alt Rush Yds','rushing_receiving_yards':'Rush + Rec Yds','passing_rushing_yards':'Pass + Rush Yds','anytime_touchdown':'Anytime TD','anytime_td_scorer':'Anytime TD','passing_touchdowns':'Pass TDs','rushing_touchdowns':'Rush TDs','receptions':'Receptions','receptions_alt':'Alt Receptions','longest_reception':'Longest Rec','moneyline':'Moneyline','spread':'Spread','total_points':'Total Points','total_points_under':'Total Points Under','total_points_over':'Total Points Over','interceptions_thrown':'INTs Thrown'};
      const baseName = m[stat] || (stat ? stat.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase()) : 'Unknown Stat');
      
      // Only add (U) suffix for under bets, over is default/implied
      if (stat_add === 'under') {
        return baseName + ' (U)';
      }
      
      return baseName;
    }
    function getQuarter(p){return p===1?'1st Q':p===2?'2nd Q':p===3?'3rd Q':p===4?'4th Q':'OT';}

    // Get 3-letter team abbreviation from full team name
    function getTeamAbbr(teamName) {
      const abbrevMap = {
        'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
        'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
        'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
        'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
        'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
        'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
        'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
        'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
        'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
        'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
        'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
      };
      return abbrevMap[teamName] || teamName.substring(0, 3).toUpperCase();
    }

    // Format stat value for mobile display
    function formatStatForMobile(value, stat) {
      if (!stat || stat === 'moneyline' || stat === 'spread') return value;
      
      // For numeric stats, add unit abbreviations
      if (stat.includes('yards')) return `${value} Yds`;
      if (stat.includes('touchdown')) return `${value} TDs`;
      if (stat.includes('receptions')) return `${value} Rec`;
      if (stat.includes('passing')) return `${value} Pass`;
      if (stat.includes('rushing')) return `${value} Rush`;
      
      return value;
    }

    // Normalize stat_type values to user-friendly display names
    function normalizeStatType(statType) {
      if (!statType) {
        console.warn('normalizeStatType called with undefined/null statType:', statType);
        return 'N/A';
      }
      
      const statMap = {
        // Passing stats
        'passing_yards': 'Passing Yds',
        'passing_yards_alt': 'Passing Yds',
        'alt_passing_yards': 'Passing Yds',
        'pass_attempts': 'Pass Attempts',
        'pass_completions': 'Completions',
        'passing_touchdowns': 'Pass TDs',
        'interceptions_thrown': 'Interceptions',
        'longest_pass_completion': 'Longest Pass',
        
        // Rushing stats
        'rushing_yards': 'Rushing Yds',
        'rushing_yards_alt': 'Rushing Yds',
        'alt_rushing_yards': 'Rushing Yds',
        'rushing_attempts': 'Rush Attempts',
        'rushing_touchdowns': 'Rush TDs',
        'longest_rush': 'Longest Rush',
        
        // Receiving stats
        'receiving_yards': 'Receiving Yds',
        'receiving_yards_alt': 'Receiving Yds',
        'alt_receiving_yards': 'Receiving Yds',
        'receptions': 'Receptions',
        'receptions_alt': 'Receptions',
        'receiving_touchdowns': 'Rec TDs',
        'longest_reception': 'Longest Rec',
        
        // Combined stats
        'rushing_receiving_yards': 'Rush + Rec Yds',
        'passing_rushing_yards': 'Pass + Rush Yds',
        
        // Touchdown stats
        'anytime_touchdown': 'Anytime TD',
        'player_to_score_2_touchdowns': '2+ TDs',
        'player_to_score_3_touchdowns': '3+ TDs',
        'first_touchdown_scorer': '1st TD Scorer',
        'last_touchdown_scorer': 'Last TD Scorer',
        
        // Defensive stats
        'sacks': 'Sacks',
        'tackles_assists': 'Tackles',
        
        // Kicking stats
        'field_goals_made': 'FG Made',
        'kicking_points': 'Kicking Pts',
        
        // Team props
        'team_total_points': 'Team Total Pts',
        'first_team_to_score': '1st Team to Score',
        'last_team_to_score': 'Last Team to Score',
        
        // Game props
        'total_points': 'Total Points',
        'total_points_under': 'Total Points Under',
        'total_points_over': 'Total Points Over',
        'will_be_overtime': 'Overtime',
        
        // Moneyline/Spread (keep as-is)
        'moneyline': 'Moneyline',
        'spread': 'Spread',
        
        // Additional variants found in database
        'anytime_td_scorer': 'Anytime TD Scorer',
        'player_prop': 'Player Prop'
      };
      
      return statMap[statType] || statType; // Fallback to original if not mapped
    }

    // Format stat type with under indicator
    function formatStatTypeWithUnder(statType, betLineType) {
      const normalized = normalizeStatType(statType);
      // Add (U) suffix if bet is under
      if (betLineType && betLineType.toLowerCase() === 'under') {
        return `${normalized} (U)`;
      }
      return normalized;
    }

    // Calculate countdown to game start
    function getCountdown(startDateTime) {
      if (!startDateTime) return '';
      
      const now = new Date();
      const gameStart = new Date(startDateTime);
      const diffMs = gameStart - now;
      
      if (diffMs <= 0) return 'Starting soon';
      
      const totalHours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      // If less than 24 hours, show hours and minutes
      if (totalHours < 24) {
        return `Starts in ${totalHours}h ${minutes}m`;
      }
      
      // If 24 hours or more, show days and hours (no minutes)
      const days = Math.floor(totalHours / 24);
      const hours = totalHours % 24;
      return `Starts in ${days}d ${hours}h`;
    }

    function enhanceParlayName(parlay) {
      // If parlay doesn't have legs, return original name
      if (!parlay.legs || !Array.isArray(parlay.legs) || parlay.legs.length === 0) {
        return parlay.name || 'Unnamed Parlay';
      }

      // Get unique teams from all legs
      const allTeams = new Set();
      parlay.legs.forEach(leg => {
        if (leg.away) allTeams.add(leg.away);
        if (leg.home) allTeams.add(leg.home);
      });

      // Only proceed if exactly 2 teams are involved
      if (allTeams.size !== 2) {
        return parlay.name || 'Unnamed Parlay';
      }

      // Get away and home teams from the first leg
      const away = parlay.legs[0].away;
      const home = parlay.legs[0].home;

      // Convert full team names to abbreviations
      const teamAbbrevMap = {
        'Atlanta Falcons': 'Falcons', 'Buffalo Bills': 'Bills', 'Carolina Panthers': 'Panthers',
        'Chicago Bears': 'Bears', 'Cincinnati Bengals': 'Bengals', 'Cleveland Browns': 'Browns',
        'Dallas Cowboys': 'Cowboys', 'Denver Broncos': 'Broncos', 'Detroit Lions': 'Lions',
        'Green Bay Packers': 'Packers', 'Houston Texans': 'Texans', 'Indianapolis Colts': 'Colts',
        'Jacksonville Jaguars': 'Jaguars', 'Kansas City Chiefs': 'Chiefs', 'Las Vegas Raiders': 'Raiders',
        'Los Angeles Chargers': 'Chargers', 'Los Angeles Rams': 'Rams', 'Miami Dolphins': 'Dolphins',
        'Minnesota Vikings': 'Vikings', 'New England Patriots': 'Patriots', 'New Orleans Saints': 'Saints',
        'New York Giants': 'Giants', 'New York Jets': 'Jets', 'Philadelphia Eagles': 'Eagles',
        'Pittsburgh Steelers': 'Steelers', 'San Francisco 49ers': '49ers', 'Seattle Seahawks': 'Seahawks',
        'Tampa Bay Buccaneers': 'Buccaneers', 'Tennessee Titans': 'Titans', 'Washington Commanders': 'Commanders',
        'Arizona Cardinals': 'Cardinals', 'Baltimore Ravens': 'Ravens'
      };

      const awayAbbrev = teamAbbrevMap[away] || away;
      const homeAbbrev = teamAbbrevMap[home] || home;
      const matchup = `${awayAbbrev} @ ${homeAbbrev}`;

      // Check if the matchup or team names are already in the parlay name
      const parlayName = parlay.name || '';
      const nameContainsMatchup = parlayName.includes('@') ||
                                   parlayName.includes(awayAbbrev) ||
                                   parlayName.includes(homeAbbrev) ||
                                   parlayName.includes(away) ||
                                   parlayName.includes(home);

      // If matchup info not already in name, append it
      if (!nameContainsMatchup) {
        return `${parlayName} - ${matchup}`;
      }

      return parlayName;
    }

    // Player position mapping
    const playerPositions = {
      // Quarterbacks
      "Patrick Mahomes": "QB", "Jayden Daniels": "QB", "Josh Allen": "QB", "Lamar Jackson": "QB",
      "Baker Mayfield": "QB", "Geno Smith": "QB", "Sam Darnold": "QB", "Kyler Murray": "QB",
      "Jared Goff": "QB", "Matthew Stafford": "QB", "Justin Herbert": "QB", "Joe Burrow": "QB",
      "Jalen Hurts": "QB", "Dak Prescott": "QB", "Bo Nix": "QB", "Jordan Love": "QB",
      "Mac Jones": "QB", "Caleb Williams": "QB", "Drake Maye": "QB", "Aaron Rodgers": "QB",
      "Trevor Lawrence": "QB", "Russell Wilson": "QB", "Daniel Jones": "QB", "Joe Flacco": "QB",
      "Spencer Rattler": "QB", "Michael Penix Jr.": "QB", "Marcus Mariota": "QB", "Carson Wentz": "QB",
      "J.J. McCarthy": "QB", "Dillon Gabriel": "QB", "Tua Tagovailoa": "QB",
      // Running Backs
      "Isiah Pacheco": "RB", "Saquon Barkley": "RB", "Christian McCaffrey": "RB", "Derrick Henry": "RB",
      "De'Von Achane": "RB",
      "Jordan Mason": "RB", "Kenneth Walker III": "RB", "Bucky Irving": "RB", "Bijan Robinson": "RB",
      "Aaron Jones": "RB", "D'Andre Swift": "RB", "Kyren Williams": "RB", "Javonte Williams": "RB",
      "Jonathan Taylor": "RB", "David Montgomery": "RB", "Jahmyr Gibbs": "RB", "James Cook": "RB",
      "Travis Etienne": "RB", "Trey Benson": "RB", "Zach Charbonnet": "RB", "Omarion Hampton": "RB",
      "Tyler Allgeier": "RB", "Roschon Johnson": "RB", "Jaylen Warren": "RB", "Rhamondre Stevenson": "RB",
      "Rico Dowdle": "RB", "Jacory Croskey-Merritt": "RB", "Brashard Smith": "RB",
      // Wide Receivers
      "Rashee Rice": "WR", "Terry McLaurin": "WR", "Xavier Worthy": "WR", "Marquise Brown": "WR",
      "Deebo Samuel": "WR", "CeeDee Lamb": "WR", "George Pickens": "WR", "A.J. Brown": "WR",
      "DeVonta Smith": "WR", "Devonta Smith": "WR", "Malik Nabers": "WR", "Zay Flowers": "WR",
      "Khalil Shakir": "WR", "Justin Jefferson": "WR", "D.J. Moore": "WR", "Jakobi Meyers": "WR",
      "Keenan Allen": "WR", "Amon-Ra St. Brown": "WR", "Jaxon Smith-Njigba": "WR", 
      "Marvin Harrison Jr.": "WR", "Michael Wilson": "WR", "Puka Nacua": "WR", "Cooper Kupp": "WR",
      "Davante Adams": "WR", "Michael Pittman Jr.": "WR", "Stefon Diggs": "WR", "Dyami Brown": "WR",
      "Drake London": "WR", "Ja'Marr Chase": "WR", "DK Metcalf": "WR", "Rome Odunze": "WR",
      "Jordan Addison": "WR", "Ladd McConkey": "WR", "Matthew Golden": "WR", "Quentin Johnston": "WR",
      "Emeka Egbuka": "WR", "Travis Hunter": "WR", "Malik Washington": "WR",
      // Tight Ends
      "Travis Kelce": "TE", "Dalton Kincaid": "TE", "Mark Andrews": "TE", "T.J. Hockenson": "TE",
      "Tucker Kraft": "TE", "Sam LaPorta": "TE", "Trey McBride": "TE", "Dallas Goedert": "TE",
      "Jake Ferguson": "TE", "Zach Ertz": "TE", "Cade Otton": "TE"
    };

    // Helper to get player team abbreviation from full team name
    function getPlayerTeamAbbr(playerName, teamFull) {
      if (!teamFull) return '';
      const teamAbbrevMap = {
        'Atlanta Falcons': 'Falcons', 'Buffalo Bills': 'Bills', 'Carolina Panthers': 'Panthers',
        'Chicago Bears': 'Bears', 'Cincinnati Bengals': 'Bengals', 'Cleveland Browns': 'Browns',
        'Dallas Cowboys': 'Cowboys', 'Denver Broncos': 'Broncos', 'Detroit Lions': 'Lions',
        'Green Bay Packers': 'Packers', 'Houston Texans': 'Texans', 'Indianapolis Colts': 'Colts',
        'Jacksonville Jaguars': 'Jaguars', 'Kansas City Chiefs': 'Chiefs', 'Las Vegas Raiders': 'Raiders',
        'Los Angeles Chargers': 'Chargers', 'Los Angeles Rams': 'Rams', 'Miami Dolphins': 'Dolphins',
        'Minnesota Vikings': 'Vikings', 'New England Patriots': 'Patriots', 'New Orleans Saints': 'Saints',
        'New York Giants': 'Giants', 'New York Jets': 'Jets', 'Philadelphia Eagles': 'Eagles',
        'Pittsburgh Steelers': 'Steelers', 'San Francisco 49ers': '49ers', 'Seattle Seahawks': 'Seahawks',
        'Tampa Bay Buccaneers': 'Buccaneers', 'Tennessee Titans': 'Titans', 'Washington Commanders': 'Commanders',
        'Arizona Cardinals': 'Cardinals', 'Baltimore Ravens': 'Ravens'
      };
      return teamAbbrevMap[teamFull] || teamFull.split(' ').pop(); // Fallback to last word
    }

    // Player to team mapping (from backend)
    const playerTeams = {
      "Saquon Barkley": "Philadelphia Eagles", "A.J. Brown": "Philadelphia Eagles",
      "DeVonta Smith": "Philadelphia Eagles", "Devonta Smith": "Philadelphia Eagles",
      "George Pickens": "Dallas Cowboys", "CeeDee Lamb": "Dallas Cowboys",
      "Jake Ferguson": "Dallas Cowboys", "Dallas Goedert": "Philadelphia Eagles",
      "Javonte Williams": "Denver Broncos", "Terry McLaurin": "Washington Commanders",
      "Malik Nabers": "New York Giants", "Jayden Daniels": "Washington Commanders",
      "Russell Wilson": "New York Giants", "Lamar Jackson": "Baltimore Ravens",
      "Josh Allen": "Buffalo Bills", "Zay Flowers": "Baltimore Ravens",
      "Khalil Shakir": "Buffalo Bills", "James Cook": "Buffalo Bills",
      "Dalton Kincaid": "Buffalo Bills", "Derrick Henry": "Baltimore Ravens",
      "Mark Andrews": "Baltimore Ravens", "Aaron Jones": "Minnesota Vikings",
      "D'Andre Swift": "Chicago Bears", "T.J. Hockenson": "Minnesota Vikings",
      "Justin Jefferson": "Minnesota Vikings", "Caleb Williams": "Chicago Bears",
      "D.J. Moore": "Chicago Bears", "Tucker Kraft": "Green Bay Packers",
      "Kyren Williams": "Los Angeles Rams", "Geno Smith": "Seattle Seahawks",
      "Justin Herbert": "Los Angeles Chargers", "Jakobi Meyers": "Las Vegas Raiders",
      "Keenan Allen": "Chicago Bears", "Patrick Mahomes": "Kansas City Chiefs",
      "Bucky Irving": "Tampa Bay Buccaneers", "Bijan Robinson": "Atlanta Falcons",
      "Jordan Mason": "San Francisco 49ers", "Kenneth Walker III": "Seattle Seahawks",
      "Amon-Ra St. Brown": "Detroit Lions", "Jared Goff": "Detroit Lions",
      "Sam LaPorta": "Detroit Lions", "Kyler Murray": "Arizona Cardinals",
      "Sam Darnold": "Seattle Seahawks", "Trey Benson": "Arizona Cardinals",
      "Jaxon Smith-Njigba": "Seattle Seahawks", "Marvin Harrison Jr.": "Arizona Cardinals",
      "Trey McBride": "Arizona Cardinals", "Michael Wilson": "Arizona Cardinals",
      "Zach Charbonnet": "Seattle Seahawks", "Matthew Stafford": "Los Angeles Rams",
      "Daniel Jones": "Indianapolis Colts", "Puka Nacua": "Los Angeles Rams",
      "Cooper Kupp": "Los Angeles Rams", "Jonathan Taylor": "Indianapolis Colts",
      "Davante Adams": "Los Angeles Chargers", "Michael Pittman Jr.": "Indianapolis Colts",
      "Omarion Hampton": "Los Angeles Chargers", "Spencer Rattler": "New Orleans Saints",
      "David Montgomery": "Detroit Lions", "Jordan Love": "Green Bay Packers",
      "Mac Jones": "San Francisco 49ers", "Christian McCaffrey": "San Francisco 49ers",
      "Bo Nix": "Denver Broncos", "Jalen Hurts": "Philadelphia Eagles",
      "Stefon Diggs": "Houston Texans", "Drake Maye": "New England Patriots",
      "Dyami Brown": "Washington Commanders", "Isiah Pacheco": "Kansas City Chiefs",
      "Trevor Lawrence": "Jacksonville Jaguars", "Xavier Worthy": "Kansas City Chiefs",
      "Travis Kelce": "Kansas City Chiefs", "Marquise Brown": "Kansas City Chiefs",
      "Travis Etienne": "Jacksonville Jaguars", "Jahmyr Gibbs": "Detroit Lions",
      "Tyler Allgeier": "Atlanta Falcons", "Drake London": "Atlanta Falcons",
      "Roschon Johnson": "Chicago Bears", "Zach Ertz": "Washington Commanders",
      "Aaron Rodgers": "New York Jets", "Joe Flacco": "Indianapolis Colts",
      "Ja'Marr Chase": "Cincinnati Bengals", "DK Metcalf": "Seattle Seahawks",
      "Jaylen Warren": "Pittsburgh Steelers", "Rome Odunze": "Chicago Bears",
      "Michael Penix Jr.": "Atlanta Falcons", "Cade Otton": "Tampa Bay Buccaneers",
      "Baker Mayfield": "Tampa Bay Buccaneers", "Rhamondre Stevenson": "New England Patriots",
      "Rico Dowdle": "Dallas Cowboys", "Deebo Samuel": "San Francisco 49ers",
      "Rashee Rice": "Kansas City Chiefs",
      // Additional players
      "Marcus Mariota": "Washington Commanders", "Carson Wentz": "Kansas City Chiefs",
      "J.J. McCarthy": "Minnesota Vikings", "Jacory Croskey-Merritt": "Washington Commanders",
      "Brashard Smith": "Miami Dolphins", "Jordan Addison": "Minnesota Vikings",
      "Ladd McConkey": "Los Angeles Chargers", "Matthew Golden": "Houston Texans",
      "Quentin Johnston": "Los Angeles Chargers", "Tua Tagovailoa": "Miami Dolphins",
      "Malik Washington": "Miami Dolphins", "De'Von Achane": "Miami Dolphins",
      // College players
      "Dillon Gabriel": "Oregon Ducks", "Emeka Egbuka": "Ohio State Buckeyes",
      "Travis Hunter": "Colorado Buffaloes"
    };

    // Helper to get player team and position display with jersey number
    function getPlayerTeamPosition(leg) {
      if (!leg.player) return ''; // No player = team bet (moneyline/spread)
      
      const isSpreadOrML = leg.stat === 'spread' || leg.stat === 'moneyline';
      if (isSpreadOrML) return ''; // Don't show for team bets
      
      // Prioritize leg data (from database), fallback to hardcoded dictionaries
      const position = leg.position || playerPositions[leg.player] || '';
      
      // Get team abbreviation - prioritize leg.team
      let teamAbbr = '';
      if (leg.team) {
        teamAbbr = getPlayerTeamAbbr(leg.player, leg.team);
      } else if (playerTeams[leg.player]) {
        teamAbbr = getPlayerTeamAbbr(leg.player, playerTeams[leg.player]);
      }
      
      // Get jersey number if available
      const jerseyNum = leg.jersey_number ? `#${leg.jersey_number}` : '';
      
      // Build display string: "SEA RB #55" or "SEA RB" or "SEA #55"
      if (position && teamAbbr && jerseyNum) {
        return `${teamAbbr} ${position} ${jerseyNum}`;
      } else if (position && teamAbbr) {
        return `${teamAbbr} ${position}`;
      } else if (teamAbbr && jerseyNum) {
        return `${teamAbbr} ${jerseyNum}`;
      } else if (teamAbbr) {
        return teamAbbr;
      } else if (position && jerseyNum) {
        return `${position} ${jerseyNum}`;
      } else if (position) {
        return position;
      }
      
      return '';
    }

    async function update(){
      msg.textContent='Fetching data...';
      try{
        // Clear ALL caches to get fresh data (same as login)
        // 1. Clear backend server-side cache
        try {
          await fetchWithAdminToken(`${API_BASE}/api/cache-bust`, { method: 'POST' });
          console.log('✅ Server cache cleared');
        } catch (e) {
          console.warn('Could not clear server cache:', e);
        }
        
        // 2. Clear frontend in-memory caches
        cachedLive = null;
        cachedHistorical = null;
        console.log('✅ Frontend memory caches cleared');
        
        // 3. Clear localStorage caches
        clearHistoricalCache();
        console.log('✅ LocalStorage cache cleared');
        
        // 4. Clear service worker caches
        if ('caches' in window) {
          try {
            const cacheNames = await caches.keys();
            await Promise.all(cacheNames.map(name => caches.delete(name)));
            console.log(`✅ Cleared ${cacheNames.length} service worker caches`);
          } catch (e) {
            console.warn('Could not clear service worker caches:', e);
          }
        }
        
        // First process any new parlays
        await fetchWithAdminToken(statsUrl);
        
        // Get active tab
        const activeTab = document.querySelector('.tab.active').dataset.tab;
        
        // Only fetch data for the active tab; use cache if available
        if(activeTab === 'current') {
          // Fetch both todays and live bets and combine them
          const todaysUrl = `${API_BASE}/todays`;
          const [todaysResponse, liveResponse] = await Promise.all([
            fetchWithAdminToken(todaysUrl),
            fetchWithAdminToken(liveUrl)
          ]);
          
          if(!todaysResponse.ok) throw new Error(`Todays data error: ${todaysResponse.status}`);
          if(!liveResponse.ok) throw new Error(`Live data error: ${liveResponse.status}`);
          
          const todaysParlays = await todaysResponse.json();
          const liveParlays = await liveResponse.json();
          
          // Combine both arrays
          const combinedParlays = [...todaysParlays, ...liveParlays];
          cachedLive = combinedParlays;
          
          console.log('Todays parlays:', todaysParlays);
          console.log('Live parlays:', liveParlays);
          console.log('Combined parlays:', combinedParlays);
          
          render(combinedParlays, sec);
          msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
        } else if(activeTab === 'historical') {
          // Always fetch fresh data (don't use localStorage cache)
          // This ensures we get the same fresh data as login does
          const histUrl = `${API_BASE}/historical?t=${Date.now()}`;
          const historicalResponse = await fetchWithAdminToken(histUrl);
          if(!historicalResponse.ok) throw new Error(`Historical data error: ${historicalResponse.status}`);
          const historical = await historicalResponse.json();

          // Save to both memory and localStorage cache
          cachedHistorical = historical;
          saveHistoricalCache(historical);

          console.log('Historical parlays fetched (fresh):', historical);
          render(historical, histSec);
          msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
        } else if(activeTab === 'archived') {
          // Fetch archived bets with cache busting
          const archivedUrl = `${API_BASE}/api/archived?t=${Date.now()}`;
          const archivedResponse = await fetchWithAdminToken(archivedUrl);
          if(!archivedResponse.ok) throw new Error(`Archived data error: ${archivedResponse.status}`);
          const archivedData = await archivedResponse.json();
          const archivedBets = archivedData.archived || [];

          console.log('Archived bets:', archivedBets);
          const archSec = document.getElementById('archived-sections');
          render(archivedBets, archSec);
          msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
        } else if(activeTab === 'issues') {
          // Fetch issues data
          const issuesUrl = `${API_BASE}/issues?t=${Date.now()}`;
          const issuesResponse = await fetchWithAdminToken(issuesUrl);
          if(!issuesResponse.ok) throw new Error(`Issues data error: ${issuesResponse.status}`);
          const issuesData = await issuesResponse.json();
          
          console.log('Issues data:', issuesData);
          const issuesSec = document.getElementById('issues-sections');
          renderIssues(issuesData.issues || [], issuesSec);
          msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
        }        // Update cache display after rendering
        updateCacheDisplay();
      }catch(e){
        console.error('Error during update:', e);
        msg.textContent=`Error loading data: ${e.message}`;
      }
    }

    function renderIssues(issues, container){
      console.log('Render issues called with:', issues);
      container.innerHTML = '';
      
      if (!Array.isArray(issues)) {
        container.innerHTML = '<div class="error">Invalid issues data</div>';
        return;
      }
      
      if (issues.length === 0) {
        container.innerHTML = '<div class="no-issues">No issues found</div>';
        return;
      }
      
      const issuesList = document.createElement('div');
      issuesList.className = 'issues-list';
      
      issues.forEach((issue, index) => {
        const issueItem = document.createElement('div');
        issueItem.className = 'issue-item';
        issueItem.innerHTML = `
          <div class="issue-number">${index + 1}.</div>
          <div class="issue-text">${issue}</div>
        `;
        issuesList.appendChild(issueItem);
      });
      
      container.appendChild(issuesList);
    }

    async function loadHistorical(){
      msg.textContent='Loading historical bets...';
      try{
        console.log('Fetching from:', histUrl);
        const r=await fetchWithAdminToken(histUrl);
        if(!r.ok)throw r.status;
        const historical=await r.json();
        console.log('Received historical data:', historical);
        render(historical, histSec);
        msg.textContent=`Historical data loaded: ${new Date().toLocaleTimeString()}`;
      }catch(e){
        console.error('Error loading historical data:', e);
        msg.textContent='Error loading historical data: ' + e.toString();
      }
    }

    function render(parlays, container){
      console.log('Render called with parlays:', parlays);
      console.log('Container:', container);
      container.innerHTML='';
      if (!Array.isArray(parlays)) {
        console.error('parlays is not an array:', parlays);
        return;
      }

      // Filter out invalid parlays that don't have proper legs structure
      const validParlays = parlays.filter(parlay => {
        return parlay && typeof parlay === 'object' && 
               (!parlay.legs || (Array.isArray(parlay.legs) && parlay.legs.every(leg => leg && typeof leg === 'object')));
      });

      if (validParlays.length !== parlays.length) {
        console.warn('Filtered out', parlays.length - validParlays.length, 'invalid parlays from render');
      }

      // Check if this is the historical section
      const isHistoricalSection = container.id === 'historical-sections' || container.dataset.tab === 'historical';
      
      // Sort parlays by game date and time
      const sortedParlays = [...validParlays].sort((a, b) => {
        // For historical: use earliest date (latest games first - descending)
        // For live: use latest date (earliest games first - ascending)
        const getRelevantDate = (parlay) => {
          if (!parlay.legs || !Array.isArray(parlay.legs) || parlay.legs.length === 0) return new Date('9999-12-31');
          
          const dates = parlay.legs
            .map(leg => leg.game_date)
            .filter(date => date)
            .map(date => new Date(date));
          
          if (dates.length === 0) return new Date('9999-12-31');
          
          // For live bets: use LATEST game date (so multi-game parlays sort by their last game)
          // For historical: use EARLIEST game date (to show most recent first)
          if (isHistoricalSection) {
            return new Date(Math.min(...dates));
          } else {
            return new Date(Math.max(...dates));
          }
        };
        
        // Get game start time from the parlay's games data
        const getStartTime = (parlay, relevantDate) => {
          if (!parlay.games || parlay.games.length === 0) return null;
          
          // Find the game matching the relevant date
          const relevantDateStr = relevantDate.toISOString().split('T')[0];
          const game = parlay.games.find(g => g.game_date === relevantDateStr);
          
          if (game && game.startDateTime) {
            return new Date(game.startDateTime);
          }
          return null;
        };
        
        const dateA = getRelevantDate(a);
        const dateB = getRelevantDate(b);
        
        // First sort by date
        const dateCompare = isHistoricalSection ? dateB - dateA : dateA - dateB;
        
        // If dates are the same, sort by start time
        if (dateCompare === 0) {
          const timeA = getStartTime(a, dateA);
          const timeB = getStartTime(b, dateB);
          
          if (timeA && timeB) {
            const timeCompare = isHistoricalSection ? timeB - timeA : timeA - timeB;
            
            // If times are also the same, sort by number of legs (fewer legs first)
            if (timeCompare === 0) {
              const legsA = a.legs ? a.legs.length : 0;
              const legsB = b.legs ? b.legs.length : 0;
              return legsA - legsB; // Ascending order (fewer legs first)
            }
            
            return timeCompare;
          }
        }
        
        return dateCompare;
      });

      // Show a helpful empty-state when there's no data for the tab
      if (sortedParlays.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'no-data';
        const tabName = container.dataset.tab === 'historical' ? 'Historical Bets' : "Live Bets";
        empty.innerHTML = `
          <div style="text-align:center;padding:2rem;color:#bbb">
            <strong>No parlays found</strong>
            <div style="margin-top:.5rem">There are no ${tabName} to display right now.</div>
            <button id="empty-refresh" style="margin-top:1rem;padding:.5rem 1rem;border-radius:6px;background:#140d52;color:#fff;border:none;cursor:pointer">Refresh</button>
          </div>`;
        container.appendChild(empty);
        // wire the refresh button to re-run update()
        const b = empty.querySelector('#empty-refresh');
        if (b) b.addEventListener('click', update);
        return;
      }
      
      // Render all parlays in their respective sections (isHistoricalSection already defined above for sorting)
      sortedParlays.forEach(parlay=>{
        console.log('Processing parlay:', parlay);
        const section=document.createElement('div');
        section.className='parlay-section';
        section.dataset.site = parlay.betting_site || 'Unknown'; // For color-coding and filtering
        section.dataset.sport = parlay.sport || ''; // For sport filtering
        section.dataset.betDate = parlay.bet_date || ''; // For date filtering
        
        const header=document.createElement('div');
        header.className='parlay-header';
        
        // Use parlay.name from bet_data for header display
        const displayName = parlay.name || enhanceParlayName(parlay);
        
        // Check if all legs are Hit AND all games are final (winning bet deserves trophy)
        const allLegsComplete = parlay.legs && Array.isArray(parlay.legs) && parlay.legs.length > 0 && 
          parlay.legs.every(leg => {
            // PRIORITY 1: Check database status for completed games (historical bets)
            if (leg.status === 'won') {
              return true; // Leg won according to database
            }
            if (leg.status === 'lost') {
              return false; // Leg lost according to database
            }
            
            // PRIORITY 2: Check ESPN game data for live/current games
            // Get game data for this leg
            const gameData = parlay.games ? parlay.games.find(g => 
              g.teams.away === leg.away && g.teams.home === leg.home
            ) : null;
            
            // Game must be final to count as complete (only if no database status)
            if (!gameData || gameData.statusTypeName !== 'STATUS_FINAL') {
              return false;
            }
            
            const current = leg.current ?? 0;
            const pct = leg.target > 0 ? Math.min(100, Math.round(current / leg.target * 100)) : 0;
            const isSpreadOrML = leg.stat === 'spread' || leg.stat === 'moneyline';
            const isTotalPoints = leg.stat === 'total_points' || leg.stat === 'total_points_under' || leg.stat === 'total_points_over';
            const statAdd = leg.stat_add || null;
            
            // Check if leg actually Hit (not just 100%)
            if (isSpreadOrML) {
              const scoreDiff = leg.score_diff ?? 0;
              if (leg.stat === 'moneyline') {
                return scoreDiff > 0; // Win = positive score diff
              } else if (leg.stat === 'spread') {
                return (scoreDiff + leg.target) > 0; // Covering spread
              }
            } else if (isTotalPoints) {
              // Use stat_add to determine if it's over or under
              // Fall back to old stat names for backward compatibility
              const isUnder = statAdd === 'under' || leg.stat === 'total_points_under';
              const isOver = statAdd === 'over' || leg.stat === 'total_points_over';
              
              if (isUnder) {
                return current < leg.target; // Under = current less than target
              } else if (isOver) {
                return current > leg.target; // Over = current more than target
              }
            } else {
              // Player props: Check stat_add for over/under
              if (statAdd === 'under') {
                return current < leg.target; // Under props
              } else if (statAdd === 'over' || statAdd === null) {
                // Default to "over" behavior (reach target)
                return pct === 100;
              }
            }
            
            return false;
          });
        
        // Get game date for single game parlays
        let formattedDate = '';
        
        // Check if on mobile view
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
          // Mobile: prioritize bet_date field
          if (parlay.bet_date) {
            try {
              // Validate and sanitize date string before parsing
              let dateStr = String(parlay.bet_date).trim();
              
              // Handle common date formats
              let betDate;
              if (dateStr.includes('-')) {
                // ISO format YYYY-MM-DD
                betDate = new Date(dateStr + 'T00:00:00');
              } else if (dateStr.length === 8 && /^\d{8}$/.test(dateStr)) {
                // YYYYMMDD format
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(4, 6);
                const day = dateStr.substring(6, 8);
                betDate = new Date(`${year}-${month}-${day}T00:00:00`);
              } else {
                // Try parsing as-is
                betDate = new Date(dateStr);
              }
              
              if (betDate && !isNaN(betDate.getTime())) {
                const monthName = betDate.toLocaleDateString('en-US', { month: 'short' });
                const dayNum = betDate.getDate();
                const yearNum = betDate.getFullYear();
                formattedDate = `${monthName} ${dayNum}, ${yearNum}`;
              } else {
                formattedDate = 'input date';
              }
            } catch (e) {
              console.error('Error parsing bet_date:', parlay.bet_date, e);
              formattedDate = 'input date';
            }
          } else {
            // Fallback to 'input date' if no bet_date
            formattedDate = 'input date';
          }
        } else {
          // Desktop: show game_date in full format
          if (parlay.legs && Array.isArray(parlay.legs) && parlay.legs[0]) {
            // Get unique game dates from all legs
            const uniqueDates = [...new Set(parlay.legs.map(leg => leg.game_date))].filter(d => d);
            
            // If there's only one unique date, it's a single game parlay
            if (uniqueDates.length === 1 && uniqueDates[0]) {
              const dateStr = String(uniqueDates[0]);
              try {
                let gameDate;
                
                // Handle both formats: YYYY-MM-DD (new standard) and YYYYMMDD (legacy)
                if (dateStr.includes('-')) {
                  // YYYY-MM-DD format
                  gameDate = new Date(dateStr);
                } else if (dateStr.length === 8) {
                  // YYYYMMDD format (legacy)
                  const year = dateStr.substring(0, 4);
                  const month = dateStr.substring(4, 6);
                  const day = dateStr.substring(6, 8);
                  gameDate = new Date(`${year}-${month}-${day}`);
                }
                
                // Check if date is valid
                if (gameDate && !isNaN(gameDate.getTime())) {
                  const dayOfWeek = gameDate.toLocaleDateString('en-US', { weekday: 'long' });
                  const monthName = gameDate.toLocaleDateString('en-US', { month: 'short' });
                  const dayNum = gameDate.getDate();
                  const yearNum = gameDate.getFullYear();
                  formattedDate = `${dayOfWeek} - ${monthName} ${dayNum}, ${yearNum}`;
                }
              } catch (e) {
                console.error('Error parsing date:', dateStr, e);
              }
            } else if (uniqueDates.length > 1) {
              // Multi-game parlay: show bet_date if available
              if (parlay.bet_date) {
                try {
                  const betDate = new Date(parlay.bet_date);
                  if (betDate && !isNaN(betDate.getTime())) {
                    const monthName = betDate.toLocaleDateString('en-US', { month: 'short' });
                    const dayNum = betDate.getDate();
                    const yearNum = betDate.getFullYear();
                    formattedDate = `Bet Date: ${monthName} ${dayNum}, ${yearNum}`;
                  }
                } catch (e) {
                  console.error('Error parsing bet_date:', parlay.bet_date, e);
                }
              }
            }
          }
        }
        
        header.innerHTML = `
          ${allLegsComplete ? `<img src="media/trophy-1.svg" class="trophy-icon trophy-dark" alt="Won"><img src="media/trophy-2.svg" class="trophy-icon trophy-light" alt="Won">` : ''}
          <div class="parlay-title">
            <div class="parlay-title-text">
              <span class="collapse-icon">▼</span>
              <div>
                <div>${displayName}</div>
                ${formattedDate && `<span class="parlay-date">${formattedDate}</span>`}
              </div>
            </div>
          </div>
        `;
        
        // Store bet ID in section data attribute for selection
        section.dataset.betId = parlay.db_id;
        
        // Add 'won' class to winning bets for special styling
        if (allLegsComplete) {
          section.classList.add('won');
        }

        // Helper function to create scoreboard HTML
        const createScoreboard = (g) => {
          const stn=g.statusTypeName,isSched=stn==='STATUS_SCHEDULED',isLive=stn==='STATUS_IN_PROGRESS',isHalftime=stn==='STATUS_HALFTIME',isFinal=stn==='STATUS_FINAL';
          let gameStatus,gameCls,gameDetails;
          if(isSched){
            gameStatus='🔜';
            gameCls='status-pregame';
            const countdown = getCountdown(g.startDateTime);
            gameDetails=`<div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} @ ${getTeamAbbr(g.teams.home)}</div><div style="font-weight:normal;font-size:0.7rem;">${countdown || g.startTime}</div>`;
          }
          else if(isHalftime){gameStatus='HALF';gameCls='status-halftime';gameDetails=`<div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} ${g.score.away} - ${g.score.home} ${getTeamAbbr(g.teams.home)}</div>`;}
          else if(isLive){gameStatus='LIVE';gameCls='status-live';gameDetails=`<div style="font-weight:normal;font-size:0.7rem;">${getQuarter(g.period)}, ${g.clock}</div><div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} ${g.score.away} - ${g.score.home} ${getTeamAbbr(g.teams.home)}</div>`;}
          else{gameStatus='FINAL';gameCls='status-final';gameDetails=`<div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} ${g.score.away} - ${g.score.home} ${getTeamAbbr(g.teams.home)}</div>`;}
          
          const gameInfoDiv=document.createElement('div');
          gameInfoDiv.className=isFinal?'game-info two-line':'game-info';
          gameInfoDiv.innerHTML=`<img src="media/logos/nfl-logo-1.svg" class="nfl-logo-bg nfl-logo-dark" alt="NFL"><img src="media/logos/nfl-logo-2.svg" class="nfl-logo-bg nfl-logo-light" alt="NFL"><div class="badge ${gameCls}">${gameStatus}</div>${gameDetails}`;
          return gameInfoDiv;
        };

        // Determine if we should show scoreboards inline or with toggle
        const isSingleBet = parlay.type === 'Single Bet' || (parlay.legs && Array.isArray(parlay.legs) && parlay.legs.length === 1);
        const isSGP = parlay.type === 'Same Game Parlay' || parlay.type === 'SGP';
        
        // Collect all games
        let gamesToShow = [];
        if (parlay.games && parlay.games.length > 0) {
          if (parlay.type !== 'SGP' && parlay.type !== 'Same Game Parlay') {
            // For non-SGPs, get unique games
            const uniqueGames = new Map();
            if (parlay.legs && Array.isArray(parlay.legs) && parlay.legs.length > 0) {
              parlay.legs.forEach(leg => {
                const gameKey = `${leg.away}-${leg.home}`;
                const game = parlay.games.find(g => 
                  g.teams.away === leg.away && g.teams.home === leg.home
                );
                if (game && !uniqueGames.has(gameKey)) {
                  uniqueGames.set(gameKey, game);
                }
              });
            }
            gamesToShow = Array.from(uniqueGames.values());
          } else {
            gamesToShow = parlay.games;
          }
        } else if (parlay.legs && Array.isArray(parlay.legs) && parlay.legs.length > 0) {
          // For historical bets without ESPN game data, create game objects from leg data
          const uniqueGames = new Map();
          parlay.legs.forEach(leg => {
            if (leg.home && leg.away) {
              const gameKey = `${leg.away}-${leg.home}`;
              if (!uniqueGames.has(gameKey)) {
                // Create a mock game object from leg data
                const mockGame = {
                  teams: {
                    home: leg.home,
                    away: leg.away
                  },
                  score: {
                    home: leg.homeScore ?? 0,
                    away: leg.awayScore ?? 0
                  },
                  statusTypeName: leg.status === 'won' || leg.status === 'lost' ? 'STATUS_FINAL' : 'STATUS_SCHEDULED',
                  game_date: leg.game_date,
                  startDateTime: leg.game_date
                };
                uniqueGames.set(gameKey, mockGame);
              }
            }
          });
          gamesToShow = Array.from(uniqueGames.values());
        }

        // Show inline scoreboards for Single Bet, SGP, or single-game parlays
        if ((isSingleBet || isSGP || gamesToShow.length === 1) && gamesToShow.length > 0) {
          const allGamesDiv=document.createElement('div');
          allGamesDiv.className='game-info-wrapper';
          gamesToShow.forEach(g => allGamesDiv.appendChild(createScoreboard(g)));
          header.appendChild(allGamesDiv);
        }
        // For multi-game parlays (2+ games), add "Show Scores" toggle
        else if (gamesToShow.length > 1) {
          const showScoresBtn = document.createElement('button');
          showScoresBtn.className = 'show-scores-btn';
          showScoresBtn.textContent = 'Show Scores ▼';
          showScoresBtn.onclick = (e) => {
            e.stopPropagation();
            const scoreboardBlock = section.querySelector('.scoreboard-block');
            scoreboardBlock.classList.toggle('active');
            showScoresBtn.textContent = scoreboardBlock.classList.contains('active') ? 'Hide Scores ▲' : 'Show Scores ▼';
          };
          header.appendChild(showScoresBtn);

          // Create collapsible scoreboard block
          const scoreboardBlock = document.createElement('div');
          scoreboardBlock.className = 'scoreboard-block';
          
          // Split games into rows (9 per row for web, 3 per row for mobile - handled by CSS)
          const gamesPerRow = window.innerWidth > 768 ? 9 : 3;
          for (let i = 0; i < gamesToShow.length; i += gamesPerRow) {
            const rowGames = gamesToShow.slice(i, i + gamesPerRow);
            const row = document.createElement('div');
            row.className = 'scoreboard-row';
            rowGames.forEach(g => row.appendChild(createScoreboard(g)));
            scoreboardBlock.appendChild(row);
          }
          
          header.appendChild(scoreboardBlock);
        }

        const isAnyGameLive = parlay.games && parlay.games.some(g=>g.statusTypeName==='STATUS_IN_PROGRESS' || g.statusTypeName==='STATUS_HALFTIME');
        const areAllGamesFinal = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_FINAL');
        const areAllGamesScheduled = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_SCHEDULED');

        // Sort legs by status for Live Bets: "In Progress" → "Not Started" → "Hit"
        // Only sort for live bets tab, not historical
        let legsToRender = Array.isArray(parlay.legs) ? parlay.legs : [];
        if (!isHistoricalSection && Array.isArray(parlay.legs)) {
          legsToRender = [...parlay.legs].sort((a, b) => {
            // Helper function to determine leg status
            const getLegStatus = (leg) => {
              // PRIORITY 1: Check database status for completed games (historical bets)
              // If we have a definitive status from the database, use it
              if (leg.status === 'won') {
                return 'Hit';
              }
              if (leg.status === 'lost') {
                return 'Miss';
              }
              
              // PRIORITY 2: Check ESPN live game data (for current/live games)
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === leg.away && g.teams.home === leg.home
              ) : null;
              
              // Normalize stat to lowercase for comparison
              const statLower = (leg.stat || '').toLowerCase();
              const isSpreadOrML = statLower === 'spread' || statLower === 'moneyline';
              const current = leg.current ?? 0;
              const pct = leg.target > 0 ? Math.min(100, Math.round(current / leg.target * 100)) : 0;
              
              // Check leg.gameStatus first (from database), then fall back to gameData
              const gameStatus = leg.gameStatus || (gameData ? gameData.statusTypeName : null);
              
              // Check if game is in progress
              if (gameStatus === 'in_progress' || gameStatus === 'STATUS_IN_PROGRESS' || gameStatus === 'STATUS_HALFTIME') {
                // For in-progress spread/moneyline bets, check if currently winning/losing
                if (isSpreadOrML && current !== null) {
                  const scoreDiff = leg.score_diff ?? current;
                  let isWinning = false;
                  if (statLower === 'moneyline') {
                    isWinning = scoreDiff > 0;
                  } else if (statLower === 'spread') {
                    isWinning = (scoreDiff + leg.target) > 0;
                  }
                  return isWinning ? 'In Progress (Winning)' : 'In Progress (Losing)';
                }
                return 'In Progress';
              }
              
              // Check if not started
              if (gameStatus === 'scheduled' || gameStatus === 'STATUS_SCHEDULED' || gameStatus === 'pre') {
                return 'Not Started';
              }
              if (!gameStatus && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))) {
                return 'Not Started';
              }
              
              // Check if game is final/completed
              if (gameStatus === 'completed' || gameStatus === 'final' || gameStatus === 'STATUS_FINAL') {
                if (isSpreadOrML) {
                  const scoreDiff = leg.score_diff ?? current;
                  let isWinningBet = false;
                  if (statLower === 'moneyline') {
                    isWinningBet = scoreDiff > 0;
                  } else if (statLower === 'spread') {
                    isWinningBet = (scoreDiff + leg.target) > 0;
                  }
                  return isWinningBet ? 'Hit' : 'Miss';
                }
                // For other stats, check if target was reached
                if (pct >= 100) {
                  return 'Hit';
                } else {
                  return 'Miss';
                }
              }
              
              // Check if hit (100% or winning bet for non-final games)
              if (!isSpreadOrML && pct >= 100) {
                return 'Hit';
              }
              
              return 'In Progress'; // Default
            };
            
            const statusA = getLegStatus(a);
            const statusB = getLegStatus(b);
            
            // Sort order: "In Progress" → "Not Started" → "Hit" → "Miss"
            const statusOrder = {
              'In Progress': 0,
              'Not Started': 1,
              'Hit': 2,
              'Miss': 3
            };
            
            return (statusOrder[statusA] ?? 99) - (statusOrder[statusB] ?? 99);
          });
        }

        const table=document.createElement('table');
        table.innerHTML=`
          <thead><tr>
            <th style="display:none;"></th>
            <th style="display:none;"></th>
            <th>Player</th><th>Stat Type</th><th>Current</th>
            <th>Target</th><th style="width:25%;">Progress</th><th>Status</th>
          </tr></thead>
          <tbody>
            ${legsToRender.map(p=>{
              const current = p.current ?? 0; // Handle undefined/null as 0
              const pct = p.target > 0 ? Math.min(100, Math.round(current / p.target * 100)) : 0;
              
              let txt; // Declare txt variable to avoid 'txt is not defined' error
              
              // Check if this is a spread or moneyline bet (no progress bar)
              const isSpreadOrML = p.stat === 'spread' || p.stat === 'moneyline';
              
              // Check if this is a total points over/under bet
              const isTotalPoints = p.stat === 'total_points' || p.stat === 'total_points_under' || p.stat === 'total_points_over';
              const statAdd = p.stat_add || p.over_under || null;
              
              // Get game data for this leg
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === p.away && g.teams.home === p.home
              ) : null;
              
              let progressCol = '';
              let currentDisplay = p.current_display || current;
              let targetDisplay = p.target;
              
              // For spread/moneyline, use team name; for player props, use player name
              let playerDisplay = p.player || p.team || 'N/A';
              
              // Use backend-calculated display values if available
              let useBackendValues = false;
              if (p.progress_display) {
                const colorStyle = p.progress_color ? `color: ${p.progress_color === 'green' ? '#4caf50' : p.progress_color === 'red' ? '#f44336' : p.progress_color === 'yellow' ? '#ffeb3b' : 'inherit'};` : '';
                progressCol = `<div style="text-align:center;padding:0.5rem;font-weight:bold;${colorStyle}">${p.progress_display}</div>`;
                useBackendValues = true;
              } else {
                // Fallback to old logic if backend values not available
                progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
              }
              
              // Skip old frontend logic if we have backend values
              if (!useBackendValues) {
              if (isSpreadOrML && p.team) {
                // Extract just the team name (e.g., "Dallas Cowboys" -> "Cowboys")
                playerDisplay = p.team.split(' ').pop();
              } else if (isSpreadOrML && (p.home || p.away)) {
                // Fallback: use home or away team from game data
                const betTeam = p.home || p.away;
                playerDisplay = betTeam.split(' ').pop();
              }
              
              // Handle total points over/under - show matchup as "player"
              if (isTotalPoints && p.away && p.home) {
                // Get friendly team names (e.g., "Tampa" instead of "TB", "Saints" instead of "NO")
                const getFriendlyTeamName = (fullName) => {
                  // Extract the last word (team name) from full name
                  const parts = fullName.split(' ');
                  return parts[parts.length - 1]; // Returns "Buccaneers", "Saints", etc.
                };
                
                const awayName = getFriendlyTeamName(p.away);
                const homeName = getFriendlyTeamName(p.home);
                playerDisplay = `${awayName} @ ${homeName}`;
                
                // Show progress bar with percentage for total points
                if (gameData) {
                  const awayScore = gameData.score.away;
                  const homeScore = gameData.score.home;
                  const totalScore = awayScore + homeScore;
                  
                  currentDisplay = totalScore;
                  
                  // Calculate percentage and show progress bar
                  const totalPct = p.target > 0 ? Math.min(100, Math.round(totalScore / p.target * 100)) : 0;
                  
                  // Determine if this is an under or over bet
                  const isTotalUnder = statAdd === 'under' || p.stat === 'total_points_under';
                  const isTotalOver = statAdd === 'over' || p.stat === 'total_points_over';
                  
                  let totalCls = '';
                  const areAllGamesFinal = parlay.games && parlay.games.every(g => g.statusTypeName === 'STATUS_FINAL');
                  
                  if (areAllGamesFinal) {
                    // Game is over - show green if bet hit, red if missed
                    if (isTotalUnder) {
                      // Under bet: hit if total < target
                      totalCls = (totalScore < p.target) ? 'pct-under-vlow' : 'pct-under-full';
                    } else {
                      // Over bet: hit if total > target
                      totalCls = (totalScore > p.target) ? 'pct-full' : 'pct-vlow';
                    }
                  } else {
                    // Game is live/in progress
                    if (isTotalUnder) {
                      // Reverse colors for under bets: 0-60% green, 60-80% yellow, 80-99% orange, 100% red
                      if (totalPct >= 100) {
                        totalCls = 'pct-under-full';  // Red at 100%+
                      } else if (totalPct >= 80) {
                        totalCls = 'pct-under-high';  // Orange 80-99%
                      } else if (totalPct >= 60) {
                        totalCls = 'pct-under-mid';   // Yellow 60-79%
                      } else {
                        totalCls = 'pct-under-vlow';  // Green 0-59%
                      }
                    } else {
                      // Normal colors for over bets
                      if (totalPct >= 100) {
                        totalCls = 'pct-full';
                      } else if (totalPct >= 60) {
                        totalCls = 'pct-mid';
                      } else if (totalPct >= 20) {
                        totalCls = 'pct-low';
                      } else if (totalPct > 0) {
                        totalCls = 'pct-vlow';
                      }
                    }
                  }
                  
                  progressCol = `<div class="progress-bar ${totalCls}">
                           <div class="progress ${totalCls}" style="width:${totalPct}%"></div>
                           <div class="progress-text">${totalPct}%</div>
                         </div>`;
                } else {
                  progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
                }
              } else if (isSpreadOrML) {
                // For spread/moneyline, show score with bet team on left and opponent on right
                const scoreDiff = p.score_diff ?? 0;
                // Use player_team from bet leg for bet team
                const betTeam = p.player_team || p.team || '';
                const betTeamName = betTeam.split(' ').pop();

                // Determine if bet is currently winning or losing
                let isWinning = false;
                let progressColor = '';

                // Find opponent team name and scores
                let opponentTeamName = '';
                let betTeamScore = null;
                let oppTeamScore = null;

                if (gameData) {
                  // Use ESPN game data
                  const betTeamLower = betTeam.toLowerCase();
                  const homeLower = gameData.teams.home.toLowerCase();
                  const awayLower = gameData.teams.away.toLowerCase();
                  let isBetTeamHome = false, isBetTeamAway = false;
                  // Partial match: check if bet team name is included in home or away team name
                  if (homeLower.includes(betTeamLower)) {
                    isBetTeamHome = true;
                  } else if (awayLower.includes(betTeamLower)) {
                    isBetTeamAway = true;
                  }
                  if (isBetTeamHome) {
                    opponentTeamName = gameData.teams.away.split(' ').pop();
                    betTeamScore = gameData.score.home;
                    oppTeamScore = gameData.score.away;
                  } else if (isBetTeamAway) {
                    opponentTeamName = gameData.teams.home.split(' ').pop();
                    betTeamScore = gameData.score.away;
                    oppTeamScore = gameData.score.home;
                  } else {
                    // Fallback: if bet team doesn't match home/away, just show as is
                    opponentTeamName = (gameData.teams.home !== betTeam ? gameData.teams.home : gameData.teams.away).split(' ').pop();
                    betTeamScore = null;
                    oppTeamScore = null;
                  }

                  // Determine if bet is currently winning or losing
                  if (p.stat === 'moneyline') {
                    isWinning = scoreDiff > 0;
                  } else if (p.stat === 'spread') {
                    isWinning = (scoreDiff + p.target) > 0;
                  }
                  progressColor = isWinning ? 'color: #4caf50;' : 'color: #f44336;';
                } else if (p.homeScore !== undefined && p.awayScore !== undefined) {
                  // Use database scores (for historical games)
                  const isBetTeamHome = betTeam === p.home || (p.home && betTeam && p.home.includes(betTeamName));
                  if (isBetTeamHome) {
                    opponentTeamName = (p.away || '').split(' ').pop();
                    betTeamScore = p.homeScore;
                    oppTeamScore = p.awayScore;
                  } else {
                    opponentTeamName = (p.home || '').split(' ').pop();
                    betTeamScore = p.awayScore;
                    oppTeamScore = p.homeScore;
                  }
                  isWinning = p.status === 'won';
                  progressColor = isWinning ? 'color: #4caf50;' : 'color: #f44336;';
                }

                // Show score if available
                if (betTeamScore !== null && oppTeamScore !== null) {
                  progressCol = `<div style="text-align:center;padding:0.5rem;font-weight:bold;${progressColor}">${betTeamName} ${betTeamScore} - ${oppTeamScore} ${opponentTeamName}</div>`;
                } else {
                  // No game data yet (scheduled game)
                  progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
                }
                
                // For moneyline: current shows winning/losing status, target shows "Win"
                if (p.stat === 'moneyline') {
                  targetDisplay = 'Win';
                  if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                    const isFinal = gameData.statusTypeName === 'STATUS_FINAL';
                    if (scoreDiff > 0) {
                      currentDisplay = isFinal ? 'Win' : `Up ${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = isFinal ? 'Loss' : `Down ${Math.abs(scoreDiff)}`;
                    } else {
                      currentDisplay = 'Tied';
                    }
                  } else if (p.homeScore !== undefined && p.awayScore !== undefined) {
                    // Historical/completed games with scores from database
                    if (scoreDiff > 0) {
                      currentDisplay = 'Win';
                    } else if (scoreDiff < 0) {
                      currentDisplay = 'Loss';
                    } else {
                      currentDisplay = 'Tied';
                    }
                  } else {
                    // No game data yet
                    currentDisplay = '-';
                  }
                }
                
                // For spread: format target with +/- sign
                if (p.stat === 'spread') {
                  targetDisplay = p.target > 0 ? `+${p.target}` : `${p.target}`;
                  // Current shows score differential for all spread bets
                  if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                    // Show score differential (up/down) for live and final games
                    if (scoreDiff > 0) {
                      currentDisplay = `+${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = `${scoreDiff}`;
                    } else {
                      currentDisplay = '0';
                    }
                  } else if (p.homeScore !== undefined && p.awayScore !== undefined) {
                    // Historical/completed games with scores from database
                    if (scoreDiff > 0) {
                      currentDisplay = `+${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = `${scoreDiff}`;
                    } else {
                      currentDisplay = '0';
                    }
                  } else {
                    // No game data yet
                    currentDisplay = '-';
                  }
                }
                
              } else {
                // Regular progress bar for numeric stats
                let cls = '';
                const isUnderBet = statAdd === 'under';
                
                if (areAllGamesFinal) {
                  // Game is over - show green if bet hit, red if missed
                  if (isUnderBet) {
                    // Under bet: hit if current < target
                    cls = (current < p.target) ? 'pct-under-vlow' : 'pct-under-full';
                  } else {
                    // Over bet: hit if 100%
                    cls = (pct === 100) ? 'pct-full' : 'pct-vlow';
                  }
                } else {
                  // Game is live/in progress
                  if (isUnderBet) {
                    // Reverse colors for under bets: 0-60% green, 60-80% yellow, 80-99% orange, 100% red
                    if (pct === 100) {
                      cls = 'pct-under-full';  // Red at 100%
                    } else if (pct >= 80) {
                      cls = 'pct-under-high';  // Orange 80-99%
                    } else if (pct >= 60) {
                      cls = 'pct-under-mid';   // Yellow 60-79%
                    } else {
                      cls = 'pct-under-vlow';  // Green 0-59%
                    }
                  } else {
                    // Normal colors for over bets
                    if (pct === 100) {
                      cls = 'pct-full';
                    } else if (pct >= 60) {
                      cls = 'pct-mid';
                    } else if (pct >= 20) {
                      cls = 'pct-low';
                    } else if (pct > 0) {
                      cls = 'pct-vlow';
                    }
                  }
                }
                progressCol = `<div class="progress-bar ${cls}">
                           <div class="progress ${cls}" style="width:${pct}%"></div>
                           <div class="progress-text">${pct}%</div>
                         </div>`;
              }
              
              // Determine win/loss for total points over/under
              if (isTotalPoints && gameData) {
                const totalScore = current;
                // Use stat_add to determine if it's over or under
                // Fall back to old stat names for backward compatibility
                const isUnder = statAdd === 'under' || p.stat === 'total_points_under';
                const isOver = statAdd === 'over' || p.stat === 'total_points_over';
                
                if (isUnder) {
                  isWinningBet = totalScore < p.target;
                } else if (isOver) {
                  isWinningBet = totalScore > p.target;
                }
              }
              
              // Determine win/loss for spread/moneyline based on actual game result
              if (isSpreadOrML && gameData) {
                const scoreDiff = p.score_diff ?? 0;
                console.log(`[Status Check] ${p.team || p.player} - ${p.stat}: scoreDiff=${scoreDiff}, target=${p.target}, gameStatus=${gameData.statusTypeName}`);
                
                if (p.stat === 'moneyline') {
                  // Moneyline: just need to win (positive score difference)
                  isWinningBet = scoreDiff > 0;
                  console.log(`  Moneyline: scoreDiff > 0 = ${isWinningBet}`);
                } else if (p.stat === 'spread') {
                  // Spread: score_diff + spread > 0
                  // Example: -7 spread, win by 10 = 10 + (-7) = 3 > 0 ✓
                  // Example: +3.5 spread, lose by 3 = -3 + 3.5 = 0.5 > 0 ✓
                  isWinningBet = (scoreDiff + p.target) > 0;
                  console.log(`  Spread: (${scoreDiff} + ${p.target}) = ${scoreDiff + p.target} > 0 = ${isWinningBet}`);
                }
              }
              
              // Status logic - PRIORITY 1: Check database status for completed games (historical bets)
              if (p.status === 'won') {
                txt = '✅ Hit';
              } else if (p.status === 'lost') {
                txt = '🚫 Miss';
              } else if (p.status === 'pending' && !gameData) {
                // OCR bets that haven't been processed by ESPN API yet
                txt = '🔜 Not Started';
              } else if(gameData && gameData.statusTypeName === 'STATUS_SCHEDULED') {
                txt='🔜 Not Started';
              } else if(gameData && (gameData.statusTypeName === 'STATUS_IN_PROGRESS' || gameData.statusTypeName === 'STATUS_HALFTIME')) {
                txt='⏳ In Progress';
              } else if(!gameData && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))) {
                txt='🔜 Not Started';
              } else if((isSpreadOrML || isTotalPoints) && gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                // For spread/moneyline/totals, only show Hit/Miss when game is FINAL
                txt = isWinningBet ? '✅ Hit' : '🚫 Miss';
              } else if(!isSpreadOrML && !isTotalPoints) {
                // For numeric stats (player props), check stat_add for over/under
                let isHit = false;
                
                if (statAdd === 'under') {
                  // Under props: Hit when current < target
                  isHit = current < p.target;
                } else {
                  // Over props (or null/default): Hit when 100%
                  isHit = pct === 100;
                }
                
                if(isHit) txt='✅ Hit';
                else if(areAllGamesFinal) txt='🚫 Miss';
                else txt='⏳ In Progress';
              } else {
                txt='⏳ In Progress'; // Default to in progress
              }
              } // End of !useBackendValues condition
              
              // Format for mobile display
              const playerOrTeam = playerDisplay; // Use the calculated playerDisplay
              const statType = formatStatTypeWithUnder(p.stat, p.bet_line_type);
              const mobileCurrentDisplay = formatStatForMobile(currentDisplay, p.stat);
              const mobileTargetDisplay = formatStatForMobile(targetDisplay, p.stat);
              
              // Get team and position for player props
              // Reduce spacing between elements by 50% (0.15rem -> 0.075rem)
              const teamPosition = getPlayerTeamPosition(p);
              const playerCellContent = playerDisplay; // Use the same logic as playerDisplay
              const playerCellHTML = teamPosition ? 
                `<div>${playerCellContent}</div><div style="font-size:0.65rem;color:#999;margin-top:0.075rem;">${teamPosition}</div>` : 
                playerCellContent;
              
              // Mobile player name with stat type on same line, team/position below
              // Reduce spacing between elements by 75% (0.15rem -> 0.0375rem)
              const mobilePlayerHTML = teamPosition ? 
                `<strong>${playerOrTeam}</strong><span style="font-weight:normal;"> - ${statType}</span><div style="font-size:0.65rem;font-weight:bold;color:#999;margin-top:0.0375rem;">${teamPosition}</div>` : 
                `<strong>${playerOrTeam}</strong><span style="font-weight:normal;"> - ${statType}</span>`;
              
              // Check if game has started (for hiding progress bar and current stat in Live Bets)
              // If we have database status (won/lost), the game has definitely finished, so it's not "not started"
              const gameNotStarted = (p.status !== 'won' && p.status !== 'lost') && 
                                     ((gameData && gameData.statusTypeName === 'STATUS_SCHEDULED') || 
                                     (!gameData && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))));
              
              // For Live Bets that haven't started: hide progress bar and current stat, center the target
              const mobileLine2Content = gameNotStarted ? 
                `<span style="grid-column: 1 / -1; text-align: center;">${mobileTargetDisplay}<div style="font-size:0.65rem;color:#999;margin-top:0.0375rem;">Target</div></span>` :
                `<span>${mobileCurrentDisplay}<div style="font-size:0.65rem;color:#999;margin-top:0.0375rem;">Current</div></span>
                      <span>${progressCol}</span>
                      <span>${mobileTargetDisplay}<div style="font-size:0.65rem;color:#999;margin-top:0.0375rem;">Target</div></span>`;
              
              return`
                <tr>
                  <td>
                    <div class="mobile-line-1">
                      <span>${mobilePlayerHTML}</span>
                      <span class="status-badge">${txt}</span>
                    </div>
                  </td>
                  <td>
                    <div class="mobile-line-2">
                      ${mobileLine2Content}
                    </div>
                  </td>
                  <td>${playerCellHTML}</td>
                  <td>${formatStatTypeWithUnder(p.stat, p.bet_line_type)}</td>
                  <td>${currentDisplay}</td>
                  <td>${targetDisplay}</td>
                  <td>${progressCol}</td>
                  <td class="status-badge">${txt}</td>
                </tr>`;
            }).join('')}
          </tbody>`;
        
        // Create footer with bet info
        const footer = document.createElement('div');
        footer.className = 'parlay-footer';
        
        const oddsText = parlay.odds || 'N/A';
        const wagerText = parlay.wager ? `$${parlay.wager}` : 'N/A';
        const betIdText = parlay.betting_site_id || 'N/A';
        const siteText = parlay.betting_site || 'N/A';
        
        // Calculate winnings if bet won (all games final and all legs hit)
        let winningsText = '$0.00';
        const allGamesFinal = parlay.games && parlay.games.every(g => g.statusTypeName === 'STATUS_FINAL');
        
        if (allGamesFinal && allLegsComplete && parlay.returns && parlay.wager) {
          const winnings = parlay.returns - parlay.wager;
          winningsText = `$${winnings.toFixed(2)}`;
        }
        
        // Determine which logo to use based on theme and betting site
        const isDarkMode = !document.body.classList.contains('light-mode');
        const logoSuffix = isDarkMode ? '1' : '2'; // 1=white (dark mode), 2=colored (light mode)
        
        // Map betting site names to logo filenames
        const logoMap = {
          'DraftKings': 'draftkings',
          'FanDuel': 'fanduel',
          'Dabble': 'dabble',
          'Bet365': 'bet365'
        };
        
        const logoKey = logoMap[siteText];
        const logoHTML = logoKey ? 
          `<img src="media/logos/${logoKey}-logo-${logoSuffix}.svg" 
                alt="${siteText}" 
                class="footer-logo"
                onerror="this.style.display='none'">` : '';
        
        footer.innerHTML = `
          <div class="footer-left">
            <div class="footer-odds">Odds: ${oddsText}</div>
            <div class="footer-wager">Wager: ${wagerText}</div>
            <div class="footer-winnings">Winnings: ${winningsText}</div>
          </div>
          <div class="footer-right">
            <div class="footer-betid">Bet ID: ${betIdText}</div>
            <div class="footer-site">${siteText}</div>
          </div>
          ${logoHTML}
        `;
        
        // Wrap only table in parlay-body div for collapsing (footer stays visible)
        const parlayBody = document.createElement('div');
        parlayBody.className = 'parlay-body';
        parlayBody.appendChild(table);
        
        section.appendChild(header);
        section.appendChild(parlayBody);
        section.appendChild(footer);
        
        // Add press-and-hold selection + collapse/expand functionality
        let localPressTimer = null;
        let pressHandled = false;
        let startX = 0;
        let startY = 0;
        const MOVEMENT_THRESHOLD = 10; // pixels of movement to cancel press
        
        const startPress = (e) => {
          // Don't start timer if clicking the collapse arrow
          if (e.target.classList.contains('collapse-icon')) {
            return;
          }
          
          pressHandled = false;
          
          // Record starting position for scroll detection
          const touch = e.touches ? e.touches[0] : e;
          startX = touch.clientX;
          startY = touch.clientY;
          
          if (!selectionMode) {
            // Not in selection mode: start press-and-hold timer (500ms) for FIRST selection
            localPressTimer = setTimeout(() => {
              pressHandled = true;
              selectBet(parlay.db_id);
            }, 500);
          } else {
            // Already in selection mode: no timer needed, will toggle on tap
            // Don't set pressHandled, let endPress handle the tap
          }
        };
        
        const checkMovement = (e) => {
          if (!localPressTimer) return;
          
          const touch = e.touches ? e.touches[0] : e;
          const deltaX = Math.abs(touch.clientX - startX);
          const deltaY = Math.abs(touch.clientY - startY);
          
          // If user moved more than threshold, cancel the press (they're scrolling)
          if (deltaX > MOVEMENT_THRESHOLD || deltaY > MOVEMENT_THRESHOLD) {
            cancelPress();
          }
        };
        
        const endPress = (e) => {
          // If clicking the collapse arrow, just toggle collapse
          if (e.target.classList.contains('collapse-icon')) {
            section.classList.toggle('collapsed');
            return;
          }
          
          if (localPressTimer) {
            clearTimeout(localPressTimer);
            localPressTimer = null;
          }
          
          // If press was handled (long press completed), don't do anything else
          if (pressHandled) {
            pressHandled = false;
            return;
          }
          
          // Short tap behavior
          if (selectionMode) {
            // In selection mode: toggle selection immediately (no hold needed)
            // When selected, collapse. When unselected, uncollapse
            const isCurrentlySelected = selectedBets.has(parlay.db_id);
            toggleBetSelection(parlay.db_id);
            
            // After toggle, check new state
            if (selectedBets.has(parlay.db_id)) {
              // Just got selected - collapse it
              section.classList.add('collapsed');
            } else {
              // Just got unselected - uncollapse it
              section.classList.remove('collapsed');
            }
          } else {
            // Normal mode (no selection active): tapping header/title toggles collapse/uncollapse
            section.classList.toggle('collapsed');
          }
        };
        
        const cancelPress = () => {
          if (localPressTimer) {
            clearTimeout(localPressTimer);
            localPressTimer = null;
          }
          pressHandled = false;
        };
        
        // Remove any existing event listeners to prevent duplicates
        // Store handlers on the header element itself for cleanup
        if (header._pressHandlers) {
          const old = header._pressHandlers;
          header.removeEventListener('touchstart', old.startPress);
          header.removeEventListener('touchmove', old.checkMovement);
          header.removeEventListener('touchend', old.endPress);
          header.removeEventListener('touchcancel', old.cancelPress);
          header.removeEventListener('mousedown', old.startPress);
          header.removeEventListener('mousemove', old.checkMovement);
          header.removeEventListener('mouseup', old.endPress);
          header.removeEventListener('mouseleave', old.cancelPress);
        }
        
        // Store handlers for future cleanup
        header._pressHandlers = { startPress, checkMovement, endPress, cancelPress };
        
        // Touch events for mobile
        header.addEventListener('touchstart', startPress, { passive: true });
        header.addEventListener('touchmove', checkMovement, { passive: true }); // Check for scrolling
        header.addEventListener('touchend', endPress);
        header.addEventListener('touchcancel', cancelPress);
        
        // Mouse events for desktop
        header.addEventListener('mousedown', startPress);
        header.addEventListener('mousemove', checkMovement);
        header.addEventListener('mouseup', endPress);
        header.addEventListener('mouseleave', cancelPress);
        
        // === SORTABLE COLUMNS ===
        // Attach sorting to THIS table's headers only (not all tables on page)
        const currentTable = section.querySelector('table');
        if (currentTable) {
          currentTable.querySelectorAll('thead th').forEach((th, index) => {
            th.addEventListener('click', () => {
              const table = th.closest('table');
              const tbody = table.querySelector('tbody');
              const rows = Array.from(tbody.querySelectorAll('tr'));
              
              // Determine sort direction
              const isAsc = th.classList.contains('sorted') && th.classList.contains('asc');
              
              // Remove sorted class from all headers in this table
              table.querySelectorAll('thead th').forEach(h => {
                h.classList.remove('sorted', 'asc');
              });
              
              // Add sorted class to clicked header
              th.classList.add('sorted');
              if (!isAsc) th.classList.add('asc');
              
              // Sort rows
              rows.sort((a, b) => {
                const aCell = a.querySelectorAll('td')[index]?.textContent.trim() || '';
                const bCell = b.querySelectorAll('td')[index]?.textContent.trim() || '';
                
                // For Player column (index 0), sort by first word only
                if (index === 0) {
                  const aFirstWord = aCell.split(' ')[0];
                  const bFirstWord = bCell.split(' ')[0];
                  return isAsc ? aFirstWord.localeCompare(bFirstWord) : bFirstWord.localeCompare(aFirstWord);
                }
                
                // For Progress column (index 4), extract percentage from progress bar
                if (index === 4) {
                  const aTd = a.querySelectorAll('td')[index];
                  const bTd = b.querySelectorAll('td')[index];
                  
                  // Try to get percentage from progress-text span
                  const aProgressText = aTd?.querySelector('.progress-text')?.textContent || '0%';
                  const bProgressText = bTd?.querySelector('.progress-text')?.textContent || '0%';
                  
                  const aPct = parseFloat(aProgressText.replace('%', '')) || 0;
                  const bPct = parseFloat(bProgressText.replace('%', '')) || 0;
                  
                  return isAsc ? aPct - bPct : bPct - aPct;
                }
                
                // Try numeric comparison first
                const aNum = parseFloat(aCell);
                const bNum = parseFloat(bCell);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                  return isAsc ? aNum - bNum : bNum - aNum;
                }
                
                // String comparison
                return isAsc ? aCell.localeCompare(bCell) : bCell.localeCompare(aCell);
              });
              
              // Re-append sorted rows
              rows.forEach(row => tbody.appendChild(row));
            });
          });
        }
        
        // Append to the container passed into render() so each tab gets its own content
        container.appendChild(section);
      });
      
      // Apply filters after rendering
      applyAllFilters();
      
      // Update tab count
      updateTabCount(container, sortedParlays.length);
      
      // Initialize DataTables on newly rendered tables
      setTimeout(initializeDataTables, 100); // Small delay to ensure DOM is updated
    }
    
    // Update tab label with bet count
    function updateTabCount(container, count) {
      const isHistorical = container.id === 'historical-sections' || container.dataset.tab === 'historical';
      const tabButton = document.querySelector(`.tab[data-tab="${isHistorical ? 'historical' : 'current'}"]`);
      
      if (tabButton) {
        const baseText = isHistorical ? 'Historical Bets' : 'Live Bets';
        tabButton.textContent = `${baseText} (${count})`;
      }
    }

    btn.addEventListener('click',update);
    
    // ========================================
    // ADD BET DROPDOWN MENU
    // ========================================
    const addBetButton = document.getElementById('add-bet-button');
    const addBetDropdown = document.getElementById('add-bet-dropdown');
    const uploadBetslipOption = document.getElementById('upload-betslip-option');
    const manualEntryOption = document.getElementById('manual-entry-option');
    
    // Toggle dropdown on button click
    addBetButton.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close other menus
      filterMainMenu.classList.remove('active');
      filterSubPanel.classList.remove('active');
      collapseMenu.classList.remove('active');
      selectMenu.classList.remove('active');
      addBetDropdown.classList.toggle('active');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!addBetButton.contains(e.target) && !addBetDropdown.contains(e.target)) {
        addBetDropdown.classList.remove('active');
      }
    });
    
    // Upload Bet Slip option - opens file picker
    uploadBetslipOption.addEventListener('click', () => {
      addBetDropdown.classList.remove('active');
      document.getElementById('betslip-file-input').click();
    });
    
    // Manual Entry option - opens add bet modal from hamburger menu
    manualEntryOption.addEventListener('click', () => {
      addBetDropdown.classList.remove('active');
      document.getElementById('add-bet-item').click(); // Trigger hamburger menu add bet
    });
    
    // ========================================
    // BET SLIP OCR UPLOAD FUNCTIONALITY
    // ========================================
    const fileInput = document.getElementById('betslip-file-input');
    const ocrModal = document.getElementById('ocr-modal');
    const closeOcrModal = document.getElementById('close-ocr-modal');
    const cancelOcr = document.getElementById('cancel-ocr');
    const ocrLoading = document.getElementById('ocr-loading');
    const ocrError = document.getElementById('ocr-error');
    const ocrResults = document.getElementById('ocr-results');
    const confirmSaveBtn = document.getElementById('confirm-save-bet');
    const bettorSearch = document.getElementById('bettor-search');
    const bettorSuggestions = document.getElementById('bettor-suggestions');
    const selectedBettorsContainer = document.getElementById('selected-bettors');
    
    let extractedBetData = null;
    let selectedSecondaryBettors = [];
    let allUsers = [];
    
    // Handle file selection
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      // Show modal with loading state
      ocrModal.style.display = 'flex';
      ocrModal.style.alignItems = 'center';
      ocrModal.style.justifyContent = 'center';
      ocrLoading.style.display = 'block';
      ocrError.style.display = 'none';
      ocrResults.style.display = 'none';
      
      // Prevent body scrolling when modal is open
      document.body.style.overflow = 'hidden';
      
      // Fetch users for autocomplete if not already loaded
      if (allUsers.length === 0) {
        fetchAllUsers();
      }
      
      // Reset secondary bettors
      selectedSecondaryBettors = [];
      renderSelectedBettors();
      
      try {
        // Create FormData and upload
        const formData = new FormData();
        formData.append('image', file);
        
        const response = await fetch(`${API_BASE}/api/upload-betslip`, {
          method: 'POST',
          credentials: 'include',
          body: formData
        });
        
        // Check if response is HTML (error page) instead of JSON
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('text/html')) {
          // Server returned an HTML error page
          const htmlText = await response.text();
          console.error('Server returned HTML error page:', htmlText.substring(0, 200));
          throw new Error(
            `Server error (${response.status}): The server returned an error page. ` +
            `This usually means: 1) The OpenAI API key is not configured on the server, ` +
            `2) The server crashed while processing, or 3) You're not authenticated. ` +
            `Please contact the administrator or try logging in again.`
          );
        }
        
        let result;
        try {
          result = await response.json();
        } catch (jsonError) {
          console.error('Failed to parse server response as JSON:', jsonError);
          throw new Error(
            `Invalid server response: Expected JSON but got something else. ` +
            `Status: ${response.status}. This usually means the server encountered ` +
            `an internal error. Please try again or contact support.`
          );
        }
        
        if (!response.ok || !result.success) {
          // Server returned a proper JSON error
          const errorMsg = result.message || result.error || result.details || 'Failed to process bet slip';
          throw new Error(`Bet slip processing failed: ${errorMsg}`);
        }
        
        // Success - display extracted data
        extractedBetData = result.data;
        displayExtractedBet(result.data);
        
        ocrLoading.style.display = 'none';
        ocrResults.style.display = 'block';
        
      } catch (error) {
        console.error('OCR error:', error);
        ocrLoading.style.display = 'none';
        ocrError.style.display = 'block';
        
        // Display user-friendly error message
        let errorMessage = error.message;
        if (errorMessage.includes('Failed to fetch')) {
          errorMessage = 'Network error: Unable to reach the server. Please check your internet connection and try again.';
        }
        document.getElementById('ocr-error-message').textContent = errorMessage;
      }
      
      // Reset file input
      fileInput.value = '';
    });
    
    // Calculate odds from wager and payout
    function calculateOddsFromPayout(wager, payout) {
      if (!wager || !payout || wager <= 0) return null;
      const profit = payout - wager;
      if (profit <= 0) return null;
      
      if (profit >= wager) {
        // Underdog (+odds)
        return '+' + Math.round((profit / wager) * 100);
      } else {
        // Favorite (-odds)
        return '-' + Math.round((wager / profit) * 100);
      }
    }
    
    // Calculate payout from wager and odds
    function calculatePayoutFromOdds(wager, odds) {
      if (!wager || !odds || wager <= 0) return null;
      const oddsStr = odds.toString().trim();
      
      let profit = 0;
      if (oddsStr.startsWith('+')) {
        // Underdog: profit = wager * (odds/100)
        const oddsNum = parseInt(oddsStr.substring(1));
        profit = wager * (oddsNum / 100);
      } else if (oddsStr.startsWith('-')) {
        // Favorite: profit = wager / (odds/100)
        const oddsNum = parseInt(oddsStr.substring(1));
        profit = wager / (oddsNum / 100);
      } else {
        // Try parsing as number
        const oddsNum = parseInt(oddsStr);
        if (oddsNum > 0) {
          profit = wager * (oddsNum / 100);
        } else {
          profit = wager / (Math.abs(oddsNum) / 100);
        }
      }
      
      return Math.round((wager + profit) * 100) / 100;
    }
    
    // Display extracted bet data
    function displayExtractedBet(data) {
      // Calculate missing odds or payout
      let odds = data.total_odds;
      let wager = data.wager_amount;
      let payout = data.potential_payout;
      
      // If odds is blank/N/A but we have wager and payout, calculate odds
      if ((!odds || odds === 'N/A' || odds === 'null') && wager && payout) {
        odds = calculateOddsFromPayout(wager, payout);
        console.log(`Calculated odds: ${odds} from wager: ${wager} and payout: ${payout}`);
      }
      
      // If payout is blank/N/A but we have wager and odds, calculate payout
      if ((!payout || payout === 'N/A' || payout === 'null' || payout === 0) && wager && odds) {
        payout = calculatePayoutFromOdds(wager, odds);
        console.log(`Calculated payout: ${payout} from wager: ${wager} and odds: ${odds}`);
      }
      
      // Populate editable fields
      document.getElementById('extracted-site').value = data.bet_site || 'Unknown';
      document.getElementById('extracted-type').value = data.bet_type || 'parlay';
      document.getElementById('extracted-odds').value = odds || '';
      document.getElementById('extracted-wager').value = wager || '0';
      document.getElementById('extracted-payout').value = payout || '0';
      document.getElementById('extracted-date').value = data.bet_date || new Date().toISOString().split('T')[0];
      document.getElementById('extracted-bet-name').value = data.bet_name || '';
      document.getElementById('leg-count').textContent = data.legs?.length || 0;
      
      // Auto-calculate on change
      const wagerInput = document.getElementById('extracted-wager');
      const oddsInput = document.getElementById('extracted-odds');
      const payoutInput = document.getElementById('extracted-payout');
      
      // When wager or odds change, recalculate payout
      const recalculatePayout = () => {
        const w = parseFloat(wagerInput.value);
        const o = oddsInput.value.trim();
        if (w && o) {
          const p = calculatePayoutFromOdds(w, o);
          if (p) payoutInput.value = p;
        }
      };
      
      // When wager or payout change, recalculate odds
      const recalculateOdds = () => {
        const w = parseFloat(wagerInput.value);
        const p = parseFloat(payoutInput.value);
        if (w && p && p > w) {
          const o = calculateOddsFromPayout(w, p);
          if (o) oddsInput.value = o;
        }
      };
      
      wagerInput.addEventListener('input', () => {
        if (oddsInput.value && (!payoutInput.value || parseFloat(payoutInput.value) === 0)) {
          recalculatePayout();
        } else if (payoutInput.value && !oddsInput.value) {
          recalculateOdds();
        }
      });
      
      oddsInput.addEventListener('input', recalculatePayout);
      payoutInput.addEventListener('input', recalculateOdds);
      
      // Bet legs
      const legsList = document.getElementById('extracted-legs-list');
      legsList.innerHTML = '';
      
      if (data.legs && data.legs.length > 0) {
        data.legs.forEach((leg, index) => {
          const legDiv = document.createElement('div');
          legDiv.style.cssText = 'padding: 16px; margin-bottom: 12px; background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border: 2px solid #e0e0e0; border-radius: 10px; transition: border-color 0.2s;';
          legDiv.addEventListener('mouseenter', () => legDiv.style.borderColor = '#667eea');
          legDiv.addEventListener('mouseleave', () => legDiv.style.borderColor = '#e0e0e0');
          
          let legDescription = '';
          // Determine bet type from stat field
          const stat = leg.stat || '';
          const betType = stat.toLowerCase().includes('spread') ? 'spread' :
                         stat.toLowerCase().includes('moneyline') || stat.toLowerCase() === 'ml' ? 'moneyline' :
                         stat.toLowerCase().includes('total') || stat.toLowerCase().includes('points') ? 'total' :
                         stat.toLowerCase();
          
          if (leg.player) {
            // Player prop
            legDescription = `<strong style="color: #2c3e50; font-size: 15px;">${leg.player}</strong> <span style="color: #666; font-size: 13px;">(${leg.team || 'N/A'})</span>`;
            legDescription += `<br><span style="color: #555; font-size: 14px; font-weight: 500;">${formatStatTypeWithUnder(stat, leg.stat_add) || 'N/A'} <span style="text-transform: uppercase; color: #667eea; font-weight: 600;">${leg.stat_add || ''}</span> ${leg.line || ''}</span>`;
          } else if (betType === 'spread') {
            // Spread
            legDescription = `<strong style="color: #2c3e50; font-size: 15px;">${leg.team || 'N/A'}</strong> <span style="color: #667eea; font-weight: 600; font-size: 14px;">${leg.line > 0 ? '+' : ''}${leg.line || ''}</span>`;
          } else if (betType === 'moneyline') {
            // Moneyline
            legDescription = `<strong style="color: #2c3e50; font-size: 15px;">${leg.team || 'N/A'}</strong> <span style="color: #667eea; font-weight: 600;">ML</span>`;
          } else if (betType === 'total') {
            // Total
            legDescription = `<span style="text-transform: uppercase; color: #667eea; font-weight: 600; font-size: 14px;">${leg.stat_add || ''}</span> <strong style="color: #2c3e50; font-size: 15px;">${leg.line || ''}</strong> <span style="color: #666;">points</span>`;
          }
          
          legDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: start;">
              <div style="flex: 1;">
                <div style="font-size: 12px; color: #888; margin-bottom: 6px; font-weight: 500;">
                  <span style="background: #667eea; color: white; padding: 2px 8px; border-radius: 4px; font-weight: 600;">NFL</span>
                  ${leg.game_info ? `<span style="margin-left: 8px;">${leg.game_info}</span>` : ''}
                  ${leg.game_date ? `<br><span style="color: #999; font-size: 11px;">${new Date(leg.game_date).toLocaleString()}</span>` : ''}
                </div>
                <div style="margin-top: 8px;">${legDescription}</div>
              </div>
              <div style="text-align: right; font-weight: bold; font-size: 16px; color: #28a745; background: #e8f5e9; padding: 6px 12px; border-radius: 6px;">
                ${leg.odds || 'N/A'}
              </div>
            </div>
          `;
          
          legsList.appendChild(legDiv);
        });
      }
    }
    
    // Close modal handlers
    closeOcrModal.addEventListener('click', () => {
      ocrModal.style.display = 'none';
      document.body.style.overflow = '';
      extractedBetData = null;
    });
    
    cancelOcr.addEventListener('click', () => {
      ocrModal.style.display = 'none';
      document.body.style.overflow = '';
      extractedBetData = null;
    });
    
    // Click outside modal to close
    ocrModal.addEventListener('click', (e) => {
      if (e.target === ocrModal) {
        ocrModal.style.display = 'none';
        document.body.style.overflow = '';
        extractedBetData = null;
      }
    });
    
    // Fetch all users for autocomplete
    async function fetchAllUsers() {
      try {
        const response = await fetch(`${API_BASE}/api/users`, {
          credentials: 'include'
        });
        if (response.ok) {
          const result = await response.json();
          allUsers = result.users || [];
        }
      } catch (error) {
        console.error('Failed to fetch users:', error);
      }
    }
    
    // Secondary bettors autocomplete
    bettorSearch.addEventListener('input', () => {
      const query = bettorSearch.value.toLowerCase().trim();
      
      if (query.length < 2) {
        bettorSuggestions.style.display = 'none';
        return;
      }
      
      // Filter users by username or email
      const matches = allUsers.filter(user => 
        user.username.toLowerCase().includes(query) || 
        user.email.toLowerCase().includes(query)
      ).filter(user => 
        // Exclude already selected bettors
        !selectedSecondaryBettors.find(b => b.id === user.id)
      ).slice(0, 5); // Max 5 suggestions
      
      if (matches.length === 0) {
        bettorSuggestions.style.display = 'none';
        return;
      }
      
      bettorSuggestions.innerHTML = matches.map(user => `
        <div class="bettor-suggestion" data-user-id="${user.id}" data-username="${user.username}" style="padding: 10px; cursor: pointer; border-bottom: 1px solid #eee; transition: background 0.2s;">
          <div style="font-weight: 600; color: #2c3e50;">${user.username}</div>
          <div style="font-size: 12px; color: #888;">${user.email}</div>
        </div>
      `).join('');
      
      bettorSuggestions.style.display = 'block';
      
      // Add click handlers
      document.querySelectorAll('.bettor-suggestion').forEach(item => {
        item.addEventListener('mouseenter', () => item.style.background = '#f0f0f0');
        item.addEventListener('mouseleave', () => item.style.background = 'white');
        item.addEventListener('click', () => {
          const userId = parseInt(item.dataset.userId);
          const username = item.dataset.username;
          addSecondaryBettor(userId, username);
          bettorSearch.value = '';
          bettorSuggestions.style.display = 'none';
        });
      });
    });
    
    // Add secondary bettor
    function addSecondaryBettor(userId, username) {
      if (selectedSecondaryBettors.find(b => b.id === userId)) {
        return; // Already added
      }
      
      selectedSecondaryBettors.push({ id: userId, username });
      renderSelectedBettors();
    }
    
    // Render selected bettors
    function renderSelectedBettors() {
      if (selectedSecondaryBettors.length === 0) {
        selectedBettorsContainer.innerHTML = '<p style="color: #999; font-size: 13px; font-style: italic;">No secondary bettors added</p>';
        return;
      }
      
      selectedBettorsContainer.innerHTML = selectedSecondaryBettors.map(bettor => `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 8px 12px; border-radius: 20px; display: inline-flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 500;">
          <span>${bettor.username}</span>
          <button class="remove-bettor" data-user-id="${bettor.id}" style="background: rgba(255,255,255,0.3); border: none; color: white; cursor: pointer; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold;">×</button>
        </div>
      `).join('');
      
      // Add remove handlers
      document.querySelectorAll('.remove-bettor').forEach(btn => {
        btn.addEventListener('click', () => {
          const userId = parseInt(btn.dataset.userId);
          selectedSecondaryBettors = selectedSecondaryBettors.filter(b => b.id !== userId);
          renderSelectedBettors();
        });
      });
    }
    
    // Hide suggestions when clicking outside
    document.addEventListener('click', (e) => {
      if (!bettorSearch.contains(e.target) && !bettorSuggestions.contains(e.target)) {
        bettorSuggestions.style.display = 'none';
      }
    });
    
    // Confirm and save bet
    confirmSaveBtn.addEventListener('click', async () => {
      if (!extractedBetData) {
        alert('No bet data to save');
        return;
      }
      
      try {
        // Disable button and show loading state
        confirmSaveBtn.disabled = true;
        confirmSaveBtn.textContent = 'Saving...';
        
        // Get edited values from form
        const editedData = {
          ...extractedBetData,
          bet_site: document.getElementById('extracted-site').value,
          bet_type: document.getElementById('extracted-type').value,
          total_odds: document.getElementById('extracted-odds').value,
          wager_amount: parseFloat(document.getElementById('extracted-wager').value),
          potential_payout: parseFloat(document.getElementById('extracted-payout').value),
          bet_date: document.getElementById('extracted-date').value,
          bet_name: document.getElementById('extracted-bet-name').value || null,
          secondary_bettor_ids: selectedSecondaryBettors.map(b => b.id)
        };
        
        // Send to save endpoint
        const response = await fetch(`${API_BASE}/api/save-extracted-bet`, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(editedData)
        });
        
        const result = await response.json();
        
        if (!response.ok || !result.success) {
          throw new Error(result.error || result.details || 'Failed to save bet');
        }
        
        // Success!
        alert(`✅ ${result.message}\n\nBet ID: ${result.bet.betting_site_id}`);
        
        // Close modal and reset
        ocrModal.style.display = 'none';
        document.body.style.overflow = '';
        extractedBetData = null;
        selectedSecondaryBettors = [];
        renderSelectedBettors();
        
        // Refresh the bets list
        update();
        
      } catch (error) {
        console.error('Save error:', error);
        alert(`❌ Failed to save bet: ${error.message}`);
        
        // Re-enable button
        confirmSaveBtn.disabled = false;
        confirmSaveBtn.textContent = '✓ Confirm & Save Bet';
      }
    });
    
    // Move completed games button
    const moveBtn = document.getElementById('move-completed-button');
    moveBtn.addEventListener('click', async () => {
      try {
        msg.textContent = 'Moving completed games...';
        moveBtn.disabled = true;
        
        const response = await fetchWithAdminToken(`${API_BASE}/admin/move_completed`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) throw new Error(`Move failed: ${response.status}`);
        
        const result = await response.json();
        msg.textContent = `Moved ${result.moved_count} parlay(s) to history. ${result.remaining_live} still live.`;
        
        // Clear caches (including localStorage for historical since new bets were added)
        cachedLive = null;
        cachedHistorical = null;
        clearHistoricalCache();
        
        // Update twice to ensure all data is refreshed properly
        await update();
        
        // Small delay then update again to show the rearranged bets
        setTimeout(async () => {
          await update();
        }, 500);
      } catch (e) {
        console.error('Error moving completed:', e);
        msg.textContent = `Error: ${e.message}`;
      } finally {
        moveBtn.disabled = false;
      }
    });
    
    // Wait for auth check to complete before calling update
    (async function() {
      try {
        await authCheckPromise;
        console.log('Auth check complete, calling update()');
        update();
        
        // Auto-refresh live data every 30 seconds
        setInterval(() => {
          const activeTab = document.querySelector('.tab.active');
          if (activeTab && activeTab.dataset.tab === 'current') {
            console.log('Auto-refreshing live data...');
            update();
          }
        }, 30000); // 30 seconds
        
      } catch (error) {
        console.error('Skipping update due to auth error:', error);
      }
    })();
    
    // Handle page visibility changes - clear cache when page becomes visible (important for mobile)
    // This ensures fresh stats when user switches back from another app/tab
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // Page became visible again - clear server cache and refresh current tab
        console.log('📱 Page became visible, clearing cache and refreshing...');
        (async () => {
          try {
            await fetchWithAdminToken(`${API_BASE}/api/cache-bust`, { method: 'POST' });
            console.log('✅ Server cache cleared');
            
            // Refresh the current tab if it's live bets
            const activeTab = document.querySelector('.tab.active');
            if (activeTab && activeTab.dataset.tab === 'current') {
              await update();
            }
          } catch (e) {
            console.warn('Could not refresh stats on page visibility:', e);
          }
        })();
      }
    });
    
    // Clear cache when page is initially loaded (page refresh or new visit)
    (async () => {
      try {
        await fetchWithAdminToken(`${API_BASE}/api/cache-bust`, { method: 'POST' });
        console.log('✅ Initial page load: Server cache cleared');
      } catch (e) {
        console.warn('Could not clear cache on page load:', e);
      }
    })();
    
    // Register Service Worker for PWA with auto-update
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered:', registration.scope);
            
            // Listen for updates to the service worker
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              console.log('New Service Worker found, installing...');
              
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New service worker is installed but old one is still controlling
                  console.log('New version available! Reloading...');
                  // Force the new service worker to take control immediately
                  newWorker.postMessage({ type: 'SKIP_WAITING' });
                  // Reload the page to get the new version
                  window.location.reload();
                }
              });
            });
            
            // Check for updates on page load and periodically
            registration.update();
            
            // Check for updates every 30 seconds while app is open
            setInterval(() => {
              registration.update();
            }, 30000);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
      
      // Listen for controller change (when new service worker takes over)
      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) {
          refreshing = true;
          console.log('New Service Worker took control, reloading...');
          window.location.reload();
        }
      });
    }
    
    // Initialize DataTables on bet tables with custom options
    function initializeDataTables() {
      // Destroy existing DataTables first
      $('table').each(function() {
        const $table = $(this);
        if ($.fn.DataTable.isDataTable($table)) {
          $table.DataTable().destroy();
        }
      });
      
      // Initialize DataTables on all bet tables
      $('table').each(function() {
        const $table = $(this);
        
        // Initialize DataTable with options that preserve existing functionality
        $table.DataTable({
          paging: false,        // Keep all rows visible (preserve existing behavior)
          searching: false,     // Disable search functionality (we have global search)
          ordering: true,       // Enable column sorting
          info: false,          // Hide "Showing X of Y entries" info
          responsive: false,    // Disable DataTables responsive (we handle it with CSS)
          autoWidth: false,     // Prevent auto width calculation that might break custom styling
          columnDefs: [
            { targets: [0, 1], orderable: false, searchable: false }, // Mobile columns (hidden by CSS)
            { targets: [6], orderable: false, searchable: false }, // Progress column (no sorting)
            { targets: [7], orderable: false, searchable: false }  // Status column (no sorting)
          ],
          initComplete: function() {
            // DataTables styling removed since search is disabled
          }
        });
      });
    }
    
    // Initialize DataTables when document is ready
    $(document).ready(function() {
      initializeDataTables();
    });
  </script>
  
  <!-- Bottom Navigation Bar -->
  <nav class="bottom-nav">
    <a href="/" class="bottom-nav-item active" data-action="my-bets" title="My Bets">
      <span class="nav-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 11l3 3L22 4M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>
        </svg>
      </span>
      <span class="nav-label">My Bets</span>
    </a>
    <a href="/explore" class="bottom-nav-item" data-action="explore" title="Explore">
      <span class="nav-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"/><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
        </svg>
      </span>
      <span class="nav-label">Explore</span>
    </a>
    <a href="/watched" class="bottom-nav-item" data-action="watched" title="Watched">
      <span class="nav-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
        </svg>
      </span>
      <span class="nav-label">Watched</span>
    </a>
    <a href="/social" class="bottom-nav-item" data-action="social" title="Social">
      <span class="nav-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/>
        </svg>
      </span>
      <span class="nav-label">Social</span>
    </a>
    <a href="#" class="bottom-nav-item" data-action="account" title="Account">
      <span class="nav-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/>
        </svg>
      </span>
      <span class="nav-label">Account</span>
    </a>
  </nav>
  
  <script src="bottom-nav.js"></script>
</body>
</html>
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Parlay & Wager Tracker</title>
  <style>
    :root {
      /* Dark mode colors (default) */
      --bg:#121212;--surface:#1a1a1a;--primary:#140d52;
      --text:#e0e0e0;--border:#ffcc00a4;--green:#4caf50;
      --orange:#ff9800;--yellow:#ffeb3b;--pregame:#ffc107;
      --error:#f44336;--progress-bg:#444;--section-bg:#252525;
      --outline-blue: #03a9f4; --title-color: #e657ff;
      --tab-active: #2a2a2a;
      
      /* Betting site colors */
      --draftkings: #4caf50;
      --fanduel: #2196f3;
      --dabble: #ffc107;
    }
    
    /* Light mode colors */
    body.light-mode {
      --bg:#f5f5f5;--surface:#ffffff;--primary:#5e35b1;
      --text:#212121;--border:#ffcc00;--green:#388e3c;
      --orange:#f57c00;--yellow:#fbc02d;--pregame:#ff6f00;
      --error:#c62828;--progress-bg:#e0e0e0;--section-bg:#fafafa;
      --outline-blue: #0288d1; --title-color: #7b1fa2;
      --tab-active: #e0e0e0;
    }
    
    /* Theme toggle button - moved to top left */
    .theme-toggle {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: transform 0.2s, opacity 0.3s;
    }
    
    .theme-toggle:hover {
      transform: scale(1.1);
    }
    
    /* Reduce opacity when scrolling */
    body.scrolling .theme-toggle {
      opacity: 0.25;
    }
    
    /* Logout button scroll opacity */
    body.scrolling .logout-btn {
      opacity: 0.25 !important;
    }
    
    /* Filter button - inline with Refresh button */
    .filter-button {
      display: inline-block;
      position: static;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      font-weight: bold;
      margin: 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: opacity 0.2s;
    }
    
    .filter-button:hover {
      opacity: 0.9;
    }
    
    /* Filter menu - dropdown below button */
    .filter-menu {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      display: none;
      min-width: 200px;
    }
    
    .filter-menu.active {
      display: block;
    }
    
    /* Button container for centering */
    .button-container {
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
    }
    
    #refresh-button {
      display: inline-block;
      margin: 0;
      padding: 0.75rem 1.5rem;
      background: var(--primary);
      color: #fff;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    
    .button-container > div {
      display: flex;
      align-items: center;
      margin: 0;
    }
    
    .filter-option {
      padding: 0.5rem 1rem;
      margin: 0.25rem 0;
      background: var(--section-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text);
      display: block;
      width: 100%;
      text-align: left;
      transition: background 0.2s;
    }
    
    .filter-option:hover, .filter-option.active {
      background: var(--primary);
      color: #fff;
    }
    
    /* Collapsible parlay */
    .parlay-section.collapsed .parlay-body {
      display: none;
    }
    
    .parlay-section.collapsed {
      padding: 0 !important;
    }
    
    .parlay-section.collapsed .parlay-header {
      margin: 0 !important;
      border-radius: 12px !important;
    }
    
    .parlay-header {
      cursor: pointer;
      user-select: none;
    }
    
    .parlay-title {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      position: relative;
      z-index: 1;
      width: 100%;
    }
    
    .collapse-icon {
      display: inline-block;
      margin-right: 0.5rem;
      transition: transform 0.3s;
      width: 20px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .parlay-section.collapsed .collapse-icon {
      transform: rotate(-180deg);
    }
    
    .parlay-title-text {
      display: flex;
      align-items: center;
    }
    
    /* Sortable column headers */
    thead th {
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    
    thead th:hover {
      background: var(--primary) !important;
    }
    
    thead th.sorted::after {
      content: ' ▼';
      font-size: 0.7em;
    }
    
    thead th.sorted.asc::after {
      content: ' ▲';
    }
    
    /* Pull to refresh indicator */
    .pull-refresh {
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: #fff;
      padding: 0.5rem 1rem;
      border-radius: 0 0 8px 8px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1001;
    }
    
    .pull-refresh.active {
      opacity: 1;
    }
    
    .tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      justify-content: center;
    }
    
    .tab {
      padding: 0.75rem 1.5rem;
      background: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    .tab:hover {
      opacity: 0.9;
    }
    
    .tab.active {
      background: var(--tab-active);
      color: var(--title-color);
    }
    body{background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
      margin:0;padding:1rem;
      zoom: 0.8;}
    .container{max-width:1200px;margin:auto;padding:2rem;
      background:var(--surface);border-radius:12px;
      box-shadow:0 4px 20px rgba(0,0,0,0.25);}
    h1{text-align:center;color:var(--title-color);margin-bottom:1.5rem;}
    button{display:block;margin:0 auto 1.5rem;padding:.75rem 1.5rem;
      background:var(--primary);color:#fff;font-weight:bold;
      border:none;border-radius:8px;cursor:pointer;}
    button:hover{opacity:.9;}
    #status-message{text-align:center;margin-bottom:2rem;color:#aaa;}
    .parlay-section{background:var(--section-bg);margin-bottom:2rem;
      border-radius:12px;padding:1.5rem 1.5rem 1.125rem;border:1px solid #cccccc;}
    .parlay-header{
      background:linear-gradient(135deg, var(--primary) 0%, rgba(20, 13, 82, 0.7) 100%);
      color:#fff;
      margin:-1.5rem -1.5rem 1.125rem -1.5rem;padding:1rem 1.5rem;
      border-radius:10px 10px 0 0;display:flex; flex-wrap: wrap;
      justify-content:space-between;align-items:flex-start;font-weight:bold;
      position:relative;
      cursor: pointer;
      user-select: none;
      gap: 1rem;
    }
    /* Single scoreboard: keep header on one line */
    .parlay-header:has(.game-info-wrapper .game-info:only-child) {
      flex-wrap: nowrap;
    }
    .parlay-footer{
      background:linear-gradient(135deg, rgba(20, 13, 82, 0.7) 0%, var(--primary) 100%);
      color:#fff;
      margin:1.125rem -1.5rem -1.125rem -1.5rem;padding:0.375rem 1.5rem;
      border-radius:0 0 10px 10px;display:flex;
      justify-content:space-between;align-items:center;
      font-size:0.75rem;min-height:1.5rem;}
    /* Site-specific footer colors with gradients */
    .parlay-section[data-site="DraftKings"] .parlay-footer {
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.7) 0%, var(--draftkings) 100%);
    }
    .parlay-section[data-site="FanDuel"] .parlay-footer {
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.7) 0%, var(--fanduel) 100%);
    }
    .parlay-section[data-site="Dabble"] .parlay-footer {
      background: linear-gradient(135deg, rgba(255, 193, 7, 0.7) 0%, var(--dabble) 100%);
      color: #000;
    }
    .footer-left{display:flex;flex-direction:column;gap:0.25rem;}
    .footer-right{display:flex;flex-direction:column;gap:0.25rem;text-align:right;}
    .footer-odds{font-weight:bold;color:#FFD700;}
    .footer-wager{color:#ddd;}
    .footer-betid{color:#ddd;}
    .footer-site{color:#fff;font-weight:500;}
    .winning-overlay{
      position:absolute;
      top:0.5rem;
      left:0.75rem;
      right:0.75rem;
      bottom:0.5rem;
      background:rgba(255, 242, 0, 0.622);
      border-radius:8px;
      pointer-events:none;
      z-index:0;}
    .parlay-title{display:flex;flex-direction:column;gap:0.25rem;position:relative;z-index:1;flex:1 1 auto;min-width:0;}
    .parlay-date{font-size:0.85rem;font-weight:normal;opacity:0.8;}
    .game-info-wrapper{display:flex;gap:0.5rem;flex-wrap:wrap;position:relative;z-index:1;justify-content:flex-end;align-items:flex-start;width:100%;flex:1 1 100%;flex-direction:row-reverse;}
    /* Single game: align scoreboards to the right, no reversal, no size constraints */
    .game-info-wrapper:has(.game-info:only-child) {
      justify-content:flex-end;
      width:auto;
      flex:0 0 auto;
      flex-direction:row;
      flex-wrap:nowrap;
    }
    .game-info-wrapper:has(.game-info:only-child) .game-info {
      flex: 0 0 auto;
      max-width: none;
    }
    /* Multiple games: limit to 10 per row on desktop */
    .game-info-wrapper:not(:has(.game-info:only-child)) .game-info {
      flex: 0 0 auto;
      width: calc((100% - 4.5rem) / 10); /* 10 items with 9 gaps of 0.5rem */
      max-width: calc((100% - 4.5rem) / 10);
    }
    /* Center items that wrap to second row (11th item onwards) */
    .game-info-wrapper:not(:has(.game-info:only-child)) .game-info:nth-child(n+11) {
      flex: 0 0 auto;
    }
    .game-info{display:flex;flex-direction:column;align-items:center;
      gap:.25rem;font-size:.9rem;border:1px solid var(--border);
      padding:.5rem;border-radius:6px;background:rgba(0,0,0,0.2);}
    table{width:100%;border-collapse:separate;border-spacing:0;}
    th,td{padding:.375rem;border-bottom:1px solid var(--border);
      vertical-align:middle;text-align:left;}
    /* Double padding for Player column (column 3) */
    td:nth-child(3){padding-left:0.75rem !important;}
    td { background: var(--surface); }
    th:first-child { border-top-left-radius: 10px; }
    th:last-child { border-top-right-radius: 10px; }
    /* Desktop body: Player column (3) - left aligned */
    td:nth-child(3){text-align:left !important;}
    /* Desktop body: Bet Type, Current, Target, Progress columns (4-7) - centered */
    td:nth-child(4),td:nth-child(5),td:nth-child(6),td:nth-child(7){text-align:center !important;}
    /* Desktop body: Status column (8) - centered */
    td:nth-child(8){text-align:center !important;}
    /* Headers: Player (th1) - left, Bet Type through Status (th2-6) - centered */
    thead th:nth-child(1){text-align:left !important;}
    thead th:nth-child(2),thead th:nth-child(3),thead th:nth-child(4),thead th:nth-child(5),thead th:nth-child(6){text-align:center !important;}
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:last-child td:first-child { border-bottom-left-radius: 10px; }
    tbody tr:last-child td:last-child { border-bottom-right-radius: 10px; }
    th{background:#2a2a2a;}
    .progress-bar{background:var(--progress-bg);border-radius:13px;position:relative;height:1.5rem;border:2px solid var(--outline-blue);padding:3px;}
    .progress-bar.pct-vlow { border-color: var(--error); }
    .progress-bar.pct-low { border-color: var(--orange); }
    .progress-bar.pct-mid { border-color: var(--yellow); }
    .progress-bar.pct-full { border-color: var(--green); }
    .progress{height:100%;transition:width .5s ease-in-out;border-radius:8px;}
    .progress-text{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;}
    .progress.pct-vlow{background:linear-gradient(to right, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 1));}
    .progress.pct-low{background:linear-gradient(to right, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 1));}
    .progress.pct-mid{background:linear-gradient(to right, rgba(255, 235, 59, 0.2), rgba(255, 235, 59, 1));}
    .progress.pct-full{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));}
    .badge{display:inline-block;font-size:.75rem;font-weight:bold;
      margin-bottom:.25rem;padding:2px 6px;border-radius:4px;}
    .status-pregame{background:var(--pregame);color:#ffffff;}
    .status-live{background:var(--error);color:#ffffff;}
    .status-halftime{background:transparent;color:#ffffff;border:1px solid #ffffff;}
    .status-final{background:#808080;color:#ffffff;}
    
    /* Mobile-specific layout classes (hidden on desktop) */
    .mobile-line-1,
    .mobile-line-2,
    .mobile-line-2-header {
      display: none;
    }
    
    /* Hide mobile cells 1-2 on desktop */
    table tbody tr td:nth-child(1),
    table tbody tr td:nth-child(2) {
      display: none;
    }
    
    .mobile-line-1 {
      justify-content: space-between;
      align-items: center;
      font-weight: 500;
    }
    
    .mobile-line-2-header {
      display: grid;
      grid-template-columns: 3.75rem 1fr 3.75rem;
      gap: 0.25rem;
      align-items: end;
      font-size: 0.45rem;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 0.125rem;
    }
    
    .mobile-line-2-header span:first-child {
      text-align: left;
    }
    
    .mobile-line-2-header span:nth-child(2) {
      text-align: center;
    }
    
    .mobile-line-2-header span:last-child {
      text-align: right;
    }
    
    .mobile-line-2 {
      grid-template-columns: 3.75rem 1fr 3.75rem;
      gap: 0.25rem;
      align-items: center;
    }
    
    .mobile-line-2 span:first-child {
      text-align: left;
      max-width: 3.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .mobile-line-2 span:nth-child(2) {
      text-align: center;
    }
    
    .mobile-line-2 span:last-child {
      text-align: right;
      max-width: 3.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 0;
        zoom: 1; /* Reset zoom on mobile for better readability */
      }
      
      .container {
        padding: 0.5rem;
        border-radius: 0;
      }
      
      h1 {
        font-size: 1.5rem;
        padding: 0 0.5rem;
      }
      
      .parlay-section {
        padding: 1rem 0.5rem;
        overflow-x: hidden; /* Prevent horizontal scroll */
        margin: 1.125rem 0; /* Reduced by 25% from 1.5rem */
        border-radius: 8px;
        border-color: rgba(204, 204, 204, 0.5);
      }
      
      .parlay-header {
        margin: -1rem -0.5rem 1rem -0.5rem;
        padding: 0.5625rem 0.5rem; /* Reduced by 25% from 0.75rem */
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.375rem; /* Reduced by 25% from 0.5rem */
        align-items: flex-start;
        justify-content: space-between;
      }
      
      .parlay-title {
        flex: 1;
        min-width: 0;
      }
      
      .parlay-footer {
        margin: 1rem -0.5rem -1rem -0.5rem;
        padding: 0.75rem 0.5rem;
        font-size: 0.7rem;
      }
      
      /* Adjust winning overlay for mobile padding */
      .winning-overlay {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 8px;
      }

      /* Compact scoreboards - max 3 per row, populate right to left */
      .game-info-wrapper {
        gap: 0.5rem;
        justify-content: flex-end !important;
        flex-wrap: wrap;
        width: 100%;
        display: flex;
        flex-direction: row-reverse;
      }
      
      /* Single scoreboard - align to right, auto width, no reversal, no size constraints */
      .game-info-wrapper:has(.game-info:only-child) {
        justify-content: flex-end !important;
        width: auto;
        flex-direction: row;
      }
      
      .game-info-wrapper:has(.game-info:only-child) .game-info {
        flex: 0 0 auto;
        max-width: none;
      }
      
      /* Multiple games: max 3 per row on mobile */
      .game-info-wrapper:not(:has(.game-info:only-child)) .game-info {
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        gap: 0.15rem;
        flex: 0 0 calc(33.333% - 0.35rem); /* Max 3 per row on mobile */
        max-width: calc(33.333% - 0.35rem);
        box-sizing: border-box;
      }
      
      /* Multiple games: center items that wrap to second row (4th item onwards) */
      .game-info-wrapper:not(:has(.game-info:only-child)) .game-info:nth-child(n+4) {
        margin: 0 auto;
      }
      
      .game-info {
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        gap: 0.15rem;
      }
      
      .game-info .badge {
        font-size: 0.6rem;
        padding: 1px 4px;
      }

      /* Mobile: Stack bet legs vertically with compact layout */
      table {
        display: block;
      }
      
      thead {
        display: none; /* Hide table headers on mobile */
      }
      
      tbody {
        display: block;
      }
      
      tr {
        display: block;
        margin-bottom: 0.5rem;
        padding: 0.4rem; /* Reduced by 20% from 0.5rem for shorter vertical height */
        background: var(--surface);
        border-radius: 8px;
        border: 1px solid rgba(255, 204, 0, 0.2);
      }
      
      /* Reduce spacing between header and first leg */
      tr:first-child {
        margin-top: -0.5rem;
      }
      
      /* Reduce spacing between last leg and footer */
      tr:last-child {
        margin-bottom: -0.5rem;
      }
      
      td {
        display: block;
        padding: 0.15rem 0;
        border: none;
        background: transparent;
        text-align: left !important;
      }
      
      /* Hide desktop columns 3-8 (individual cells) */
      tr td:nth-child(n+3) {
        display: none !important;
      }
      
      /* Show mobile columns 1-2 */
      tr td:nth-child(1),
      tr td:nth-child(2) {
        display: block !important;
      }
      
      /* Make mobile-specific content visible */
      .mobile-line-1 {
        display: flex !important;
        font-size: 0.9rem;
      }
      
      .mobile-line-2-header {
        display: grid !important;
        font-size: 0.45rem;
      }
      
      .mobile-line-2 {
        display: grid !important;
        font-size: 0.85rem;
      }
      
      /* Line 1 styling */
      tr td:nth-child(1) {
        margin-bottom: 0.25rem; /* Reduced by 50% from 0.5rem */
      }

      .progress-bar {
        height: 2.5rem;
      }
      
      .progress-bar .progress-text {
        font-size: 0.75rem;
      }
      
      .tabs {
        gap: 0.5rem;
        padding: 0 0.5rem;
      }
      
      .tab {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      #refresh-button,
      #move-completed-button {
        margin-left: 0.5rem !important;
      }
      
      #status-message {
        margin: 0 0.5rem;
      }
    }
    
    /* Extra small screens */
    @media (max-width: 480px) {
      h1 {
        font-size: 1.25rem;
      }
      
      .progress-bar {
        height: 1rem;
        font-size: 0.65rem;
      }
      
      .button-container {
        justify-content: center;
        padding: 0 1rem;
      }
      
      #refresh-button, .filter-button {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <!-- Theme Toggle -->
  <button class="theme-toggle" id="theme-toggle" title="Toggle Light/Dark Mode">🌙</button>
  
  <!-- Pull to Refresh Indicator -->
  <div class="pull-refresh" id="pull-refresh">Release to refresh...</div>
  
  <div class="container">
    <h1>Parlay & Wager Tracker</h1>
    <div class="tabs">
      <button class="tab active" data-tab="current">Live Bets</button>
      <button class="tab" data-tab="historical">Historical Bets</button>
    </div>
    <div class="button-container">
      <button id="refresh-button">Refresh Stats</button>
      <div style="position: relative;">
        <button class="filter-button" id="filter-button" title="Filter Parlays">Filter 🔍</button>
        <div class="filter-menu" id="filter-menu">
          <button class="filter-option active" data-filter="all">All Bets</button>
          <button class="filter-option" data-filter="live">Live Only</button>
          <button class="filter-option" data-filter="winning">Winning</button>
          <button class="filter-option" data-filter="losing">Losing</button>
          <button class="filter-option" data-filter="scheduled">Not Started</button>
          <button class="filter-option" data-filter="clear">Clear Filter</button>
        </div>
      </div>
    </div>
    <div id="status-message"></div>
    <div id="parlay-sections" class="tab-content active" data-tab="current"></div>
    <div id="historical-sections" class="tab-content" data-tab="historical" style="display:none"></div>
    <div style="text-align: right; margin-top: 2rem;">
      <button id="move-completed-button">Move Completed to History</button>
    </div>
  </div>
  <script>
    // Scroll detection for button opacity
    let scrollTimer;
    window.addEventListener('scroll', () => {
      document.body.classList.add('scrolling');
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        document.body.classList.remove('scrolling');
      }, 1000);
    });
    
    // Helper to read query params
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // API base precedence: ?api=... (query param) -> window.API_BASE -> default Render backend
    const urlApi = getQueryParam('api');
    const API_BASE = (urlApi ? urlApi.replace(/\/$/, '') : (window.API_BASE && window.API_BASE.replace(/\/$/, ''))) || 'https://parlay-tracker-backend.onrender.com';
    const btn=document.getElementById('refresh-button'),
      sec=document.getElementById('parlay-sections'),
      histSec=document.getElementById('historical-sections'),
      msg=document.getElementById('status-message'),
      statsUrl = `${API_BASE}/stats`,
      liveUrl = `${API_BASE}/live`,
      histUrl = `${API_BASE}/historical`;
    
    // Client-side cache for faster tab switching
    let cachedLive = null;
    let cachedHistorical = null;
    
    // === 1. THEME TOGGLE ===
    const themeToggle = document.getElementById('theme-toggle');
    const savedTheme = localStorage.getItem('theme') || 'dark';
    if (savedTheme === 'light') {
      document.body.classList.add('light-mode');
      themeToggle.textContent = '☀️';
    }
    
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      const isLight = document.body.classList.contains('light-mode');
      themeToggle.textContent = isLight ? '☀️' : '🌙';
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
    });
    
    // === 2. FILTER FUNCTIONALITY ===
    let currentFilter = 'all';
    const filterButton = document.getElementById('filter-button');
    const filterMenu = document.getElementById('filter-menu');
    
    filterButton.addEventListener('click', (e) => {
      e.stopPropagation();
      filterMenu.classList.toggle('active');
    });
    
    document.addEventListener('click', () => {
      filterMenu.classList.remove('active');
    });
    
    filterMenu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    document.querySelectorAll('.filter-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.filter-option').forEach(o => o.classList.remove('active'));
        option.classList.add('active');
        currentFilter = option.dataset.filter;
        filterMenu.classList.remove('active');
        applyFilter();
      });
    });
    
    function applyFilter() {
      document.querySelectorAll('.parlay-section').forEach(section => {
        const legs = section.querySelectorAll('tbody tr');
        let shouldShow = true;
        
        if (currentFilter === 'live') {
          shouldShow = Array.from(legs).some(leg => {
            const status = leg.querySelector('td:nth-child(8)')?.textContent;
            return status && status.includes('In Progress');
          });
        } else if (currentFilter === 'winning') {
          // Winning = any combination of Hit and Not Started (no Misses, no In Progress)
          const hasHit = Array.from(legs).some(leg => {
            const status = leg.querySelector('td:nth-child(8)')?.textContent;
            return status && status.includes('Hit');
          });
          const hasMiss = Array.from(legs).some(leg => {
            const status = leg.querySelector('td:nth-child(8)')?.textContent;
            return status && status.includes('Miss');
          });
          const allHitOrNotStarted = Array.from(legs).every(leg => {
            const status = leg.querySelector('td:nth-child(8)')?.textContent;
            return status && (status.includes('Hit') || status.includes('Not Started'));
          });
          shouldShow = hasHit && !hasMiss && allHitOrNotStarted;
        } else if (currentFilter === 'losing') {
          shouldShow = Array.from(legs).some(leg => {
            const status = leg.querySelector('td:nth-child(8)')?.textContent;
            return status && status.includes('Miss');
          });
        } else if (currentFilter === 'scheduled') {
          shouldShow = Array.from(legs).every(leg => {
            const status = leg.querySelector('td:nth-child(8)')?.textContent;
            return status && status.includes('Not Started');
          });
        } else if (currentFilter === 'clear') {
          currentFilter = 'all';
          shouldShow = true;
        }
        
        section.style.display = shouldShow ? 'block' : 'none';
      });
    }
    
    // === 3. PULL TO REFRESH ===
    let startY = 0;
    let isPulling = false;
    const pullRefresh = document.getElementById('pull-refresh');
    
    document.addEventListener('touchstart', (e) => {
      if (window.scrollY === 0) {
        startY = e.touches[0].pageY;
        isPulling = true;
      }
    });
    
    document.addEventListener('touchmove', (e) => {
      if (!isPulling) return;
      const currentY = e.touches[0].pageY;
      const diff = currentY - startY;
      
      if (diff > 80) {
        pullRefresh.classList.add('active');
        pullRefresh.textContent = 'Release to refresh...';
      }
    });
    
    document.addEventListener('touchend', async (e) => {
      if (!isPulling) return;
      isPulling = false;
      
      if (pullRefresh.classList.contains('active')) {
        pullRefresh.textContent = 'Refreshing...';
        await update();
        setTimeout(() => {
          pullRefresh.classList.remove('active');
        }, 1000);
      }
    });

    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', async () => {
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show/hide content
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(content => {
          if (content.dataset.tab === tabName) {
            content.style.display = 'block';
          } else {
            content.style.display = 'none';
          }
        });
        
        // Refresh data when switching tabs
        await update();
      });
    });

    // --- Admin Token Modal/Login UI ---
function showTokenModal() {
  let modal = document.getElementById('token-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'token-modal';
    modal.style = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:9999;';
    modal.innerHTML = `
      <div style="background:#222;padding:2rem 2.5rem;border-radius:12px;box-shadow:0 2px 16px #000;display:flex;flex-direction:column;align-items:center;min-width:300px;">
        <h2 style='color:#e657ff;margin-bottom:1rem;'>Enter Admin Token</h2>
        <input id='token-input' type='password' placeholder='Admin Token' style='padding:0.5rem 1rem;font-size:1.1rem;border-radius:6px;border:1px solid #888;width:100%;margin-bottom:1rem;'>
        <button id='token-submit' style='padding:0.5rem 1.5rem;background:#140d52;color:#fff;border:none;border-radius:6px;font-weight:bold;cursor:pointer;'>Login</button>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('token-submit').onclick = function() {
      const val = document.getElementById('token-input').value.trim();
      if (val) {
        localStorage.setItem('admin_token', val);
        modal.remove();
        location.reload();
      }
    };
    document.getElementById('token-input').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') document.getElementById('token-submit').click();
    });
  }
}

function getAdminToken() {
  let token = localStorage.getItem('admin_token');
  if (!token) {
    showTokenModal();
    throw new Error('No admin token set');
  }
  return token;
}

function logoutToken() {
  localStorage.removeItem('admin_token');
  location.reload();
}

// Add a logout button to the UI
(function addLogoutButton(){
  const btn = document.createElement('button');
  btn.textContent = 'Logout';
  btn.className = 'logout-btn';
  btn.style = 'position:fixed;top:1rem;right:1rem;z-index:1000;background:#f44336;color:#fff;padding:0.5rem 1.2rem;border:none;border-radius:8px;font-weight:bold;cursor:pointer;transition:opacity 0.3s;';
  btn.onclick = logoutToken;
  document.body.appendChild(btn);
})();

    function fetchWithAdminToken(url, options = {}) {
      let token;
      try {
        token = getAdminToken();
      } catch (e) {
        // If no token, the modal will be shown and error thrown
        // Return a rejected promise so the caller can handle it
        return Promise.reject(e);
      }
      options.headers = options.headers || {};
      options.headers['X-Admin-Token'] = token;
      return fetch(url, options);
    }

    // Prefetch historical data in the background so it appears instantly on switch
    (async function prefetchHistorical(){
      try{
        const r = await fetchWithAdminToken(histUrl);
        if(r.ok){ cachedHistorical = await r.json(); console.log('Prefetched historical:', cachedHistorical); }
      }catch(e){ console.warn('Prefetch historical failed', e); }
    })();

    function fmtType(stat){
      const m={'passing_yards':'Pass Yds','passing_yards_alt':'Alt Pass Yds','receiving_yards':'Rec Yds','receiving_yards_alt':'Alt Rec Yds','rushing_yards':'Rush Yds','rushing_yards_alt':'Alt Rush Yds','rushing_receiving_yards':'Rush + Rec Yds','anytime_touchdown':'Anytime TD','passing_touchdowns':'Pass TDs','rushing_touchdowns':'Rush TDs','receptions':'Receptions','receptions_alt':'Alt Receptions','longest_reception':'Longest Rec','moneyline':'Moneyline','spread':'Spread'};
      return m[stat]||stat.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase());
    }
    function getQuarter(p){return p===1?'1st Quarter':p===2?'2nd Quarter':p===3?'3rd Quarter':p===4?'4th Quarter':'Overtime';}

    // Get 3-letter team abbreviation from full team name
    function getTeamAbbr(teamName) {
      const abbrevMap = {
        'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
        'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
        'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
        'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
        'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
        'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
        'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
        'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
        'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
        'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
        'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
      };
      return abbrevMap[teamName] || teamName.substring(0, 3).toUpperCase();
    }

    // Format stat value for mobile display
    function formatStatForMobile(value, stat) {
      if (stat === 'moneyline') return value;
      if (stat === 'spread') return value;
      
      // For numeric stats, add unit abbreviations
      if (stat.includes('yards')) return `${value} Yds`;
      if (stat.includes('touchdown')) return `${value} TDs`;
      if (stat.includes('receptions')) return `${value} Rec`;
      if (stat.includes('passing')) return `${value} Pass`;
      if (stat.includes('rushing')) return `${value} Rush`;
      
      return value;
    }

    // Calculate countdown to game start
    function getCountdown(startDateTime) {
      if (!startDateTime) return '';
      
      const now = new Date();
      const gameStart = new Date(startDateTime);
      const diffMs = gameStart - now;
      
      if (diffMs <= 0) return 'Starting soon';
      
      const totalHours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      // If less than 24 hours, show hours and minutes
      if (totalHours < 24) {
        return `Starts in ${totalHours}h ${minutes}m`;
      }
      
      // If 24 hours or more, show days and hours (no minutes)
      const days = Math.floor(totalHours / 24);
      const hours = totalHours % 24;
      return `Starts in ${days}d ${hours}h`;
    }

    function enhanceParlayName(parlay) {
      // If parlay doesn't have legs, return original name
      if (!parlay.legs || parlay.legs.length === 0) {
        return parlay.name;
      }

      // Get unique teams from all legs
      const allTeams = new Set();
      parlay.legs.forEach(leg => {
        if (leg.away) allTeams.add(leg.away);
        if (leg.home) allTeams.add(leg.home);
      });

      // Only proceed if exactly 2 teams are involved
      if (allTeams.size !== 2) {
        return parlay.name;
      }

      // Get away and home teams from the first leg
      const away = parlay.legs[0].away;
      const home = parlay.legs[0].home;

      // Convert full team names to abbreviations
      const teamAbbrevMap = {
        'Atlanta Falcons': 'Falcons', 'Buffalo Bills': 'Bills', 'Carolina Panthers': 'Panthers',
        'Chicago Bears': 'Bears', 'Cincinnati Bengals': 'Bengals', 'Cleveland Browns': 'Browns',
        'Dallas Cowboys': 'Cowboys', 'Denver Broncos': 'Broncos', 'Detroit Lions': 'Lions',
        'Green Bay Packers': 'Packers', 'Houston Texans': 'Texans', 'Indianapolis Colts': 'Colts',
        'Jacksonville Jaguars': 'Jaguars', 'Kansas City Chiefs': 'Chiefs', 'Las Vegas Raiders': 'Raiders',
        'Los Angeles Chargers': 'Chargers', 'Los Angeles Rams': 'Rams', 'Miami Dolphins': 'Dolphins',
        'Minnesota Vikings': 'Vikings', 'New England Patriots': 'Patriots', 'New Orleans Saints': 'Saints',
        'New York Giants': 'Giants', 'New York Jets': 'Jets', 'Philadelphia Eagles': 'Eagles',
        'Pittsburgh Steelers': 'Steelers', 'San Francisco 49ers': '49ers', 'Seattle Seahawks': 'Seahawks',
        'Tampa Bay Buccaneers': 'Buccaneers', 'Tennessee Titans': 'Titans', 'Washington Commanders': 'Commanders',
        'Arizona Cardinals': 'Cardinals', 'Baltimore Ravens': 'Ravens'
      };

      const awayAbbrev = teamAbbrevMap[away] || away;
      const homeAbbrev = teamAbbrevMap[home] || home;
      const matchup = `${awayAbbrev} @ ${homeAbbrev}`;

      // Check if the matchup or team names are already in the parlay name
      const nameContainsMatchup = parlay.name.includes('@') || 
                                   parlay.name.includes(awayAbbrev) || 
                                   parlay.name.includes(homeAbbrev) ||
                                   parlay.name.includes(away) ||
                                   parlay.name.includes(home);

      // If matchup info not already in name, append it
      if (!nameContainsMatchup) {
        return `${parlay.name} - ${matchup}`;
      }

      return parlay.name;
    }

    async function update(){
      msg.textContent='Fetching data...';
      try{
        // First process any new parlays
        await fetchWithAdminToken(statsUrl);
        
        // Get active tab
        const activeTab = document.querySelector('.tab.active').dataset.tab;
        
        // Only fetch data for the active tab; use cache if available
        if(activeTab === 'current') {
          // Fetch both todays and live bets and combine them
          const todaysUrl = `${API_BASE}/todays`;
          const [todaysResponse, liveResponse] = await Promise.all([
            fetchWithAdminToken(todaysUrl),
            fetchWithAdminToken(liveUrl)
          ]);
          
          if(!todaysResponse.ok) throw new Error(`Todays data error: ${todaysResponse.status}`);
          if(!liveResponse.ok) throw new Error(`Live data error: ${liveResponse.status}`);
          
          const todaysParlays = await todaysResponse.json();
          const liveParlays = await liveResponse.json();
          
          // Combine both arrays
          const combinedParlays = [...todaysParlays, ...liveParlays];
          cachedLive = combinedParlays;
          
          console.log('Todays parlays:', todaysParlays);
          console.log('Live parlays:', liveParlays);
          console.log('Combined parlays:', combinedParlays);
          
          render(combinedParlays, sec);
        } else if(activeTab === 'historical') {
          if (cachedHistorical) {
            console.log('Using cached historical data');
            render(cachedHistorical, histSec);
          } else {
            const historicalResponse = await fetchWithAdminToken(histUrl);
            if(!historicalResponse.ok) throw new Error(`Historical data error: ${historicalResponse.status}`);
            const historical = await historicalResponse.json();
            cachedHistorical = historical;
            console.log('Historical parlays:', historical);
            render(historical, histSec);
          }
        }
        
        msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
      }catch(e){
        console.error('Error during update:', e);
        msg.textContent=`Error loading data: ${e.message}`;
      }
    }

    async function loadHistorical(){
      msg.textContent='Loading historical bets...';
      try{
        console.log('Fetching from:', histUrl);
        const r=await fetchWithAdminToken(histUrl);
        if(!r.ok)throw r.status;
        const historical=await r.json();
        console.log('Received historical data:', historical);
        render(historical, histSec);
        msg.textContent=`Historical data loaded: ${new Date().toLocaleTimeString()}`;
      }catch(e){
        console.error('Error loading historical data:', e);
        msg.textContent='Error loading historical data: ' + e.toString();
      }
    }

    function render(parlays, container){
      console.log('Render called with parlays:', parlays);
      console.log('Container:', container);
      container.innerHTML='';
      if (!Array.isArray(parlays)) {
        console.error('parlays is not an array:', parlays);
        return;
      }

      // Check if this is the historical section
      const isHistoricalSection = container.id === 'historical-sections' || container.dataset.tab === 'historical';
      
      // Sort parlays by earliest game date
      const sortedParlays = [...parlays].sort((a, b) => {
        // Find earliest date in each parlay
        const getEarliestDate = (parlay) => {
          if (!parlay.legs || parlay.legs.length === 0) return new Date('9999-12-31');
          const dates = parlay.legs
            .map(leg => leg.game_date)
            .filter(date => date)
            .map(date => new Date(date));
          return dates.length > 0 ? new Date(Math.min(...dates)) : new Date('9999-12-31');
        };
        
        const dateA = getEarliestDate(a);
        const dateB = getEarliestDate(b);
        
        // For historical: latest games first (descending)
        // For live: earliest games first (ascending)
        return isHistoricalSection ? dateB - dateA : dateA - dateB;
      });

      // Show a helpful empty-state when there's no data for the tab
      if (sortedParlays.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'no-data';
        const tabName = container.dataset.tab === 'historical' ? 'Historical Bets' : "Live Bets";
        empty.innerHTML = `
          <div style="text-align:center;padding:2rem;color:#bbb">
            <strong>No parlays found</strong>
            <div style="margin-top:.5rem">There are no ${tabName} to display right now.</div>
            <button id="empty-refresh" style="margin-top:1rem;padding:.5rem 1rem;border-radius:6px;background:#140d52;color:#fff;border:none;cursor:pointer">Refresh</button>
          </div>`;
        container.appendChild(empty);
        // wire the refresh button to re-run update()
        const b = empty.querySelector('#empty-refresh');
        if (b) b.addEventListener('click', update);
        return;
      }
      
      // Render all parlays in their respective sections (isHistoricalSection already defined above for sorting)
      sortedParlays.forEach(parlay=>{
        console.log('Processing parlay:', parlay);
        const section=document.createElement('div');
        section.className='parlay-section';
        section.dataset.site = parlay.betting_site || 'Unknown'; // For color-coding
        
        const header=document.createElement('div');
        header.className='parlay-header';
        
        // Enhance parlay name with team matchup if applicable
        const displayName = enhanceParlayName(parlay);
        
        // Check if all legs are at 100% (winning bet)
        const allLegsComplete = parlay.legs && parlay.legs.length > 0 && 
          parlay.legs.every(leg => {
            const pct = leg.target > 0 ? Math.min(100, Math.round(leg.current / leg.target * 100)) : 0;
            return pct === 100;
          });
        
        // Get game date for single game parlays
        let formattedDate = '';
        if (parlay.legs && parlay.legs[0]) {
          // Get unique game dates from all legs
          const uniqueDates = [...new Set(parlay.legs.map(leg => leg.game_date))].filter(d => d);
          
          // If there's only one unique date, it's a single game parlay
          if (uniqueDates.length === 1 && uniqueDates[0]) {
            const dateStr = String(uniqueDates[0]);
            try {
              let gameDate;
              
              // Handle both formats: YYYY-MM-DD (new standard) and YYYYMMDD (legacy)
              if (dateStr.includes('-')) {
                // YYYY-MM-DD format
                gameDate = new Date(dateStr);
              } else if (dateStr.length === 8) {
                // YYYYMMDD format (legacy)
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(4, 6);
                const day = dateStr.substring(6, 8);
                gameDate = new Date(`${year}-${month}-${day}`);
              }
              
              // Check if date is valid
              if (gameDate && !isNaN(gameDate.getTime())) {
                const dayOfWeek = gameDate.toLocaleDateString('en-US', { weekday: 'long' });
                const monthName = gameDate.toLocaleDateString('en-US', { month: 'short' });
                const dayNum = gameDate.getDate();
                const yearNum = gameDate.getFullYear();
                formattedDate = `${dayOfWeek} - ${monthName} ${dayNum}, ${yearNum}`;
              }
            } catch (e) {
              console.error('Error parsing date:', dateStr, e);
            }
          }
        }
        
        header.innerHTML = `
          ${allLegsComplete ? '<div class="winning-overlay"></div>' : ''}
          <div class="parlay-title">
            <div class="parlay-title-text">
              <span class="collapse-icon">▼</span>
              <div>
                <div>${displayName}</div>
                ${formattedDate && `<span class="parlay-date">${formattedDate}</span>`}
              </div>
            </div>
          </div>
        `;

        const allGamesDiv=document.createElement('div');
        allGamesDiv.className='game-info-wrapper';

        // Debug logging
        console.log('Parlay:', parlay.name, 'has games:', parlay.games ? parlay.games.length : 'undefined');

        // Show scoreboard if games data exists
        if (parlay.games && parlay.games.length > 0) {
          // For non-SGPs, we want to show all relevant games
          if (parlay.type !== 'SGP') {
            // Create a map of unique games based on away+home team combination
            const uniqueGames = new Map();
            parlay.legs.forEach(leg => {
              const gameKey = `${leg.away}-${leg.home}`;
              const game = parlay.games.find(g => 
                g.teams.away === leg.away && g.teams.home === leg.home
              );
              if (game && !uniqueGames.has(gameKey)) {
                uniqueGames.set(gameKey, game);
              }
            });
            
            // Show all unique games involved in the parlay
            uniqueGames.forEach(g => {
              const stn=g.statusTypeName,isSched=stn==='STATUS_SCHEDULED',isLive=stn==='STATUS_IN_PROGRESS',isHalftime=stn==='STATUS_HALFTIME';
              let gameStatus,gameCls,gameDetails;
              if(isSched){
                gameStatus='🔜 Not Started';
                gameCls='status-pregame';
                const countdown = getCountdown(g.startDateTime);
                gameDetails=`<div>${getTeamAbbr(g.teams.away)} @ ${getTeamAbbr(g.teams.home)}</div><div>${countdown || g.startTime}</div>`;
              }
              else if(isHalftime){gameStatus='HALF';gameCls='status-halftime';gameDetails=`<div>${getQuarter(g.period)}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else if(isLive){gameStatus='LIVE';gameCls='status-live';gameDetails=`<div>${getQuarter(g.period)}, ${g.clock}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else{gameStatus='FINAL';gameCls='status-final';gameDetails=`<div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              
              const gameInfoDiv=document.createElement('div');
              gameInfoDiv.className='game-info';
              gameInfoDiv.innerHTML=`<div class="badge ${gameCls}">${gameStatus}</div>${gameDetails}`;
              allGamesDiv.appendChild(gameInfoDiv);
            });
          } else {
            // For SGPs, show the game info as before
            parlay.games.forEach(g=>{
              const stn=g.statusTypeName,isSched=stn==='STATUS_SCHEDULED',isLive=stn==='STATUS_IN_PROGRESS',isHalftime=stn==='STATUS_HALFTIME';
              let gameStatus,gameCls,gameDetails;
              if(isSched){
                gameStatus='🔜 Not Started';
                gameCls='status-pregame';
                const countdown = getCountdown(g.startDateTime);
                gameDetails=`<div>${getTeamAbbr(g.teams.away)} @ ${getTeamAbbr(g.teams.home)}</div><div>${countdown || g.startTime}</div>`;
              }
              else if(isHalftime){gameStatus='HALF';gameCls='status-halftime';gameDetails=`<div>${getQuarter(g.period)}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else if(isLive){gameStatus='LIVE';gameCls='status-live';gameDetails=`<div>${getQuarter(g.period)}, ${g.clock}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else{gameStatus='FINAL';gameCls='status-final';gameDetails=`<div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              
              const gameInfoDiv=document.createElement('div');
              gameInfoDiv.className='game-info';
              gameInfoDiv.innerHTML=`<div class="badge ${gameCls}">${gameStatus}</div>${gameDetails}`;
              allGamesDiv.appendChild(gameInfoDiv);
            });
          }
        }
        header.appendChild(allGamesDiv);

        const isAnyGameLive = parlay.games && parlay.games.some(g=>g.statusTypeName==='STATUS_IN_PROGRESS' || g.statusTypeName==='STATUS_HALFTIME');
        const areAllGamesFinal = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_FINAL');
        const areAllGamesScheduled = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_SCHEDULED');

        // Sort legs by status for Live Bets: "In Progress" → "Not Started" → "Hit"
        // Only sort for live bets tab, not historical
        let legsToRender = parlay.legs;
        if (!isHistoricalSection) {
          legsToRender = [...parlay.legs].sort((a, b) => {
            // Helper function to determine leg status
            const getLegStatus = (leg) => {
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === leg.away && g.teams.home === leg.home
              ) : null;
              
              const isSpreadOrML = leg.stat === 'spread' || leg.stat === 'moneyline';
              const current = leg.current ?? 0;
              const pct = leg.target > 0 ? Math.min(100, Math.round(current / leg.target * 100)) : 0;
              
              // Check if game is in progress
              if (gameData && (gameData.statusTypeName === 'STATUS_IN_PROGRESS' || gameData.statusTypeName === 'STATUS_HALFTIME')) {
                return 'In Progress';
              }
              
              // Check if not started
              if (gameData && gameData.statusTypeName === 'STATUS_SCHEDULED') {
                return 'Not Started';
              }
              if (!gameData && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))) {
                return 'Not Started';
              }
              
              // Check if hit (100% or winning bet)
              if (!isSpreadOrML && pct === 100) {
                return 'Hit';
              }
              if (isSpreadOrML && gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                const scoreDiff = leg.score_diff ?? 0;
                let isWinningBet = false;
                if (leg.stat === 'moneyline') {
                  isWinningBet = scoreDiff > 0;
                } else if (leg.stat === 'spread') {
                  isWinningBet = (scoreDiff + leg.target) > 0;
                }
                return isWinningBet ? 'Hit' : 'Miss';
              }
              
              return 'In Progress'; // Default
            };
            
            const statusA = getLegStatus(a);
            const statusB = getLegStatus(b);
            
            // Sort order: "In Progress" → "Not Started" → "Hit" → "Miss"
            const statusOrder = {
              'In Progress': 0,
              'Not Started': 1,
              'Hit': 2,
              'Miss': 3
            };
            
            return (statusOrder[statusA] ?? 99) - (statusOrder[statusB] ?? 99);
          });
        }

        const table=document.createElement('table');
        table.innerHTML=`
          <thead><tr>
            <th>Player</th><th>Bet Type</th><th>Current</th>
            <th>Target</th><th style="width:25%;">Progress</th><th>Status</th>
          </tr></thead>
          <tbody>
            ${legsToRender.map(p=>{
              const current = p.current ?? 0; // Handle undefined/null as 0
              const pct = p.target > 0 ? Math.min(100, Math.round(current / p.target * 100)) : 0;
              
              // Check if this is a spread or moneyline bet (no progress bar)
              const isSpreadOrML = p.stat === 'spread' || p.stat === 'moneyline';
              
              // Get game data for this leg
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === p.away && g.teams.home === p.home
              ) : null;
              
              let progressCol = '';
              let currentDisplay = current;
              let targetDisplay = p.target;
              
              if (isSpreadOrML) {
                // For spread/moneyline, show score with team names only
                const scoreDiff = p.score_diff ?? 0;
                const betTeam = p.team || '';
                const betTeamName = betTeam.split(' ').pop(); // Get last word (e.g., "Cowboys")
                
                // Find opponent team name
                let opponentTeamName = '';
                if (gameData) {
                  const isHome = betTeam === gameData.teams.home;
                  const opponentFull = isHome ? gameData.teams.away : gameData.teams.home;
                  opponentTeamName = opponentFull.split(' ').pop();
                  
                  // Get actual scores
                  const betTeamScore = isHome ? gameData.score.home : gameData.score.away;
                  const oppTeamScore = isHome ? gameData.score.away : gameData.score.home;
                  
                  // Show score in format: "Cowboys 21 - 7 Falcons" (bet team always on left)
                  progressCol = `<div style="text-align:center;padding:0.5rem;font-weight:bold;">${betTeamName} ${betTeamScore} - ${oppTeamScore} ${opponentTeamName}</div>`;
                } else {
                  // No game data yet (scheduled game)
                  progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
                }
                
                // For moneyline: current shows winning/losing status, target shows "Win"
                if (p.stat === 'moneyline') {
                  targetDisplay = 'Win';
                  if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                    const isFinal = gameData.statusTypeName === 'STATUS_FINAL';
                    if (scoreDiff > 0) {
                      currentDisplay = isFinal ? 'Win' : `Winning by ${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = isFinal ? 'Loss' : `Losing by ${Math.abs(scoreDiff)}`;
                    } else {
                      currentDisplay = 'Tied';
                    }
                  } else if (!gameData && (areAllGamesFinal || areAllGamesScheduled === false)) {
                    // Historical data without game info - use current value
                    currentDisplay = current === 1 ? 'Win' : 'Loss';
                  } else {
                    currentDisplay = '-';
                  }
                }
                
                // For spread: format target with +/- sign
                if (p.stat === 'spread') {
                  targetDisplay = p.target > 0 ? `+${p.target}` : `${p.target}`;
                  // Current shows Win/Loss for final games, 0/1 otherwise
                  if (gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                    currentDisplay = current === 1 ? 'Win' : 'Loss';
                  } else {
                    currentDisplay = current;
                  }
                }
                
              } else {
                // Regular progress bar for numeric stats
                let cls = '';
                if (areAllGamesFinal) {
                  cls = (pct === 100) ? 'pct-full' : 'pct-vlow';
                } else {
                  if (pct === 100) {
                    cls = 'pct-full';
                  } else if (pct >= 60) {
                    cls = 'pct-mid';
                  } else if (pct >= 20) {
                    cls = 'pct-low';
                  } else if (pct > 0) {
                    cls = 'pct-vlow';
                  }
                }
                progressCol = `<div class="progress-bar ${cls}">
                           <div class="progress ${cls}" style="width:${pct}%"></div>
                           <div class="progress-text">${pct}%</div>
                         </div>`;
              }
              
              let txt;
              // Determine win/loss for spread/moneyline based on actual game result
              let isWinningBet = false;
              if (isSpreadOrML && gameData) {
                const scoreDiff = p.score_diff ?? 0;
                console.log(`[Status Check] ${p.team || p.player} - ${p.stat}: scoreDiff=${scoreDiff}, target=${p.target}, gameStatus=${gameData.statusTypeName}`);
                
                if (p.stat === 'moneyline') {
                  // Moneyline: just need to win (positive score difference)
                  isWinningBet = scoreDiff > 0;
                  console.log(`  Moneyline: scoreDiff > 0 = ${isWinningBet}`);
                } else if (p.stat === 'spread') {
                  // Spread: score_diff + spread > 0
                  // Example: -7 spread, win by 10 = 10 + (-7) = 3 > 0 ✓
                  // Example: +3.5 spread, lose by 3 = -3 + 3.5 = 0.5 > 0 ✓
                  isWinningBet = (scoreDiff + p.target) > 0;
                  console.log(`  Spread: (${scoreDiff} + ${p.target}) = ${scoreDiff + p.target} > 0 = ${isWinningBet}`);
                }
              }
              
              // Status logic - check game state FIRST before showing win/loss
              if(gameData && gameData.statusTypeName === 'STATUS_SCHEDULED') {
                txt='🔜 Not Started';
              } else if(gameData && (gameData.statusTypeName === 'STATUS_IN_PROGRESS' || gameData.statusTypeName === 'STATUS_HALFTIME')) {
                txt='⏳ In Progress';
              } else if(!gameData && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))) {
                txt='🔜 Not Started';
              } else if(isSpreadOrML && gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                // For spread/moneyline, only show Hit/Miss when game is FINAL
                txt = isWinningBet ? '✅ Hit' : '🚫 Miss';
              } else if(!isSpreadOrML) {
                // For numeric stats (player props), show Hit if 100% reached even during live game
                if(pct===100) txt='✅ Hit';
                else if(areAllGamesFinal) txt='🚫 Miss';
                else txt='⏳ In Progress';
              } else {
                txt='⏳ In Progress'; // Default to in progress
              }
              
              // Format for mobile display
              const playerOrTeam = p.player || p.team || 'N/A';
              const statType = fmtType(p.stat);
              const mobileCurrentDisplay = formatStatForMobile(currentDisplay, p.stat);
              const mobileTargetDisplay = formatStatForMobile(targetDisplay, p.stat);
              
              return`
                <tr>
                  <td>
                    <div class="mobile-line-1">
                      <span><strong>${playerOrTeam}</strong><span style="font-weight:normal;"> - ${statType}</span></span>
                      <span>${txt}</span>
                    </div>
                  </td>
                  <td>
                    <div class="mobile-line-2-header">
                      <span>Current</span>
                      <span></span>
                      <span>Target</span>
                    </div>
                    <div class="mobile-line-2">
                      <span>${mobileCurrentDisplay}</span>
                      <span>${progressCol}</span>
                      <span>${mobileTargetDisplay}</span>
                    </div>
                  </td>
                  <td>${p.player || p.team || 'N/A'}</td>
                  <td>${fmtType(p.stat)}</td>
                  <td>${currentDisplay}</td>
                  <td>${targetDisplay}</td>
                  <td>${progressCol}</td>
                  <td>${txt}</td>
                </tr>`;
            }).join('')}
          </tbody>`;
        
        // Create footer with bet info
        const footer = document.createElement('div');
        footer.className = 'parlay-footer';
        
        const oddsText = parlay.odds || 'N/A';
        const wagerText = parlay.wager ? `$${parlay.wager}` : 'N/A';
        const betIdText = parlay.bet_id || 'N/A';
        const siteText = parlay.betting_site || 'N/A';
        
        footer.innerHTML = `
          <div class="footer-left">
            <div class="footer-odds">Odds: ${oddsText}</div>
            <div class="footer-wager">Wager: ${wagerText}</div>
          </div>
          <div class="footer-right">
            <div class="footer-betid">Bet ID: ${betIdText}</div>
            <div class="footer-site">${siteText}</div>
          </div>
        `;
        
        // Wrap table and footer in parlay-body div for collapsing
        const parlayBody = document.createElement('div');
        parlayBody.className = 'parlay-body';
        parlayBody.appendChild(table);
        parlayBody.appendChild(footer);
        
        section.appendChild(header);
        section.appendChild(parlayBody);
        
        // Add collapse/expand functionality
        header.addEventListener('click', () => {
          section.classList.toggle('collapsed');
        });
        
        // Append to the container passed into render() so each tab gets its own content
        container.appendChild(section);
      });
      
      // === 4. SORTABLE COLUMNS ===
      document.querySelectorAll('thead th').forEach((th, index) => {
        th.addEventListener('click', () => {
          const table = th.closest('table');
          const tbody = table.querySelector('tbody');
          const rows = Array.from(tbody.querySelectorAll('tr'));
          
          // Determine sort direction
          const isAsc = th.classList.contains('sorted') && th.classList.contains('asc');
          
          // Remove sorted class from all headers
          table.querySelectorAll('thead th').forEach(h => {
            h.classList.remove('sorted', 'asc');
          });
          
          // Add sorted class to clicked header
          th.classList.add('sorted');
          if (!isAsc) th.classList.add('asc');
          
          // Sort rows
          rows.sort((a, b) => {
            const aCell = a.querySelectorAll('td')[index]?.textContent.trim() || '';
            const bCell = b.querySelectorAll('td')[index]?.textContent.trim() || '';
            
            // Try numeric comparison first
            const aNum = parseFloat(aCell);
            const bNum = parseFloat(bCell);
            
            if (!isNaN(aNum) && !isNaN(bNum)) {
              return isAsc ? aNum - bNum : bNum - aNum;
            }
            
            // String comparison
            return isAsc ? aCell.localeCompare(bCell) : bCell.localeCompare(aCell);
          });
          
          // Re-append sorted rows
          rows.forEach(row => tbody.appendChild(row));
        });
      });
      
      // Apply filter after rendering
      applyFilter();
    }

    btn.addEventListener('click',update);
    
    // Move completed games button
    const moveBtn = document.getElementById('move-completed-button');
    moveBtn.addEventListener('click', async () => {
      try {
        msg.textContent = 'Moving completed games...';
        moveBtn.disabled = true;
        
        const response = await fetchWithAdminToken(`${API_BASE}/admin/move_completed`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) throw new Error(`Move failed: ${response.status}`);
        
        const result = await response.json();
        msg.textContent = `Moved ${result.moved_count} parlay(s) to history. ${result.remaining_live} still live.`;
        
        // Clear caches and refresh
        cachedLive = null;
        cachedHistorical = null;
        await update();
      } catch (e) {
        console.error('Error moving completed:', e);
        msg.textContent = `Error: ${e.message}`;
      } finally {
        moveBtn.disabled = false;
      }
    });
    
    update();
  </script>
</body>
</html>
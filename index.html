<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Parlay & Wager Tracker</title>
  
  <!-- PWA Configuration -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#140d52">
  
  <!-- Android specific -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Parlay Tracker">
  
  <!-- iOS specific -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Parlays">
  
  <!-- App Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="/media/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/media/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/media/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="512x512" href="/media/icons/icon-512x512.png">
  
  <!-- Description for search engines and sharing -->
  <meta name="description" content="Track your sports betting parlays and monitor live stats in real-time">
  <style>
    :root {
      /* Dark mode colors (default) */
      --bg:#121212;--surface:#252525;--primary:#140d52;
      --text:#e0e0e0;--border:#ffcc00a4;--green:#4caf50;
      --orange:#ff9800;--yellow:#ffeb3b;--pregame:#ffc107;
      --error:#f44336;--progress-bg:#444;--section-bg:#1a1a1a;
      --outline-blue: #03a9f4; --title-color: #e657ff;
      --tab-active: #2a2a2a;
      
      /* Betting site colors */
      --draftkings: #4caf50;
      --fanduel: #2196f3;
      --dabble: #ffc107;
    }
    
    /* Light mode colors */
    body.light-mode {
      --bg:#f5f5f5;--surface:#f0f0f0;--primary:#5e35b1;
      --text:#212121;--border:#ffcc00;--green:#388e3c;
      --orange:#f57c00;--yellow:#fbc02d;--pregame:#ff6f00;
      --error:#c62828;--progress-bg:#e0e0e0;--section-bg:#ffffff;
      --outline-blue: #0288d1; --title-color: #7b1fa2;
      --tab-active: #e0e0e0;
    }
    
    /* Theme toggle button - moved to top left */
    .theme-toggle {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: transform 0.2s, opacity 0.3s;
    }
    
    .theme-toggle:hover {
      transform: scale(1.1);
    }
    
    /* Reduce opacity when scrolling */
    body.scrolling .theme-toggle {
      opacity: 0.25;
    }
    
    /* Logout button scroll opacity */
    body.scrolling .logout-btn {
      opacity: 0.25 !important;
    }
    
    /* Filter button - inline with Refresh button */
    .filter-button {
      display: inline-block;
      position: static;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.6rem 1.2rem; /* Match toolbar-button padding */
      cursor: pointer;
      font-weight: 600; /* Match toolbar-button weight */
      margin: 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); /* Match toolbar-button shadow */
      transition: opacity 0.2s;
      height: 40px; /* Match toolbar-button height */
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      line-height: 1;
    }
    
    .filter-button:hover {
      opacity: 0.9;
    }
    
    /* New toolbar styles */
    .toolbar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0 1rem 0; /* Consistent margin */
      flex-wrap: wrap;
      min-height: 40px; /* Ensure minimum height matches button height */
    }
    
    .toolbar-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      height: 40px;
    }
    
    .toolbar-controls > div {
      display: flex;
      align-items: center;
      height: 40px;
    }
    
    .toolbar-search {
      display: flex;
      align-items: center;
      height: 40px;
    }
    
    .toolbar-button {
      padding: 0.6rem 1.2rem;
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.2s;
      position: relative;
      height: 40px; /* Fixed height for alignment */
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      line-height: 1;
    }
    
    .toolbar-button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
    
    .search-input {
      padding: 0.6rem 1rem;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
      color: var(--text);
      font-size: 0.9rem;
      width: 250px;
      transition: border-color 0.2s;
      height: 40px; /* Fixed height for alignment */
      box-sizing: border-box;
      line-height: 1;
      vertical-align: middle;
    }
    
    .search-input:focus {
      outline: none;
      border-color: var(--primary);
    }
    
    /* Sub-panel for filter options - smaller dropdown to the right */
    .filter-sub-panel {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 0;
      width: 150px; /* Match collapse-menu width */
      max-height: 400px;
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 1001;
      overflow-y: auto;
      display: none;
    }
    
    .filter-sub-panel.active {
      display: block;
    }
    
    .filter-panel-header {
      padding: 0.3rem 0.5rem; /* Reduced vertical padding by 33% (from 0.5rem to 0.3rem) */
      background: var(--primary);
      color: #fff;
      font-weight: bold;
      font-size: 0.9rem; /* Match dropdown font size */
      display: flex;
      justify-content: center;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
      border-radius: 6px 6px 0 0;
      min-height: 30px; /* Reduced from default */
    }
    
    .filter-panel-back {
      background: none;
      border: none;
      color: #fff;
      font-size: 1rem; /* Slightly smaller for narrow panel */
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      left: 0.5rem; /* Position in top-left corner */
      top: 50%;
      transform: translateY(-50%);
    }
    
    .filter-panel-close {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      right: 0.5rem; /* Position in top-right corner */
      top: 50%;
      transform: translateY(-50%);
    }
    
    .filter-panel-content {
      padding: 0.5rem; /* Match collapse-menu padding */
      font-size: 0.9rem; /* Match dropdown font size */
    }
    
    .filter-category {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: var(--section-bg);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .filter-category:hover {
      background: var(--parlay-bg);
    }
    
    .filter-category-title {
      font-weight: bold;
      font-size: 1rem;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .filter-category-desc {
      font-size: 0.85rem;
      opacity: 0.7;
    }
    
    .filter-option-item {
      padding: 0.6rem 1rem; /* Match collapse-option padding */
      margin: 0.25rem 0; /* Match collapse-option margin */
      background: var(--section-bg);
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
      font-size: 0.9rem; /* Match dropdown font size */
    }
    
    .filter-option-item:hover {
      background: var(--parlay-bg);
      border-color: var(--primary);
    }
    
    .filter-option-item.selected {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    
    .filter-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    
    .filter-overlay.active {
      display: block;
    }
    
    /* Collapse menu */
    .collapse-menu {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      z-index: 998;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      display: none;
      min-width: 150px;
    }
    
    .collapse-menu.active {
      display: block;
    }
    
    .collapse-option {
      padding: 0.6rem 1rem;
      margin: 0.25rem 0;
      background: var(--section-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text);
      display: block;
      width: 100%;
      text-align: left;
      transition: background 0.2s;
      font-size: 0.9rem;
    }
    
    .collapse-option:hover {
      background: var(--primary);
      color: #fff;
    }
    
    /* Old filter menu - keeping for compatibility but will hide */
    .filter-menu {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      z-index: 999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      display: none;
      min-width: 200px;
    }
    
    .filter-menu.active {
      display: block;
    }
    
    /* Button container for centering */
    .button-container {
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
    }
    
    #refresh-button {
      display: inline-block;
      margin: 0;
      padding: 0.75rem 1.5rem;
      background: var(--primary);
      color: #fff;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    
    .button-container > div {
      display: flex;
      align-items: center;
      margin: 0;
    }
    
    .filter-option {
      padding: 0.5rem 1rem;
      margin: 0.25rem 0;
      background: var(--section-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text);
      display: block;
      width: 100%;
      text-align: left;
      transition: background 0.2s;
    }
    
    .filter-option:hover, .filter-option.active {
      background: var(--primary);
      color: #fff;
    }
    
    /* Collapsible parlay */
    .parlay-section.collapsed .parlay-body {
      display: none;
    }
    
    .parlay-section.collapsed {
      padding: 0 !important;
    }
    
    .parlay-section.collapsed .parlay-header {
      margin: 0 !important;
      border-radius: 12px 12px 0 0 !important;
    }
    
    .parlay-section.collapsed .parlay-footer {
      margin: 0 !important;
      border-radius: 0 0 12px 12px !important;
    }
    
    .parlay-header {
      cursor: pointer;
      user-select: none;
    }
    
    .parlay-title {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      position: relative;
      z-index: 1;
      width: 100%;
    }
    
    .collapse-icon {
      display: inline-block;
      margin-right: 0.5rem;
      transition: transform 0.3s;
      width: 20px;
      text-align: center;
      flex-shrink: 0;
    }
    
    .parlay-section.collapsed .collapse-icon {
      transform: rotate(-180deg);
    }
    
    .parlay-title-text {
      display: flex;
      align-items: center;
    }
    
    /* Sortable column headers */
    thead th {
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    
    thead th:hover {
      background: var(--primary) !important;
    }
    
    thead th.sorted::after {
      content: ' ▼';
      font-size: 0.7em;
    }
    
    thead th.sorted.asc::after {
      content: ' ▲';
    }
    
    /* Pull to refresh indicator */
    .pull-refresh {
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: #fff;
      padding: 0.5rem 1rem;
      border-radius: 0 0 8px 8px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1001;
    }
    
    .pull-refresh.active {
      opacity: 1;
    }
    
    .tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      justify-content: center;
    }
    
    .tab {
      padding: 0.75rem 1.5rem;
      background: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    .tab:hover {
      opacity: 0.9;
    }
    
    .tab.active {
      background: var(--tab-active);
      color: var(--title-color);
    }
    body{background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
      margin:0;
      padding:1rem;
      /* iOS safe area insets for notch/Dynamic Island */
      padding-top: max(1rem, env(safe-area-inset-top));
      padding-bottom: max(1rem, env(safe-area-inset-bottom));
      padding-left: max(1rem, env(safe-area-inset-left));
      padding-right: max(1rem, env(safe-area-inset-right));
      zoom: 0.8;}
    .container{max-width:1200px;margin:auto;padding:2rem;
      background:var(--surface);border-radius:12px;
      box-shadow:0 4px 20px rgba(0,0,0,0.25);}
    h1{text-align:center;color:var(--title-color);margin-bottom:1.5rem;}
    button{display:block;margin:0 auto 1.5rem;padding:.75rem 1.5rem;
      background:var(--primary);color:#fff;font-weight:bold;
      border:none;border-radius:8px;cursor:pointer;}
    button:hover{opacity:.9;}
    #status-message{text-align:center;margin:0.5rem 0 1.5rem 0;color:#aaa;} /* Added bottom margin for spacing */
    .parlay-section{background:var(--section-bg);margin-bottom:2rem;
      border-radius:12px;padding:1.5rem 1.5rem 1.125rem;border:1px solid #cccccc;}
    .parlay-header{
      background:linear-gradient(135deg, var(--primary) 0%, rgba(20, 13, 82, 0.7) 100%);
      color:#fff;
      margin:-1.5rem -1.5rem 1.125rem -1.5rem;padding:1rem 1.5rem;
      border-radius:10px 10px 0 0;display:flex; flex-wrap: wrap;
      justify-content:space-between;align-items:flex-start;font-weight:bold;
      position:relative;
      cursor: pointer;
      user-select: none;
      gap: 1rem;
      overflow: hidden;
    }
    /* Single scoreboard: keep header on one line */
    .parlay-header:has(.game-info-wrapper .game-info:only-child) {
      flex-wrap: nowrap;
    }
    .parlay-footer{
      background:linear-gradient(135deg, var(--primary) 0%, rgba(20, 13, 82, 0.7) 100%);
      color:#fff;
      margin:1.125rem -1.5rem -1.125rem -1.5rem;padding:0.375rem 1.5rem;
      border-radius:0 0 10px 10px;display:flex;
      justify-content:space-between;align-items:center;
      font-size:0.75rem;min-height:1.5rem;
      position: relative;
      overflow: hidden;
    }
    
    /* Footer logo styling */
    .footer-logo {
      position: absolute;
      right: 0.5rem;
      top: 0;
      bottom: 0;
      height: 120%;
      width: auto;
      opacity: 0.15;
      object-fit: contain;
      pointer-events: none;
      transform: translateY(-10%);
    }
    
    /* Ensure footer content stays above logo */
    .footer-left, .footer-right {
      position: relative;
      z-index: 1;
    }
    
    .footer-left{display:flex;flex-direction:column;gap:0.25rem;}
    .footer-right{display:flex;flex-direction:column;gap:0.25rem;text-align:right;}
    .footer-odds{font-weight:bold;color:#FFD700;}
    .footer-wager{color:#ddd;}
    .footer-betid{color:#ddd;}
    .footer-site{color:#fff;font-weight:500;}
    .trophy-icon{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%, -50%) scale(1.25) rotate(-30deg);
      height:100%;
      width:auto;
      opacity:0.3;
      pointer-events:none;
      z-index:0;
      object-fit:contain;}
    /* Trophy theme switching */
    body.dark-mode .trophy-light {display: none;}
    body.dark-mode .trophy-dark {display: block;}
    body:not(.dark-mode) .trophy-dark {display: none;}
    body:not(.dark-mode) .trophy-light {display: block;}
    .parlay-title{display:flex;flex-direction:column;gap:0.25rem;position:relative;z-index:1;flex:1 1 auto;min-width:0;}
    .parlay-date{font-size:0.85rem;font-weight:normal;opacity:0.8;}
    .game-info-wrapper{display:flex;gap:0.5rem;flex-wrap:wrap;position:relative;z-index:1;justify-content:flex-end;align-items:flex-start;flex:0 1 100%;flex-direction:row;}
    /* Single game: align scoreboards to the right, no reversal, no size constraints */
    .game-info-wrapper:has(.game-info:only-child) {
      justify-content:flex-end;
      width:auto;
      flex:0 0 auto;
      flex-direction:row;
      flex-wrap:nowrap;
    }
    .game-info-wrapper:has(.game-info:only-child) .game-info {
      flex: 0 0 auto;
      max-width: none;
    }
    /* Multiple games: keep right-aligned, limit to 10 per row on desktop */
    .game-info-wrapper:not(:has(.game-info:only-child)) {
      width: 100%;
      justify-content: flex-end; /* Keep scoreboards aligned to the right */
    }
    .game-info-wrapper:not(:has(.game-info:only-child)) .game-info {
      flex: 0 0 calc((100% - 4.5rem) / 10); /* 10 items with 9 gaps of 0.5rem */
      max-width: calc((100% - 4.5rem) / 10);
    }
    /* Center items that wrap to second row (11th item onwards) */
    .game-info-wrapper:not(:has(.game-info:only-child)) .game-info:nth-child(n+11) {
      flex: 0 0 auto;
    }
    .game-info{display:flex;flex-direction:column;align-items:center;
      gap:.25rem;font-size:.9rem;border:1px solid var(--border);
      padding:.5rem;border-radius:6px;background:rgba(0,0,0,0.2);
      position:relative;overflow:hidden;
      width: 12ch; /* Fixed width: 12 characters (e.g., "LAC 13 - 99 LAR") */
      min-width: 12ch;
      max-width: 12ch;
    }
    /* Reduce scoreboard font size (web view only) */
    .game-info * {
      font-size: 0.8rem;
    }
    
    /* Show Scores toggle button */
    .show-scores-btn {
      position: absolute;
      bottom: 0.5rem;
      right: 0.5rem;
      background: rgba(20, 13, 82, 0.8);
      color: #fff;
      border: 1px solid rgba(255, 204, 0, 0.3);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      z-index: 10;
      transition: background 0.2s;
    }
    .show-scores-btn:hover {
      background: rgba(20, 13, 82, 1);
    }
    
    /* Scoreboard block - hidden by default */
    .scoreboard-block {
      display: none;
      width: 100%;
      margin-top: 1rem;
      padding: 0.75rem 0;
      border-top: 1px solid rgba(255, 204, 0, 0.2);
    }
    .scoreboard-block.active {
      display: block;
    }
    
    /* Scoreboard rows */
    .scoreboard-row {
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      flex-wrap: nowrap;
    }
    .scoreboard-row:last-child {
      margin-bottom: 0;
    }
    
    /* Second and subsequent rows centered */
    .scoreboard-row:not(:first-child) {
      justify-content: center;
    }
    /* NFL logo in scoreboards - positioned in background with low opacity */
    .nfl-logo-bg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1.5);
      width: 100%;
      height: 100%;
      opacity: 0.1;
      pointer-events: none;
      z-index: 0;
    }
    /* Larger zoom for 2-line scoreboards (FINAL games) */
    .game-info.two-line .nfl-logo-bg {
      transform: translate(-50%, -50%) scale(2.25);
    }
    /* Theme-aware NFL logo display */
    body:not(.light-mode) .nfl-logo-light {
      display: none;
    }
    body.light-mode .nfl-logo-dark {
      display: none;
    }
    /* Ensure scoreboard content is above logo */
    .game-info > div {
      position: relative;
      z-index: 1;
    }
    table{width:100%;border-collapse:separate;border-spacing:0;}
    th,td{padding:.375rem;border-bottom:1px solid var(--border);
      vertical-align:middle;text-align:left;}
    /* Double padding for Player column (column 1) - header and data */
    th:nth-child(1){padding-left:0.75rem !important;}
    td:nth-child(1){padding-left:0.75rem !important;}
    td { background: var(--surface); }
    th:first-child { border-top-left-radius: 10px; }
    th:last-child { border-top-right-radius: 10px; }
    /* Desktop body: Player column (3) - left aligned */
    td:nth-child(3){text-align:left !important;}
    /* Desktop body: Bet Type, Current, Target, Progress columns (4-7) - centered */
    td:nth-child(4),td:nth-child(5),td:nth-child(6),td:nth-child(7){text-align:center !important;}
    /* Desktop body: Status column (8) - centered */
    td:nth-child(8){text-align:center !important;}
    /* Headers: Player (th1) - left, Bet Type through Status (th2-6) - centered */
    thead th:nth-child(1){text-align:left !important;}
    thead th:nth-child(2),thead th:nth-child(3),thead th:nth-child(4),thead th:nth-child(5),thead th:nth-child(6){text-align:center !important;}
    tbody tr:last-child td { border-bottom: none; }
    /* Round table corners to match footer underneath */
    tbody tr:last-child td:first-child { border-bottom-left-radius: 10px; }
    tbody tr:last-child td:last-child { border-bottom-right-radius: 10px; }
    th{background:#2a2a2a;color:#fff;}
    
    /* Ensure table headers are white in light mode */
    body.light-mode th {
      color: #fff !important;
    }
    .progress-bar{background:var(--progress-bg);border-radius:13px;position:relative;height:1.5rem;border:2px solid var(--outline-blue);padding:3px;}
    .progress-bar.pct-vlow { border-color: #f44336; }  /* Red */
    .progress-bar.pct-low { border-color: #ff9800; }   /* Orange */
    .progress-bar.pct-mid { border-color: #ffeb3b; }   /* Yellow */
    .progress-bar.pct-full { border-color: #4caf50; }  /* Green */
    .progress{height:100%;transition:width .5s ease-in-out;border-radius:8px;}
    .progress-text{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;}
    .progress.pct-vlow{background:linear-gradient(to right, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 1));}
    .progress.pct-low{background:linear-gradient(to right, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 1));}
    .progress.pct-mid{background:linear-gradient(to right, rgba(255, 235, 59, 0.2), rgba(255, 235, 59, 1));}
    .progress.pct-full{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));}
    /* Reverse colors for UNDER bets (0-60% green, 60-80% yellow, 80-99% orange, 100% red) */
    .progress.pct-under-vlow{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));} /* Green */
    .progress.pct-under-low{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));} /* Green */
    .progress.pct-under-mid{background:linear-gradient(to right, rgba(255, 235, 59, 0.2), rgba(255, 235, 59, 1));} /* Yellow */
    .progress.pct-under-high{background:linear-gradient(to right, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 1));} /* Orange */
    .progress.pct-under-full{background:linear-gradient(to right, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 1));} /* Red */
    .progress-bar.pct-under-vlow { border-color: #4caf50; }  /* Green */
    .progress-bar.pct-under-low { border-color: #4caf50; }   /* Green */
    .progress-bar.pct-under-mid { border-color: #ffeb3b; }   /* Yellow */
    .progress-bar.pct-under-high { border-color: #ff9800; }  /* Orange */
    .progress-bar.pct-under-full { border-color: #f44336; }  /* Red */
    .badge{display:inline-block;font-size:.75rem;font-weight:bold;
      margin-bottom:.25rem;padding:2px 6px;border-radius:4px;}
    .status-pregame{background:var(--pregame);color:#ffffff;}
    .status-live{background:var(--error);color:#ffffff;}
    .status-halftime{background:transparent;color:#ffffff;border:1px solid #ffffff;}
    .status-final{background:#808080;color:#ffffff;}
    
    /* Mobile-specific layout classes (hidden on desktop) */
    .mobile-line-1,
    .mobile-line-2,
    .mobile-line-2-header {
      display: none;
    }
    
    /* Hide mobile cells 1-2 on desktop */
    table tbody tr td:nth-child(1),
    table tbody tr td:nth-child(2) {
      display: none;
    }
    
    .mobile-line-1 {
      justify-content: space-between;
      align-items: flex-start; /* Changed from center to flex-start for consistent top alignment */
      font-weight: 500;
    }
    
    .mobile-line-2-header {
      display: grid;
      grid-template-columns: 3.75rem 1fr 3.75rem;
      gap: 0.25rem;
      align-items: end;
      font-size: 0.45rem;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 0.125rem;
    }
    
    .mobile-line-2-header span:first-child {
      text-align: left;
    }
    
    .mobile-line-2-header span:nth-child(2) {
      text-align: center;
    }
    
    .mobile-line-2-header span:last-child {
      text-align: right;
    }
    
    .mobile-line-2 {
      grid-template-columns: 3.75rem 1fr 3.75rem;
      gap: 0.25rem;
      align-items: center;
    }
    
    .mobile-line-2 span:first-child {
      text-align: left;
      max-width: 3.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .mobile-line-2 span:nth-child(2) {
      text-align: center;
    }
    
    .mobile-line-2 span:last-child {
      text-align: right;
      max-width: 3.75rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 0;
        /* iOS safe area insets for notch/Dynamic Island on mobile */
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        zoom: 1; /* Reset zoom on mobile for better readability */
      }
      
      .container {
        padding: 0.5rem;
        border-radius: 0;
      }
      
      h1 {
        font-size: 1.5rem;
        padding: 0 0.5rem;
      }
      
      /* Mobile toolbar adjustments */
      .toolbar {
        gap: 0.2rem; /* Reduced gap by 80% from 1rem */
        margin: 0.5rem 0;
      }
      
      .toolbar-button {
        font-size: 0.85rem;
        padding: 0.5rem 1rem;
      }
      
      .search-input {
        width: 100%;
        font-size: 0.85rem;
      }
      
      .parlay-section {
        padding: 1rem 0.5rem;
        overflow-x: hidden; /* Prevent horizontal scroll */
        margin: 0.5625rem 0; /* Reduced by 50% from 1.125rem to match tighter spacing */
        border-radius: 8px;
        border-color: rgba(204, 204, 204, 0.5);
      }
      
      .parlay-header {
        margin: -1rem -0.5rem 0.40rem -0.5rem; /* Bottom margin increased from 0.25rem to 0.40rem */
        padding: 0.5625rem 0.5rem; /* Reduced by 25% from 0.75rem */
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.375rem; /* Reduced by 25% from 0.5rem */
        align-items: flex-start;
        justify-content: space-between;
      }
      
      .parlay-title {
        flex: 1;
        min-width: 0;
        font-size: 0.9rem; /* Reduced by 1 font size for mobile */
      }
      
      .parlay-date {
        font-size: 0.7rem !important; /* Match footer font size on mobile */
      }
      
      .parlay-footer {
        margin: 0.40rem -0.5rem -1rem -0.5rem; /* Top margin increased from 0.25rem to 0.40rem */
        padding: 0.3375rem 0.5rem; /* Reduced by 10% from 0.375rem to 0.3375rem */
        font-size: 0.7rem;
      }
      
      /* Reduce line spacing in footer for mobile - halved again */
      .footer-left, .footer-right {
        gap: 0.05rem; /* Reduced by 50% from 0.1rem for even tighter line spacing */
      }
      
      /* Adjust trophy icon for mobile */
      .trophy-icon {
        opacity: 0.25;
      }

      /* Mobile scoreboard styling */
      .game-info {
        width: auto; /* Override fixed width on mobile */
        min-width: auto;
        max-width: none;
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        gap: 0.15rem;
      }
      
      /* Show Scores button smaller on mobile */
      .show-scores-btn {
        font-size: 0.6rem;
        padding: 0.2rem 0.4rem;
        bottom: 0.35rem;
        right: 0.35rem;
      }
      
      /* Scoreboard block - 3 per row on mobile */
      .scoreboard-row {
        flex-wrap: wrap;
        justify-content: space-evenly;
      }
      
      .scoreboard-row .game-info {
        flex: 0 0 calc(33.333% - 0.35rem); /* 3 per row */
        max-width: calc(33.333% - 0.35rem);
      }
      
      /* Multiple games: center items that wrap to second row (4th item onwards) */
      .game-info-wrapper:not(:has(.game-info:only-child)) .game-info:nth-child(n+4) {
        margin: 0 auto;
      }
      
      .game-info {
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        gap: 0.15rem;
      }
      
      .game-info .badge {
        font-size: 0.6rem;
        padding: 1px 4px;
      }

      /* Mobile: Stack bet legs vertically with compact layout */
      table {
        display: block;
      }
      
      thead {
        display: none; /* Hide table headers on mobile */
      }
      
      tbody {
        display: block;
      }
      
      tr {
        display: block;
        margin-bottom: 0.40rem; /* Increased from 0.25rem to 0.40rem */
        padding: 0.40rem; /* Increased from 0.3rem to 0.40rem for side padding */
        background: var(--surface);
        border-radius: 8px;
        border: 1px solid rgba(255, 204, 0, 0.2);
      }
      
      /* Remove negative margins since header/footer margins now handle gaps */
      tr:first-child {
        margin-top: 0; /* Changed from -0.25rem to allow header margin to work */
      }
      
      /* Remove negative margins since header/footer margins now handle gaps */
      tr:last-child {
        margin-bottom: 0.40rem; /* Increased from 0.25rem to 0.40rem */
      }
      
      td {
        display: block;
        padding: 0.1rem 0; /* Reduced from 0.15rem to further compact */
        border: none;
        background: transparent;
        text-align: left !important;
      }
      
      /* Remove desktop padding override for mobile - keep consistent padding */
      td:nth-child(1) {
        padding-left: 0 !important;
      }
      
      /* Hide desktop columns 3-8 (individual cells) */
      tr td:nth-child(n+3) {
        display: none !important;
      }
      
      /* Show mobile columns 1-2 */
      tr td:nth-child(1),
      tr td:nth-child(2) {
        display: block !important;
      }
      
      /* Make mobile-specific content visible */
      .mobile-line-1 {
        display: flex !important;
        font-size: 0.9rem;
      }
      
      .mobile-line-2-header {
        display: grid !important;
        font-size: 0.45rem;
      }
      
      .mobile-line-2 {
        display: grid !important;
        font-size: 0.85rem;
      }
      
      /* Line 1 styling */
      tr td:nth-child(1) {
        margin-bottom: 0.25rem; /* Reduced by 50% from 0.5rem */
      }

      .progress-bar {
        height: 2.5rem;
      }
      
      .progress-bar .progress-text {
        font-size: 0.75rem;
      }
      
      .tabs {
        gap: 0.5rem;
        padding: 0 0.5rem;
      }
      
      .tab {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      #refresh-button,
      #move-completed-button {
        margin-left: 0.5rem !important;
      }
      
      #status-message {
        margin: 0.5rem 0.5rem 1.5rem 0.5rem; /* Increased bottom margin for mobile */
      }
      
      /* Mobile: Toolbar layout - buttons on one line, search below */
      .toolbar {
        flex-direction: column;
        padding: 0 0.5rem;
        gap: 0.5rem;
        align-items: stretch;
      }
      
      .toolbar-controls {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        width: 100%;
      }
      
      .toolbar-search {
        width: 100%;
      }
      
      /* Mobile: Make search bar full width */
      .search-input {
        width: 100% !important;
        max-width: none !important;
      }
    }
    
    /* Extra small screens */
    @media (max-width: 480px) {
      h1 {
        font-size: 1.25rem;
      }
      
      .progress-bar {
        height: 1rem;
        font-size: 0.65rem;
      }
      
      .button-container {
        justify-content: center;
        padding: 0 1rem;
      }
      
      #refresh-button, .filter-button {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <!-- Theme Toggle -->
  <button class="theme-toggle" id="theme-toggle" title="Toggle Light/Dark Mode">🌙</button>
  
  <!-- Pull to Refresh Indicator -->
  <div class="pull-refresh" id="pull-refresh">Release to refresh...</div>
  
  <div class="container">
    <h1>Parlay & Wager Tracker</h1>
    <div class="tabs">
      <button class="tab active" data-tab="current">Live Bets</button>
      <button class="tab" data-tab="historical">Historical Bets</button>
    </div>
    <div class="button-container">
      <button id="refresh-button">Refresh Stats</button>
      <button id="clear-cache-button" style="display: none;">Clear Cache 🗑️</button>
    </div>
    <div id="status-message"></div>
    
    <!-- New Toolbar -->
    <div class="toolbar">
      <div class="toolbar-controls">
        <div style="position: relative;">
          <button class="toolbar-button" id="filter-dropdown-btn">Filter ▼</button>
          <div class="collapse-menu" id="filter-main-menu">
            <button class="collapse-option" data-category="status">Status</button>
            <button class="collapse-option" data-category="site">Betting Site</button>
            <button class="collapse-option" data-category="sport">Sport</button>
            <button class="collapse-option" data-category="last30">Last 30 Days</button>
            <button class="collapse-option" id="clear-all-filters">Clear All</button>
          </div>
          
          <!-- Filter Sub-Panel -->
          <div class="filter-sub-panel" id="filter-sub-panel">
            <div class="filter-panel-header">
              <button class="filter-panel-back" id="back-to-filters">←</button>
              <span id="sub-panel-title">Filter Options</span>
              <button class="filter-panel-close" id="close-sub-panel">×</button>
            </div>
            <div class="filter-panel-content" id="sub-panel-content"></div>
          </div>
        </div>
        
        <div style="position: relative;">
          <button class="toolbar-button" id="collapse-dropdown-btn">Collapse ▼</button>
          <div class="collapse-menu" id="collapse-menu">
            <button class="collapse-option" id="collapse-all">All</button>
            <button class="collapse-option" id="uncollapse-all">None</button>
          </div>
        </div>
      </div>
      
      <div class="toolbar-search">
        <input type="text" class="search-input" id="search-input" placeholder="Search bets...">
      </div>
    </div>
    
    <div id="cache-info" style="text-align: center; margin-bottom: 1rem; color: #888; font-size: 0.85rem; display: none;"></div>
    <div id="parlay-sections" class="tab-content active" data-tab="current"></div>
    <div id="historical-sections" class="tab-content" data-tab="historical" style="display:none"></div>
    <div style="text-align: right; margin-top: 2rem;">
      <button id="move-completed-button">Move Completed to History</button>
    </div>
  </div>
  <script>
    // Scroll detection for button opacity
    let scrollTimer;
    window.addEventListener('scroll', () => {
      document.body.classList.add('scrolling');
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        document.body.classList.remove('scrolling');
      }, 1000);
    });
    
    // Helper to read query params
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // API base precedence: ?api=... (query param) -> window.API_BASE -> default Render backend
    const urlApi = getQueryParam('api');
    const API_BASE = (urlApi ? urlApi.replace(/\/$/, '') : (window.API_BASE && window.API_BASE.replace(/\/$/, ''))) || 'https://parlay-tracker-backend.onrender.com';
    const btn=document.getElementById('refresh-button'),
      sec=document.getElementById('parlay-sections'),
      histSec=document.getElementById('historical-sections'),
      msg=document.getElementById('status-message'),
      statsUrl = `${API_BASE}/stats`,
      liveUrl = `${API_BASE}/live`,
      histUrl = `${API_BASE}/historical`;
    
    // Client-side cache for faster tab switching
    let cachedLive = null;
    let cachedHistorical = null;
    
    // === HISTORICAL BETS CACHE SYSTEM ===
    const HISTORICAL_CACHE_KEY = 'parlay_tracker_historical_cache';
    const HISTORICAL_CACHE_META_KEY = 'parlay_tracker_historical_cache_meta';
    
    function saveHistoricalCache(data) {
      try {
        const cacheData = {
          timestamp: new Date().toISOString(),
          betCount: data.length,
          data: data
        };
        localStorage.setItem(HISTORICAL_CACHE_KEY, JSON.stringify(cacheData));
        localStorage.setItem(HISTORICAL_CACHE_META_KEY, JSON.stringify({
          timestamp: cacheData.timestamp,
          betCount: cacheData.betCount
        }));
        console.log('✅ Historical cache saved:', cacheData.betCount, 'bets');
      } catch (e) {
        console.warn('Failed to save historical cache:', e);
      }
    }
    
    function loadHistoricalCache() {
      try {
        const cached = localStorage.getItem(HISTORICAL_CACHE_KEY);
        if (!cached) return null;
        
        const cacheData = JSON.parse(cached);
        console.log('📦 Historical cache loaded:', cacheData.betCount, 'bets from', new Date(cacheData.timestamp).toLocaleString());
        return cacheData.data;
      } catch (e) {
        console.warn('Failed to load historical cache:', e);
        return null;
      }
    }
    
    function clearHistoricalCache() {
      localStorage.removeItem(HISTORICAL_CACHE_KEY);
      localStorage.removeItem(HISTORICAL_CACHE_META_KEY);
      console.log('🗑️ Historical cache cleared');
    }
    
    function getHistoricalCacheMeta() {
      try {
        const meta = localStorage.getItem(HISTORICAL_CACHE_META_KEY);
        return meta ? JSON.parse(meta) : null;
      } catch (e) {
        return null;
      }
    }
    
    // === 1. THEME TOGGLE ===
    const themeToggle = document.getElementById('theme-toggle');
    const savedTheme = localStorage.getItem('theme') || 'dark';
    if (savedTheme === 'light') {
      document.body.classList.add('light-mode');
      themeToggle.textContent = '☀️';
    }
    
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      const isLight = document.body.classList.contains('light-mode');
      themeToggle.textContent = isLight ? '☀️' : '🌙';
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      
      // Update all footer logos to match new theme
      const logoSuffix = isLight ? '2' : '1'; // 1=white (dark mode), 2=colored (light mode)
      document.querySelectorAll('.footer-logo').forEach(logo => {
        const currentSrc = logo.src;
        const newSrc = currentSrc.replace(/logo-[12]\.svg$/, `logo-${logoSuffix}.svg`);
        logo.src = newSrc;
      });
    });
    
    // === 2. NEW FILTER, COLLAPSE, AND SEARCH FUNCTIONALITY ===
    let activeFilters = {
      status: new Set(),
      site: new Set(),
      sport: new Set(),
      last30Days: false
    };
    let searchQuery = '';
    
    // Filter dropdown menu toggle
    const filterDropdownBtn = document.getElementById('filter-dropdown-btn');
    const filterMainMenu = document.getElementById('filter-main-menu');
    const filterSubPanel = document.getElementById('filter-sub-panel');
    const subPanelTitle = document.getElementById('sub-panel-title');
    const subPanelContent = document.getElementById('sub-panel-content');
    const closeSubPanel = document.getElementById('close-sub-panel');
    
    filterDropdownBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close collapse menu if open
      collapseMenu.classList.remove('active');
      filterMainMenu.classList.toggle('active');
    });
    
    document.addEventListener('click', () => {
      filterMainMenu.classList.remove('active');
    });
    
    filterMainMenu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    // Filter category click handlers
    document.querySelectorAll('.collapse-option[data-category]').forEach(option => {
      option.addEventListener('click', () => {
        const category = option.dataset.category;
        filterMainMenu.classList.remove('active');
        
        if (category === 'last30') {
          // Toggle last 30 days filter
          activeFilters.last30Days = !activeFilters.last30Days;
          option.textContent = activeFilters.last30Days ? 'Last 30 Days ✓' : 'Last 30 Days';
          applyAllFilters();
        } else {
          // Open sub-panel for multi-select filters
          openFilterSubPanel(category);
        }
      });
    });
    
    function openFilterSubPanel(category) {
      let title = '';
      let options = [];
      
      if (category === 'status') {
        title = 'Status'; // Shortened from 'Filter by Status'
        options = ['Winning', 'Live', 'Losing', 'Not Started'];
      } else if (category === 'site') {
        title = 'Betting Site'; // Shortened from 'Filter by Betting Site'
        // Get unique betting sites from all visible parlays
        const sites = new Set();
        document.querySelectorAll('.parlay-section').forEach(section => {
          const site = section.dataset.site;
          if (site) sites.add(site);
        });
        options = Array.from(sites).sort();
      } else if (category === 'sport') {
        title = 'Sport'; // Shortened from 'Filter by Sport'
        options = ['NFL', 'NBA'];
      }
      
      subPanelTitle.textContent = title;
      subPanelContent.innerHTML = '';
      
      options.forEach(opt => {
        const item = document.createElement('div');
        item.className = 'filter-option-item';
        if (activeFilters[category].has(opt)) {
          item.classList.add('selected');
        }
        item.innerHTML = `<span>${opt}</span><span>${activeFilters[category].has(opt) ? '✓' : ''}</span>`;
        item.addEventListener('click', () => {
          if (activeFilters[category].has(opt)) {
            activeFilters[category].delete(opt);
            item.classList.remove('selected');
            item.querySelector('span:last-child').textContent = '';
          } else {
            activeFilters[category].add(opt);
            item.classList.add('selected');
            item.querySelector('span:last-child').textContent = '✓';
          }
          applyAllFilters();
        });
        subPanelContent.appendChild(item);
      });
      
      filterSubPanel.classList.add('active');
    }
    
    closeSubPanel.addEventListener('click', () => {
      filterSubPanel.classList.remove('active');
    });
    
    // Back button to return to main filter menu
    const backToFiltersBtn = document.getElementById('back-to-filters');
    backToFiltersBtn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent event bubbling
      filterSubPanel.classList.remove('active');
      filterMainMenu.classList.add('active');
    });
    
    // Close sub-panel when clicking outside
    document.addEventListener('click', (e) => {
      if (!filterSubPanel.contains(e.target) && 
          !filterDropdownBtn.contains(e.target) &&
          !filterMainMenu.contains(e.target)) {
        filterSubPanel.classList.remove('active');
      }
    });
    
    // Collapse functionality
    const collapseDropdownBtn = document.getElementById('collapse-dropdown-btn');
    const collapseMenu = document.getElementById('collapse-menu');
    const collapseAllBtn = document.getElementById('collapse-all');
    const uncollapseAllBtn = document.getElementById('uncollapse-all');
    
    collapseDropdownBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close filter menu and sub-panel if open
      filterMainMenu.classList.remove('active');
      filterSubPanel.classList.remove('active');
      collapseMenu.classList.toggle('active');
    });
    
    document.addEventListener('click', () => {
      collapseMenu.classList.remove('active');
    });
    
    collapseMenu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    collapseAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.parlay-section').forEach(section => {
        if (section.style.display !== 'none') {
          if (!section.classList.contains('collapsed')) {
            section.classList.add('collapsed');
          }
        }
      });
      collapseMenu.classList.remove('active');
    });
    
    uncollapseAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.parlay-section').forEach(section => {
        if (section.style.display !== 'none') {
          if (section.classList.contains('collapsed')) {
            section.classList.remove('collapsed');
          }
        }
      });
      collapseMenu.classList.remove('active');
    });
    
    // Clear All Filters button
    const clearAllFiltersBtn = document.getElementById('clear-all-filters');
    clearAllFiltersBtn.addEventListener('click', () => {
      // Clear all filter sets
      activeFilters.status.clear();
      activeFilters.site.clear();
      activeFilters.sport.clear();
      activeFilters.last30Days = false;
      
      // Reset "Last 30 Days" button text
      document.querySelector('.collapse-option[data-category="last30"]').textContent = 'Last 30 Days';
      
      // Apply filters to show all bets
      applyAllFilters();
      
      // Close menu
      filterMainMenu.classList.remove('active');
    });
    
    // Search functionality
    const searchInput = document.getElementById('search-input');
    searchInput.addEventListener('input', (e) => {
      searchQuery = e.target.value.toLowerCase().trim();
      applyAllFilters();
    });
    
    function applyAllFilters() {
      document.querySelectorAll('.parlay-section').forEach(section => {
        let shouldShow = true;
        
        // Get parlay data
        const site = section.dataset.site || '';
        const sport = section.dataset.sport || '';
        const betDate = section.dataset.betDate || '';
        const legs = section.querySelectorAll('tbody tr');
        
        // Status filter
        if (activeFilters.status.size > 0) {
          let statusMatch = false;
          
          if (activeFilters.status.has('Winning')) {
            const hasHit = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Hit');
            });
            const hasMiss = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Miss');
            });
            const allHitOrNotStarted = Array.from(legs).every(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && (status.includes('Hit') || status.includes('Not Started'));
            });
            if (hasHit && !hasMiss && allHitOrNotStarted) statusMatch = true;
          }
          
          if (activeFilters.status.has('Live')) {
            const hasLive = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('In Progress');
            });
            if (hasLive) statusMatch = true;
          }
          
          if (activeFilters.status.has('Losing')) {
            const hasMiss = Array.from(legs).some(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Miss');
            });
            if (hasMiss) statusMatch = true;
          }
          
          if (activeFilters.status.has('Not Started')) {
            const allNotStarted = Array.from(legs).every(leg => {
              const status = leg.querySelector('td:nth-child(8)')?.textContent;
              return status && status.includes('Not Started');
            });
            if (allNotStarted) statusMatch = true;
          }
          
          shouldShow = shouldShow && statusMatch;
        }
        
        // Betting site filter
        if (activeFilters.site.size > 0) {
          shouldShow = shouldShow && activeFilters.site.has(site);
        }
        
        // Sport filter
        if (activeFilters.sport.size > 0) {
          shouldShow = shouldShow && activeFilters.sport.has(sport);
        }
        
        // Last 30 days filter
        if (activeFilters.last30Days && betDate) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          const betDateObj = new Date(betDate);
          shouldShow = shouldShow && betDateObj >= thirtyDaysAgo;
        }
        
        // Search filter
        if (searchQuery) {
          const searchableText = section.textContent.toLowerCase();
          shouldShow = shouldShow && searchableText.includes(searchQuery);
        }
        
        section.style.display = shouldShow ? 'block' : 'none';
      });
    }
    
    // === 3. PULL TO REFRESH ===
    let startY = 0;
    let isPulling = false;
    const pullRefresh = document.getElementById('pull-refresh');
    
    document.addEventListener('touchstart', (e) => {
      if (window.scrollY === 0) {
        startY = e.touches[0].pageY;
        isPulling = true;
      }
    });
    
    document.addEventListener('touchmove', (e) => {
      if (!isPulling) return;
      const currentY = e.touches[0].pageY;
      const diff = currentY - startY;
      
      if (diff > 80) {
        pullRefresh.classList.add('active');
        pullRefresh.textContent = 'Release to refresh...';
      }
    });
    
    document.addEventListener('touchend', async (e) => {
      if (!isPulling) return;
      isPulling = false;
      
      if (pullRefresh.classList.contains('active')) {
        pullRefresh.textContent = 'Refreshing...';
        await update();
        setTimeout(() => {
          pullRefresh.classList.remove('active');
        }, 1000);
      }
    });

    // Tab handling
    const clearCacheBtn = document.getElementById('clear-cache-button');
    const cacheInfo = document.getElementById('cache-info');
    
    function updateCacheDisplay() {
      const activeTab = document.querySelector('.tab.active').dataset.tab;
      if (activeTab === 'historical') {
        const meta = getHistoricalCacheMeta();
        if (meta) {
          clearCacheBtn.style.display = 'inline-block';
          cacheInfo.style.display = 'block';
          cacheInfo.textContent = `📦 Using cached data (${meta.betCount} bets) from ${new Date(meta.timestamp).toLocaleString()}`;
        } else {
          clearCacheBtn.style.display = 'none';
          cacheInfo.style.display = 'none';
        }
      } else {
        clearCacheBtn.style.display = 'none';
        cacheInfo.style.display = 'none';
      }
    }
    
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', async () => {
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show/hide content
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(content => {
          if (content.dataset.tab === tabName) {
            content.style.display = 'block';
          } else {
            content.style.display = 'none';
          }
        });
        
        // Update cache display
        updateCacheDisplay();
        
        // Refresh data when switching tabs
        await update();
      });
    });
    
    // Clear Cache button handler
    clearCacheBtn.addEventListener('click', async () => {
      if (confirm('Clear cached historical data? This will re-fetch all historical bets from the server.')) {
        clearHistoricalCache();
        cachedHistorical = null;
        msg.textContent = 'Cache cleared. Refreshing...';
        updateCacheDisplay();
        await update();
      }
    });

    // --- Admin Token Modal/Login UI ---
function showTokenModal() {
  let modal = document.getElementById('token-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'token-modal';
    modal.style = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:9999;';
    modal.innerHTML = `
      <div style="background:#222;padding:2rem 2.5rem;border-radius:12px;box-shadow:0 2px 16px #000;display:flex;flex-direction:column;align-items:center;min-width:300px;">
        <h2 style='color:#e657ff;margin-bottom:1rem;'>Enter Admin Token</h2>
        <input id='token-input' type='password' placeholder='Admin Token' style='padding:0.5rem 1rem;font-size:1.1rem;border-radius:6px;border:1px solid #888;width:100%;margin-bottom:1rem;'>
        <button id='token-submit' style='padding:0.5rem 1.5rem;background:#140d52;color:#fff;border:none;border-radius:6px;font-weight:bold;cursor:pointer;'>Login</button>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('token-submit').onclick = function() {
      const val = document.getElementById('token-input').value.trim();
      if (val) {
        localStorage.setItem('admin_token', val);
        modal.remove();
        location.reload();
      }
    };
    document.getElementById('token-input').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') document.getElementById('token-submit').click();
    });
  }
}

function getAdminToken() {
  let token = localStorage.getItem('admin_token');
  if (!token) {
    showTokenModal();
    throw new Error('No admin token set');
  }
  return token;
}

function logoutToken() {
  localStorage.removeItem('admin_token');
  location.reload();
}

// Add a logout button to the UI
(function addLogoutButton(){
  const btn = document.createElement('button');
  btn.textContent = 'Logout';
  btn.className = 'logout-btn';
  btn.style = 'position:fixed;top:1rem;right:1rem;z-index:1000;background:#f44336;color:#fff;padding:0.5rem 1.2rem;border:none;border-radius:8px;font-weight:bold;cursor:pointer;transition:opacity 0.3s;';
  btn.onclick = logoutToken;
  document.body.appendChild(btn);
})();

    function fetchWithAdminToken(url, options = {}) {
      let token;
      try {
        token = getAdminToken();
      } catch (e) {
        // If no token, the modal will be shown and error thrown
        // Return a rejected promise so the caller can handle it
        return Promise.reject(e);
      }
      options.headers = options.headers || {};
      options.headers['X-Admin-Token'] = token;
      return fetch(url, options);
    }

    // Prefetch historical data in the background so it appears instantly on switch
    (async function prefetchHistorical(){
      try{
        const r = await fetchWithAdminToken(histUrl);
        if(r.ok){ cachedHistorical = await r.json(); console.log('Prefetched historical:', cachedHistorical); }
      }catch(e){ console.warn('Prefetch historical failed', e); }
    })();

    function fmtType(stat, stat_add = null){
      const m={'passing_yards':'Pass Yds','passing_yards_alt':'Alt Pass Yds','receiving_yards':'Rec Yds','receiving_yards_alt':'Alt Rec Yds','rushing_yards':'Rush Yds','rushing_yards_alt':'Alt Rush Yds','rushing_receiving_yards':'Rush + Rec Yds','passing_rushing_yards':'Pass + Rush Yds','anytime_touchdown':'Anytime TD','anytime_td_scorer':'Anytime TD','passing_touchdowns':'Pass TDs','rushing_touchdowns':'Rush TDs','receptions':'Receptions','receptions_alt':'Alt Receptions','longest_reception':'Longest Rec','moneyline':'Moneyline','spread':'Spread','total_points':'Total Points','total_points_under':'Total Points Under','total_points_over':'Total Points Over','interceptions_thrown':'INTs Thrown'};
      const baseName = m[stat]||stat.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase());
      
      // Only add (U) suffix for under bets, over is default/implied
      if (stat_add === 'under') {
        return baseName + ' (U)';
      }
      
      return baseName;
    }
    function getQuarter(p){return p===1?'1st Q':p===2?'2nd Q':p===3?'3rd Q':p===4?'4th Q':'OT';}

    // Get 3-letter team abbreviation from full team name
    function getTeamAbbr(teamName) {
      const abbrevMap = {
        'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
        'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
        'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
        'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
        'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
        'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
        'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
        'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
        'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
        'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
        'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
      };
      return abbrevMap[teamName] || teamName.substring(0, 3).toUpperCase();
    }

    // Format stat value for mobile display
    function formatStatForMobile(value, stat) {
      if (stat === 'moneyline') return value;
      if (stat === 'spread') return value;
      
      // For numeric stats, add unit abbreviations
      if (stat.includes('yards')) return `${value} Yds`;
      if (stat.includes('touchdown')) return `${value} TDs`;
      if (stat.includes('receptions')) return `${value} Rec`;
      if (stat.includes('passing')) return `${value} Pass`;
      if (stat.includes('rushing')) return `${value} Rush`;
      
      return value;
    }

    // Calculate countdown to game start
    function getCountdown(startDateTime) {
      if (!startDateTime) return '';
      
      const now = new Date();
      const gameStart = new Date(startDateTime);
      const diffMs = gameStart - now;
      
      if (diffMs <= 0) return 'Starting soon';
      
      const totalHours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      // If less than 24 hours, show hours and minutes
      if (totalHours < 24) {
        return `Starts in ${totalHours}h ${minutes}m`;
      }
      
      // If 24 hours or more, show days and hours (no minutes)
      const days = Math.floor(totalHours / 24);
      const hours = totalHours % 24;
      return `Starts in ${days}d ${hours}h`;
    }

    function enhanceParlayName(parlay) {
      // If parlay doesn't have legs, return original name
      if (!parlay.legs || parlay.legs.length === 0) {
        return parlay.name;
      }

      // Get unique teams from all legs
      const allTeams = new Set();
      parlay.legs.forEach(leg => {
        if (leg.away) allTeams.add(leg.away);
        if (leg.home) allTeams.add(leg.home);
      });

      // Only proceed if exactly 2 teams are involved
      if (allTeams.size !== 2) {
        return parlay.name;
      }

      // Get away and home teams from the first leg
      const away = parlay.legs[0].away;
      const home = parlay.legs[0].home;

      // Convert full team names to abbreviations
      const teamAbbrevMap = {
        'Atlanta Falcons': 'Falcons', 'Buffalo Bills': 'Bills', 'Carolina Panthers': 'Panthers',
        'Chicago Bears': 'Bears', 'Cincinnati Bengals': 'Bengals', 'Cleveland Browns': 'Browns',
        'Dallas Cowboys': 'Cowboys', 'Denver Broncos': 'Broncos', 'Detroit Lions': 'Lions',
        'Green Bay Packers': 'Packers', 'Houston Texans': 'Texans', 'Indianapolis Colts': 'Colts',
        'Jacksonville Jaguars': 'Jaguars', 'Kansas City Chiefs': 'Chiefs', 'Las Vegas Raiders': 'Raiders',
        'Los Angeles Chargers': 'Chargers', 'Los Angeles Rams': 'Rams', 'Miami Dolphins': 'Dolphins',
        'Minnesota Vikings': 'Vikings', 'New England Patriots': 'Patriots', 'New Orleans Saints': 'Saints',
        'New York Giants': 'Giants', 'New York Jets': 'Jets', 'Philadelphia Eagles': 'Eagles',
        'Pittsburgh Steelers': 'Steelers', 'San Francisco 49ers': '49ers', 'Seattle Seahawks': 'Seahawks',
        'Tampa Bay Buccaneers': 'Buccaneers', 'Tennessee Titans': 'Titans', 'Washington Commanders': 'Commanders',
        'Arizona Cardinals': 'Cardinals', 'Baltimore Ravens': 'Ravens'
      };

      const awayAbbrev = teamAbbrevMap[away] || away;
      const homeAbbrev = teamAbbrevMap[home] || home;
      const matchup = `${awayAbbrev} @ ${homeAbbrev}`;

      // Check if the matchup or team names are already in the parlay name
      const nameContainsMatchup = parlay.name.includes('@') || 
                                   parlay.name.includes(awayAbbrev) || 
                                   parlay.name.includes(homeAbbrev) ||
                                   parlay.name.includes(away) ||
                                   parlay.name.includes(home);

      // If matchup info not already in name, append it
      if (!nameContainsMatchup) {
        return `${parlay.name} - ${matchup}`;
      }

      return parlay.name;
    }

    // Player position mapping
    const playerPositions = {
      // Quarterbacks
      "Patrick Mahomes": "QB", "Jayden Daniels": "QB", "Josh Allen": "QB", "Lamar Jackson": "QB",
      "Baker Mayfield": "QB", "Geno Smith": "QB", "Sam Darnold": "QB", "Kyler Murray": "QB",
      "Jared Goff": "QB", "Matthew Stafford": "QB", "Justin Herbert": "QB", "Joe Burrow": "QB",
      "Jalen Hurts": "QB", "Dak Prescott": "QB", "Bo Nix": "QB", "Jordan Love": "QB",
      "Mac Jones": "QB", "Caleb Williams": "QB", "Drake Maye": "QB", "Aaron Rodgers": "QB",
      "Trevor Lawrence": "QB", "Russell Wilson": "QB", "Daniel Jones": "QB", "Joe Flacco": "QB",
      "Spencer Rattler": "QB", "Michael Penix Jr.": "QB", "Marcus Mariota": "QB", "Carson Wentz": "QB",
      "J.J. McCarthy": "QB", "Dillon Gabriel": "QB", "Tua Tagovailoa": "QB",
      // Running Backs
      "Isiah Pacheco": "RB", "Saquon Barkley": "RB", "Christian McCaffrey": "RB", "Derrick Henry": "RB",
      "De'Von Achane": "RB",
      "Jordan Mason": "RB", "Kenneth Walker III": "RB", "Bucky Irving": "RB", "Bijan Robinson": "RB",
      "Aaron Jones": "RB", "D'Andre Swift": "RB", "Kyren Williams": "RB", "Javonte Williams": "RB",
      "Jonathan Taylor": "RB", "David Montgomery": "RB", "Jahmyr Gibbs": "RB", "James Cook": "RB",
      "Travis Etienne": "RB", "Trey Benson": "RB", "Zach Charbonnet": "RB", "Omarion Hampton": "RB",
      "Tyler Allgeier": "RB", "Roschon Johnson": "RB", "Jaylen Warren": "RB", "Rhamondre Stevenson": "RB",
      "Rico Dowdle": "RB", "Jacory Croskey-Merritt": "RB", "Brashard Smith": "RB",
      // Wide Receivers
      "Rashee Rice": "WR", "Terry McLaurin": "WR", "Xavier Worthy": "WR", "Marquise Brown": "WR",
      "Deebo Samuel": "WR", "CeeDee Lamb": "WR", "George Pickens": "WR", "A.J. Brown": "WR",
      "DeVonta Smith": "WR", "Devonta Smith": "WR", "Malik Nabers": "WR", "Zay Flowers": "WR",
      "Khalil Shakir": "WR", "Justin Jefferson": "WR", "D.J. Moore": "WR", "Jakobi Meyers": "WR",
      "Keenan Allen": "WR", "Amon-Ra St. Brown": "WR", "Jaxon Smith-Njigba": "WR", 
      "Marvin Harrison Jr.": "WR", "Michael Wilson": "WR", "Puka Nacua": "WR", "Cooper Kupp": "WR",
      "Davante Adams": "WR", "Michael Pittman Jr.": "WR", "Stefon Diggs": "WR", "Dyami Brown": "WR",
      "Drake London": "WR", "Ja'Marr Chase": "WR", "DK Metcalf": "WR", "Rome Odunze": "WR",
      "Jordan Addison": "WR", "Ladd McConkey": "WR", "Matthew Golden": "WR", "Quentin Johnston": "WR",
      "Emeka Egbuka": "WR", "Travis Hunter": "WR", "Malik Washington": "WR",
      // Tight Ends
      "Travis Kelce": "TE", "Dalton Kincaid": "TE", "Mark Andrews": "TE", "T.J. Hockenson": "TE",
      "Tucker Kraft": "TE", "Sam LaPorta": "TE", "Trey McBride": "TE", "Dallas Goedert": "TE",
      "Jake Ferguson": "TE", "Zach Ertz": "TE", "Cade Otton": "TE"
    };

    // Helper to get player team abbreviation from full team name
    function getPlayerTeamAbbr(playerName, teamFull) {
      if (!teamFull) return '';
      const teamAbbrevMap = {
        'Atlanta Falcons': 'Falcons', 'Buffalo Bills': 'Bills', 'Carolina Panthers': 'Panthers',
        'Chicago Bears': 'Bears', 'Cincinnati Bengals': 'Bengals', 'Cleveland Browns': 'Browns',
        'Dallas Cowboys': 'Cowboys', 'Denver Broncos': 'Broncos', 'Detroit Lions': 'Lions',
        'Green Bay Packers': 'Packers', 'Houston Texans': 'Texans', 'Indianapolis Colts': 'Colts',
        'Jacksonville Jaguars': 'Jaguars', 'Kansas City Chiefs': 'Chiefs', 'Las Vegas Raiders': 'Raiders',
        'Los Angeles Chargers': 'Chargers', 'Los Angeles Rams': 'Rams', 'Miami Dolphins': 'Dolphins',
        'Minnesota Vikings': 'Vikings', 'New England Patriots': 'Patriots', 'New Orleans Saints': 'Saints',
        'New York Giants': 'Giants', 'New York Jets': 'Jets', 'Philadelphia Eagles': 'Eagles',
        'Pittsburgh Steelers': 'Steelers', 'San Francisco 49ers': '49ers', 'Seattle Seahawks': 'Seahawks',
        'Tampa Bay Buccaneers': 'Buccaneers', 'Tennessee Titans': 'Titans', 'Washington Commanders': 'Commanders',
        'Arizona Cardinals': 'Cardinals', 'Baltimore Ravens': 'Ravens'
      };
      return teamAbbrevMap[teamFull] || teamFull.split(' ').pop(); // Fallback to last word
    }

    // Player to team mapping (from backend)
    const playerTeams = {
      "Saquon Barkley": "Philadelphia Eagles", "A.J. Brown": "Philadelphia Eagles",
      "DeVonta Smith": "Philadelphia Eagles", "Devonta Smith": "Philadelphia Eagles",
      "George Pickens": "Dallas Cowboys", "CeeDee Lamb": "Dallas Cowboys",
      "Jake Ferguson": "Dallas Cowboys", "Dallas Goedert": "Philadelphia Eagles",
      "Javonte Williams": "Denver Broncos", "Terry McLaurin": "Washington Commanders",
      "Malik Nabers": "New York Giants", "Jayden Daniels": "Washington Commanders",
      "Russell Wilson": "New York Giants", "Lamar Jackson": "Baltimore Ravens",
      "Josh Allen": "Buffalo Bills", "Zay Flowers": "Baltimore Ravens",
      "Khalil Shakir": "Buffalo Bills", "James Cook": "Buffalo Bills",
      "Dalton Kincaid": "Buffalo Bills", "Derrick Henry": "Baltimore Ravens",
      "Mark Andrews": "Baltimore Ravens", "Aaron Jones": "Minnesota Vikings",
      "D'Andre Swift": "Chicago Bears", "T.J. Hockenson": "Minnesota Vikings",
      "Justin Jefferson": "Minnesota Vikings", "Caleb Williams": "Chicago Bears",
      "D.J. Moore": "Chicago Bears", "Tucker Kraft": "Green Bay Packers",
      "Kyren Williams": "Los Angeles Rams", "Geno Smith": "Seattle Seahawks",
      "Justin Herbert": "Los Angeles Chargers", "Jakobi Meyers": "Las Vegas Raiders",
      "Keenan Allen": "Chicago Bears", "Patrick Mahomes": "Kansas City Chiefs",
      "Bucky Irving": "Tampa Bay Buccaneers", "Bijan Robinson": "Atlanta Falcons",
      "Jordan Mason": "San Francisco 49ers", "Kenneth Walker III": "Seattle Seahawks",
      "Amon-Ra St. Brown": "Detroit Lions", "Jared Goff": "Detroit Lions",
      "Sam LaPorta": "Detroit Lions", "Kyler Murray": "Arizona Cardinals",
      "Sam Darnold": "Seattle Seahawks", "Trey Benson": "Arizona Cardinals",
      "Jaxon Smith-Njigba": "Seattle Seahawks", "Marvin Harrison Jr.": "Arizona Cardinals",
      "Trey McBride": "Arizona Cardinals", "Michael Wilson": "Arizona Cardinals",
      "Zach Charbonnet": "Seattle Seahawks", "Matthew Stafford": "Los Angeles Rams",
      "Daniel Jones": "Indianapolis Colts", "Puka Nacua": "Los Angeles Rams",
      "Cooper Kupp": "Los Angeles Rams", "Jonathan Taylor": "Indianapolis Colts",
      "Davante Adams": "Los Angeles Chargers", "Michael Pittman Jr.": "Indianapolis Colts",
      "Omarion Hampton": "Los Angeles Chargers", "Spencer Rattler": "New Orleans Saints",
      "David Montgomery": "Detroit Lions", "Jordan Love": "Green Bay Packers",
      "Mac Jones": "San Francisco 49ers", "Christian McCaffrey": "San Francisco 49ers",
      "Bo Nix": "Denver Broncos", "Jalen Hurts": "Philadelphia Eagles",
      "Stefon Diggs": "Houston Texans", "Drake Maye": "New England Patriots",
      "Dyami Brown": "Washington Commanders", "Isiah Pacheco": "Kansas City Chiefs",
      "Trevor Lawrence": "Jacksonville Jaguars", "Xavier Worthy": "Kansas City Chiefs",
      "Travis Kelce": "Kansas City Chiefs", "Marquise Brown": "Kansas City Chiefs",
      "Travis Etienne": "Jacksonville Jaguars", "Jahmyr Gibbs": "Detroit Lions",
      "Tyler Allgeier": "Atlanta Falcons", "Drake London": "Atlanta Falcons",
      "Roschon Johnson": "Chicago Bears", "Zach Ertz": "Washington Commanders",
      "Aaron Rodgers": "New York Jets", "Joe Flacco": "Indianapolis Colts",
      "Ja'Marr Chase": "Cincinnati Bengals", "DK Metcalf": "Seattle Seahawks",
      "Jaylen Warren": "Pittsburgh Steelers", "Rome Odunze": "Chicago Bears",
      "Michael Penix Jr.": "Atlanta Falcons", "Cade Otton": "Tampa Bay Buccaneers",
      "Baker Mayfield": "Tampa Bay Buccaneers", "Rhamondre Stevenson": "New England Patriots",
      "Rico Dowdle": "Dallas Cowboys", "Deebo Samuel": "San Francisco 49ers",
      "Rashee Rice": "Kansas City Chiefs",
      // Additional players
      "Marcus Mariota": "Washington Commanders", "Carson Wentz": "Kansas City Chiefs",
      "J.J. McCarthy": "Minnesota Vikings", "Jacory Croskey-Merritt": "Washington Commanders",
      "Brashard Smith": "Miami Dolphins", "Jordan Addison": "Minnesota Vikings",
      "Ladd McConkey": "Los Angeles Chargers", "Matthew Golden": "Houston Texans",
      "Quentin Johnston": "Los Angeles Chargers", "Tua Tagovailoa": "Miami Dolphins",
      "Malik Washington": "Miami Dolphins", "De'Von Achane": "Miami Dolphins",
      // College players
      "Dillon Gabriel": "Oregon Ducks", "Emeka Egbuka": "Ohio State Buckeyes",
      "Travis Hunter": "Colorado Buffaloes"
    };

    // Helper to get player team and position display
    function getPlayerTeamPosition(leg) {
      if (!leg.player) return ''; // No player = team bet (moneyline/spread)
      
      const isSpreadOrML = leg.stat === 'spread' || leg.stat === 'moneyline';
      if (isSpreadOrML) return ''; // Don't show for team bets
      
      // Look up position
      const position = playerPositions[leg.player] || '';
      
      // Look up team from player mapping
      const playerTeam = playerTeams[leg.player];
      const teamAbbr = playerTeam ? getPlayerTeamAbbr(leg.player, playerTeam) : '';
      
      if (position && teamAbbr) {
        return `${teamAbbr} ${position}`;
      } else if (teamAbbr) {
        return teamAbbr;
      } else if (position) {
        return position;
      }
      
      return '';
    }

    async function update(){
      msg.textContent='Fetching data...';
      try{
        // First process any new parlays
        await fetchWithAdminToken(statsUrl);
        
        // Get active tab
        const activeTab = document.querySelector('.tab.active').dataset.tab;
        
        // Only fetch data for the active tab; use cache if available
        if(activeTab === 'current') {
          // Fetch both todays and live bets and combine them
          const todaysUrl = `${API_BASE}/todays`;
          const [todaysResponse, liveResponse] = await Promise.all([
            fetchWithAdminToken(todaysUrl),
            fetchWithAdminToken(liveUrl)
          ]);
          
          if(!todaysResponse.ok) throw new Error(`Todays data error: ${todaysResponse.status}`);
          if(!liveResponse.ok) throw new Error(`Live data error: ${liveResponse.status}`);
          
          const todaysParlays = await todaysResponse.json();
          const liveParlays = await liveResponse.json();
          
          // Combine both arrays
          const combinedParlays = [...todaysParlays, ...liveParlays];
          cachedLive = combinedParlays;
          
          console.log('Todays parlays:', todaysParlays);
          console.log('Live parlays:', liveParlays);
          console.log('Combined parlays:', combinedParlays);
          
          render(combinedParlays, sec);
          msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
        } else if(activeTab === 'historical') {
          // Try localStorage cache first
          const cachedData = loadHistoricalCache();
          if (cachedData) {
            console.log('Using localStorage cached historical data');
            cachedHistorical = cachedData;
            render(cachedData, histSec);
            msg.textContent=`Using cached data: ${new Date().toLocaleTimeString()}`;
          } else {
            // No cache - fetch from server
            const historicalResponse = await fetchWithAdminToken(histUrl);
            if(!historicalResponse.ok) throw new Error(`Historical data error: ${historicalResponse.status}`);
            const historical = await historicalResponse.json();
            
            // Save to both memory and localStorage cache
            cachedHistorical = historical;
            saveHistoricalCache(historical);
            
            console.log('Historical parlays fetched and cached:', historical);
            render(historical, histSec);
            msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
          }
        }
        
        // Update cache display after rendering
        updateCacheDisplay();
      }catch(e){
        console.error('Error during update:', e);
        msg.textContent=`Error loading data: ${e.message}`;
      }
    }

    async function loadHistorical(){
      msg.textContent='Loading historical bets...';
      try{
        console.log('Fetching from:', histUrl);
        const r=await fetchWithAdminToken(histUrl);
        if(!r.ok)throw r.status;
        const historical=await r.json();
        console.log('Received historical data:', historical);
        render(historical, histSec);
        msg.textContent=`Historical data loaded: ${new Date().toLocaleTimeString()}`;
      }catch(e){
        console.error('Error loading historical data:', e);
        msg.textContent='Error loading historical data: ' + e.toString();
      }
    }

    function render(parlays, container){
      console.log('Render called with parlays:', parlays);
      console.log('Container:', container);
      container.innerHTML='';
      if (!Array.isArray(parlays)) {
        console.error('parlays is not an array:', parlays);
        return;
      }

      // Check if this is the historical section
      const isHistoricalSection = container.id === 'historical-sections' || container.dataset.tab === 'historical';
      
      // Sort parlays by game date and time
      const sortedParlays = [...parlays].sort((a, b) => {
        // For historical: use earliest date (latest games first - descending)
        // For live: use latest date (earliest games first - ascending)
        const getRelevantDate = (parlay) => {
          if (!parlay.legs || parlay.legs.length === 0) return new Date('9999-12-31');
          
          const dates = parlay.legs
            .map(leg => leg.game_date)
            .filter(date => date)
            .map(date => new Date(date));
          
          if (dates.length === 0) return new Date('9999-12-31');
          
          // For live bets: use LATEST game date (so multi-game parlays sort by their last game)
          // For historical: use EARLIEST game date (to show most recent first)
          if (isHistoricalSection) {
            return new Date(Math.min(...dates));
          } else {
            return new Date(Math.max(...dates));
          }
        };
        
        // Get game start time from the parlay's games data
        const getStartTime = (parlay, relevantDate) => {
          if (!parlay.games || parlay.games.length === 0) return null;
          
          // Find the game matching the relevant date
          const relevantDateStr = relevantDate.toISOString().split('T')[0];
          const game = parlay.games.find(g => g.game_date === relevantDateStr);
          
          if (game && game.startDateTime) {
            return new Date(game.startDateTime);
          }
          return null;
        };
        
        const dateA = getRelevantDate(a);
        const dateB = getRelevantDate(b);
        
        // First sort by date
        const dateCompare = isHistoricalSection ? dateB - dateA : dateA - dateB;
        
        // If dates are the same, sort by start time
        if (dateCompare === 0) {
          const timeA = getStartTime(a, dateA);
          const timeB = getStartTime(b, dateB);
          
          if (timeA && timeB) {
            const timeCompare = isHistoricalSection ? timeB - timeA : timeA - timeB;
            
            // If times are also the same, sort by number of legs (fewer legs first)
            if (timeCompare === 0) {
              const legsA = a.legs ? a.legs.length : 0;
              const legsB = b.legs ? b.legs.length : 0;
              return legsA - legsB; // Ascending order (fewer legs first)
            }
            
            return timeCompare;
          }
        }
        
        return dateCompare;
      });

      // Show a helpful empty-state when there's no data for the tab
      if (sortedParlays.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'no-data';
        const tabName = container.dataset.tab === 'historical' ? 'Historical Bets' : "Live Bets";
        empty.innerHTML = `
          <div style="text-align:center;padding:2rem;color:#bbb">
            <strong>No parlays found</strong>
            <div style="margin-top:.5rem">There are no ${tabName} to display right now.</div>
            <button id="empty-refresh" style="margin-top:1rem;padding:.5rem 1rem;border-radius:6px;background:#140d52;color:#fff;border:none;cursor:pointer">Refresh</button>
          </div>`;
        container.appendChild(empty);
        // wire the refresh button to re-run update()
        const b = empty.querySelector('#empty-refresh');
        if (b) b.addEventListener('click', update);
        return;
      }
      
      // Render all parlays in their respective sections (isHistoricalSection already defined above for sorting)
      sortedParlays.forEach(parlay=>{
        console.log('Processing parlay:', parlay);
        const section=document.createElement('div');
        section.className='parlay-section';
        section.dataset.site = parlay.betting_site || 'Unknown'; // For color-coding and filtering
        section.dataset.sport = parlay.sport || ''; // For sport filtering
        section.dataset.betDate = parlay.bet_date || ''; // For date filtering
        
        const header=document.createElement('div');
        header.className='parlay-header';
        
        // Enhance parlay name with team matchup if applicable
        const displayName = enhanceParlayName(parlay);
        
        // Check if all legs are Hit AND all games are final (winning bet deserves trophy)
        const allLegsComplete = parlay.legs && parlay.legs.length > 0 && 
          parlay.legs.every(leg => {
            // Get game data for this leg
            const gameData = parlay.games ? parlay.games.find(g => 
              g.teams.away === leg.away && g.teams.home === leg.home
            ) : null;
            
            // Game must be final to count as complete
            if (!gameData || gameData.statusTypeName !== 'STATUS_FINAL') {
              return false;
            }
            
            const current = leg.current ?? 0;
            const pct = leg.target > 0 ? Math.min(100, Math.round(current / leg.target * 100)) : 0;
            const isSpreadOrML = leg.stat === 'spread' || leg.stat === 'moneyline';
            const isTotalPoints = leg.stat === 'total_points' || leg.stat === 'total_points_under' || leg.stat === 'total_points_over';
            const statAdd = leg.stat_add || null;
            
            // Check if leg actually Hit (not just 100%)
            if (isSpreadOrML) {
              const scoreDiff = leg.score_diff ?? 0;
              if (leg.stat === 'moneyline') {
                return scoreDiff > 0; // Win = positive score diff
              } else if (leg.stat === 'spread') {
                return (scoreDiff + leg.target) > 0; // Covering spread
              }
            } else if (isTotalPoints) {
              // Use stat_add to determine if it's over or under
              // Fall back to old stat names for backward compatibility
              const isUnder = statAdd === 'under' || leg.stat === 'total_points_under';
              const isOver = statAdd === 'over' || leg.stat === 'total_points_over';
              
              if (isUnder) {
                return current < leg.target; // Under = current less than target
              } else if (isOver) {
                return current > leg.target; // Over = current more than target
              }
            } else {
              // Player props: Check stat_add for over/under
              if (statAdd === 'under') {
                return current < leg.target; // Under props
              } else if (statAdd === 'over' || statAdd === null) {
                // Default to "over" behavior (reach target)
                return pct === 100;
              }
            }
            
            return false;
          });
        
        // Get game date for single game parlays
        let formattedDate = '';
        
        // Check if on mobile view
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
          // Mobile: prioritize bet_date field
          if (parlay.bet_date) {
            try {
              const betDate = new Date(parlay.bet_date);
              if (betDate && !isNaN(betDate.getTime())) {
                const monthName = betDate.toLocaleDateString('en-US', { month: 'short' });
                const dayNum = betDate.getDate();
                const yearNum = betDate.getFullYear();
                formattedDate = `${monthName} ${dayNum}, ${yearNum}`;
              }
            } catch (e) {
              console.error('Error parsing bet_date:', parlay.bet_date, e);
              formattedDate = 'input date';
            }
          } else {
            // Fallback to 'input date' if no bet_date
            formattedDate = 'input date';
          }
        } else {
          // Desktop: show game_date in full format
          if (parlay.legs && parlay.legs[0]) {
            // Get unique game dates from all legs
            const uniqueDates = [...new Set(parlay.legs.map(leg => leg.game_date))].filter(d => d);
            
            // If there's only one unique date, it's a single game parlay
            if (uniqueDates.length === 1 && uniqueDates[0]) {
              const dateStr = String(uniqueDates[0]);
              try {
                let gameDate;
                
                // Handle both formats: YYYY-MM-DD (new standard) and YYYYMMDD (legacy)
                if (dateStr.includes('-')) {
                  // YYYY-MM-DD format
                  gameDate = new Date(dateStr);
                } else if (dateStr.length === 8) {
                  // YYYYMMDD format (legacy)
                  const year = dateStr.substring(0, 4);
                  const month = dateStr.substring(4, 6);
                  const day = dateStr.substring(6, 8);
                  gameDate = new Date(`${year}-${month}-${day}`);
                }
                
                // Check if date is valid
                if (gameDate && !isNaN(gameDate.getTime())) {
                  const dayOfWeek = gameDate.toLocaleDateString('en-US', { weekday: 'long' });
                  const monthName = gameDate.toLocaleDateString('en-US', { month: 'short' });
                  const dayNum = gameDate.getDate();
                  const yearNum = gameDate.getFullYear();
                  formattedDate = `${dayOfWeek} - ${monthName} ${dayNum}, ${yearNum}`;
                }
              } catch (e) {
                console.error('Error parsing date:', dateStr, e);
              }
            } else if (uniqueDates.length > 1) {
              // Multi-game parlay: show bet_date if available
              if (parlay.bet_date) {
                try {
                  const betDate = new Date(parlay.bet_date);
                  if (betDate && !isNaN(betDate.getTime())) {
                    const monthName = betDate.toLocaleDateString('en-US', { month: 'short' });
                    const dayNum = betDate.getDate();
                    const yearNum = betDate.getFullYear();
                    formattedDate = `Bet Date: ${monthName} ${dayNum}, ${yearNum}`;
                  }
                } catch (e) {
                  console.error('Error parsing bet_date:', parlay.bet_date, e);
                }
              }
            }
          }
        }
        
        header.innerHTML = `
          ${allLegsComplete ? `<img src="media/trophy-1.svg" class="trophy-icon trophy-dark" alt="Won"><img src="media/trophy-2.svg" class="trophy-icon trophy-light" alt="Won">` : ''}
          <div class="parlay-title">
            <div class="parlay-title-text">
              <span class="collapse-icon">▼</span>
              <div>
                <div>${displayName}</div>
                ${formattedDate && `<span class="parlay-date">${formattedDate}</span>`}
              </div>
            </div>
          </div>
        `;

        // Helper function to create scoreboard HTML
        const createScoreboard = (g) => {
          const stn=g.statusTypeName,isSched=stn==='STATUS_SCHEDULED',isLive=stn==='STATUS_IN_PROGRESS',isHalftime=stn==='STATUS_HALFTIME',isFinal=stn==='STATUS_FINAL';
          let gameStatus,gameCls,gameDetails;
          if(isSched){
            gameStatus='🔜';
            gameCls='status-pregame';
            const countdown = getCountdown(g.startDateTime);
            gameDetails=`<div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} @ ${getTeamAbbr(g.teams.home)}</div><div style="font-weight:normal;font-size:0.7rem;">${countdown || g.startTime}</div>`;
          }
          else if(isHalftime){gameStatus='HALF';gameCls='status-halftime';gameDetails=`<div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} ${g.score.away} - ${g.score.home} ${getTeamAbbr(g.teams.home)}</div>`;}
          else if(isLive){gameStatus='LIVE';gameCls='status-live';gameDetails=`<div style="font-weight:normal;font-size:0.7rem;">${getQuarter(g.period)}, ${g.clock}</div><div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} ${g.score.away} - ${g.score.home} ${getTeamAbbr(g.teams.home)}</div>`;}
          else{gameStatus='FINAL';gameCls='status-final';gameDetails=`<div style="font-weight:bold;">${getTeamAbbr(g.teams.away)} ${g.score.away} - ${g.score.home} ${getTeamAbbr(g.teams.home)}</div>`;}
          
          const gameInfoDiv=document.createElement('div');
          gameInfoDiv.className=isFinal?'game-info two-line':'game-info';
          gameInfoDiv.innerHTML=`<img src="media/logos/nfl-logo-1.svg" class="nfl-logo-bg nfl-logo-dark" alt="NFL"><img src="media/logos/nfl-logo-2.svg" class="nfl-logo-bg nfl-logo-light" alt="NFL"><div class="badge ${gameCls}">${gameStatus}</div>${gameDetails}`;
          return gameInfoDiv;
        };

        // Determine if we should show scoreboards inline or with toggle
        const isSingleBet = parlay.type === 'Single Bet' || parlay.legs.length === 1;
        const isSGP = parlay.type === 'Same Game Parlay' || parlay.type === 'SGP';
        
        // Collect all games
        let gamesToShow = [];
        if (parlay.games && parlay.games.length > 0) {
          if (parlay.type !== 'SGP' && parlay.type !== 'Same Game Parlay') {
            // For non-SGPs, get unique games
            const uniqueGames = new Map();
            parlay.legs.forEach(leg => {
              const gameKey = `${leg.away}-${leg.home}`;
              const game = parlay.games.find(g => 
                g.teams.away === leg.away && g.teams.home === leg.home
              );
              if (game && !uniqueGames.has(gameKey)) {
                uniqueGames.set(gameKey, game);
              }
            });
            gamesToShow = Array.from(uniqueGames.values());
          } else {
            gamesToShow = parlay.games;
          }
        }

        // Show inline scoreboards for Single Bet or SGP
        if ((isSingleBet || isSGP) && gamesToShow.length > 0) {
          const allGamesDiv=document.createElement('div');
          allGamesDiv.className='game-info-wrapper';
          gamesToShow.forEach(g => allGamesDiv.appendChild(createScoreboard(g)));
          header.appendChild(allGamesDiv);
        }
        // For multi-game parlays, add "Show Scores" toggle
        else if (gamesToShow.length > 1) {
          const showScoresBtn = document.createElement('button');
          showScoresBtn.className = 'show-scores-btn';
          showScoresBtn.textContent = 'Show Scores ▼';
          showScoresBtn.onclick = (e) => {
            e.stopPropagation();
            const scoreboardBlock = section.querySelector('.scoreboard-block');
            scoreboardBlock.classList.toggle('active');
            showScoresBtn.textContent = scoreboardBlock.classList.contains('active') ? 'Hide Scores ▲' : 'Show Scores ▼';
          };
          header.appendChild(showScoresBtn);

          // Create collapsible scoreboard block
          const scoreboardBlock = document.createElement('div');
          scoreboardBlock.className = 'scoreboard-block';
          
          // Split games into rows (9 per row for web, 3 per row for mobile - handled by CSS)
          const gamesPerRow = window.innerWidth > 768 ? 9 : 3;
          for (let i = 0; i < gamesToShow.length; i += gamesPerRow) {
            const rowGames = gamesToShow.slice(i, i + gamesPerRow);
            const row = document.createElement('div');
            row.className = 'scoreboard-row';
            rowGames.forEach(g => row.appendChild(createScoreboard(g)));
            scoreboardBlock.appendChild(row);
          }
          
          header.appendChild(scoreboardBlock);
        }

        const isAnyGameLive = parlay.games && parlay.games.some(g=>g.statusTypeName==='STATUS_IN_PROGRESS' || g.statusTypeName==='STATUS_HALFTIME');
        const areAllGamesFinal = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_FINAL');
        const areAllGamesScheduled = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_SCHEDULED');

        // Sort legs by status for Live Bets: "In Progress" → "Not Started" → "Hit"
        // Only sort for live bets tab, not historical
        let legsToRender = parlay.legs;
        if (!isHistoricalSection) {
          legsToRender = [...parlay.legs].sort((a, b) => {
            // Helper function to determine leg status
            const getLegStatus = (leg) => {
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === leg.away && g.teams.home === leg.home
              ) : null;
              
              const isSpreadOrML = leg.stat === 'spread' || leg.stat === 'moneyline';
              const current = leg.current ?? 0;
              const pct = leg.target > 0 ? Math.min(100, Math.round(current / leg.target * 100)) : 0;
              
              // Check if game is in progress
              if (gameData && (gameData.statusTypeName === 'STATUS_IN_PROGRESS' || gameData.statusTypeName === 'STATUS_HALFTIME')) {
                return 'In Progress';
              }
              
              // Check if not started
              if (gameData && gameData.statusTypeName === 'STATUS_SCHEDULED') {
                return 'Not Started';
              }
              if (!gameData && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))) {
                return 'Not Started';
              }
              
              // Check if hit (100% or winning bet)
              if (!isSpreadOrML && pct === 100) {
                return 'Hit';
              }
              if (isSpreadOrML && gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                const scoreDiff = leg.score_diff ?? 0;
                let isWinningBet = false;
                if (leg.stat === 'moneyline') {
                  isWinningBet = scoreDiff > 0;
                } else if (leg.stat === 'spread') {
                  isWinningBet = (scoreDiff + leg.target) > 0;
                }
                return isWinningBet ? 'Hit' : 'Miss';
              }
              
              return 'In Progress'; // Default
            };
            
            const statusA = getLegStatus(a);
            const statusB = getLegStatus(b);
            
            // Sort order: "In Progress" → "Not Started" → "Hit" → "Miss"
            const statusOrder = {
              'In Progress': 0,
              'Not Started': 1,
              'Hit': 2,
              'Miss': 3
            };
            
            return (statusOrder[statusA] ?? 99) - (statusOrder[statusB] ?? 99);
          });
        }

        const table=document.createElement('table');
        table.innerHTML=`
          <thead><tr>
            <th>Player</th><th>Bet Type</th><th>Current</th>
            <th>Target</th><th style="width:25%;">Progress</th><th>Status</th>
          </tr></thead>
          <tbody>
            ${legsToRender.map(p=>{
              const current = p.current ?? 0; // Handle undefined/null as 0
              const pct = p.target > 0 ? Math.min(100, Math.round(current / p.target * 100)) : 0;
              
              // Check if this is a spread or moneyline bet (no progress bar)
              const isSpreadOrML = p.stat === 'spread' || p.stat === 'moneyline';
              
              // Check if this is a total points over/under bet
              const isTotalPoints = p.stat === 'total_points' || p.stat === 'total_points_under' || p.stat === 'total_points_over';
              const statAdd = p.stat_add || null;
              
              // Get game data for this leg
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === p.away && g.teams.home === p.home
              ) : null;
              
              let progressCol = '';
              let currentDisplay = current;
              let targetDisplay = p.target;
              let playerDisplay = p.player || p.team || 'N/A';
              
              // Handle total points over/under - show matchup as "player"
              if (isTotalPoints) {
                // Get friendly team names (e.g., "Tampa" instead of "TB", "Saints" instead of "NO")
                const getFriendlyTeamName = (fullName) => {
                  // Extract the last word (team name) from full name
                  const parts = fullName.split(' ');
                  return parts[parts.length - 1]; // Returns "Buccaneers", "Saints", etc.
                };
                
                const awayName = getFriendlyTeamName(p.away);
                const homeName = getFriendlyTeamName(p.home);
                playerDisplay = `${awayName} @ ${homeName}`;
                
                // Show progress bar with percentage for total points
                if (gameData) {
                  const awayScore = gameData.score.away;
                  const homeScore = gameData.score.home;
                  const totalScore = awayScore + homeScore;
                  
                  currentDisplay = totalScore;
                  
                  // Calculate percentage and show progress bar
                  const totalPct = p.target > 0 ? Math.min(100, Math.round(totalScore / p.target * 100)) : 0;
                  
                  // Determine if this is an under or over bet
                  const isTotalUnder = statAdd === 'under' || p.stat === 'total_points_under';
                  const isTotalOver = statAdd === 'over' || p.stat === 'total_points_over';
                  
                  let totalCls = '';
                  const areAllGamesFinal = parlay.games && parlay.games.every(g => g.statusTypeName === 'STATUS_FINAL');
                  
                  if (areAllGamesFinal) {
                    // Game is over - show green if bet hit, red if missed
                    if (isTotalUnder) {
                      // Under bet: hit if total < target
                      totalCls = (totalScore < p.target) ? 'pct-under-vlow' : 'pct-under-full';
                    } else {
                      // Over bet: hit if total > target
                      totalCls = (totalScore > p.target) ? 'pct-full' : 'pct-vlow';
                    }
                  } else {
                    // Game is live/in progress
                    if (isTotalUnder) {
                      // Reverse colors for under bets: 0-60% green, 60-80% yellow, 80-99% orange, 100% red
                      if (totalPct >= 100) {
                        totalCls = 'pct-under-full';  // Red at 100%+
                      } else if (totalPct >= 80) {
                        totalCls = 'pct-under-high';  // Orange 80-99%
                      } else if (totalPct >= 60) {
                        totalCls = 'pct-under-mid';   // Yellow 60-79%
                      } else {
                        totalCls = 'pct-under-vlow';  // Green 0-59%
                      }
                    } else {
                      // Normal colors for over bets
                      if (totalPct >= 100) {
                        totalCls = 'pct-full';
                      } else if (totalPct >= 60) {
                        totalCls = 'pct-mid';
                      } else if (totalPct >= 20) {
                        totalCls = 'pct-low';
                      } else if (totalPct > 0) {
                        totalCls = 'pct-vlow';
                      }
                    }
                  }
                  
                  progressCol = `<div class="progress-bar ${totalCls}">
                           <div class="progress ${totalCls}" style="width:${totalPct}%"></div>
                           <div class="progress-text">${totalPct}%</div>
                         </div>`;
                } else {
                  progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
                }
              } else if (isSpreadOrML) {
                // For spread/moneyline, show score with team names only
                const scoreDiff = p.score_diff ?? 0;
                const betTeam = p.team || '';
                const betTeamName = betTeam.split(' ').pop(); // Get last word (e.g., "Cowboys")
                
                // Determine if bet is currently winning or losing
                let isWinning = false;
                let progressColor = '';
                
                if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                  if (p.stat === 'moneyline') {
                    isWinning = scoreDiff > 0;
                  } else if (p.stat === 'spread') {
                    // For spread, check if covering the spread
                    isWinning = (scoreDiff + p.target) > 0;
                  }
                  progressColor = isWinning ? 'color: #4caf50;' : 'color: #f44336;'; // Green if winning, red if losing
                }
                
                // Find opponent team name
                let opponentTeamName = '';
                if (gameData) {
                  const isHome = betTeam === gameData.teams.home;
                  const opponentFull = isHome ? gameData.teams.away : gameData.teams.home;
                  opponentTeamName = opponentFull.split(' ').pop();
                  
                  // Get actual scores
                  const betTeamScore = isHome ? gameData.score.home : gameData.score.away;
                  const oppTeamScore = isHome ? gameData.score.away : gameData.score.home;
                  
                  // Show score in format: "Cowboys 21 - 7 Falcons" with color based on winning/losing
                  progressCol = `<div style="text-align:center;padding:0.5rem;font-weight:bold;${progressColor}">${betTeamName} ${betTeamScore} - ${oppTeamScore} ${opponentTeamName}</div>`;
                } else {
                  // No game data yet (scheduled game)
                  progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
                }
                
                // For moneyline: current shows winning/losing status, target shows "Win"
                if (p.stat === 'moneyline') {
                  targetDisplay = 'Win';
                  if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                    const isFinal = gameData.statusTypeName === 'STATUS_FINAL';
                    if (scoreDiff > 0) {
                      currentDisplay = isFinal ? 'Win' : `Winning by ${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = isFinal ? 'Loss' : `Losing by ${Math.abs(scoreDiff)}`;
                    } else {
                      currentDisplay = 'Tied';
                    }
                  } else if (!gameData && (areAllGamesFinal || areAllGamesScheduled === false)) {
                    // Historical data without game info - use current value
                    currentDisplay = current === 1 ? 'Win' : 'Loss';
                  } else {
                    currentDisplay = '-';
                  }
                }
                
                // For spread: format target with +/- sign
                if (p.stat === 'spread') {
                  targetDisplay = p.target > 0 ? `+${p.target}` : `${p.target}`;
                  // Current shows Up/Down for live games, Win/Loss for final games
                  if (gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                    currentDisplay = current === 1 ? 'Win' : 'Loss';
                  } else if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                    // Show Up/Down during live game
                    if (scoreDiff > 0) {
                      currentDisplay = `Up ${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = `Down ${Math.abs(scoreDiff)}`;
                    } else {
                      currentDisplay = 'Tied';
                    }
                  } else {
                    currentDisplay = current;
                  }
                }
                
              } else {
                // Regular progress bar for numeric stats
                let cls = '';
                const isUnderBet = statAdd === 'under';
                
                if (areAllGamesFinal) {
                  // Game is over - show green if bet hit, red if missed
                  if (isUnderBet) {
                    // Under bet: hit if current < target
                    cls = (current < p.target) ? 'pct-under-vlow' : 'pct-under-full';
                  } else {
                    // Over bet: hit if 100%
                    cls = (pct === 100) ? 'pct-full' : 'pct-vlow';
                  }
                } else {
                  // Game is live/in progress
                  if (isUnderBet) {
                    // Reverse colors for under bets: 0-60% green, 60-80% yellow, 80-99% orange, 100% red
                    if (pct === 100) {
                      cls = 'pct-under-full';  // Red at 100%
                    } else if (pct >= 80) {
                      cls = 'pct-under-high';  // Orange 80-99%
                    } else if (pct >= 60) {
                      cls = 'pct-under-mid';   // Yellow 60-79%
                    } else {
                      cls = 'pct-under-vlow';  // Green 0-59%
                    }
                  } else {
                    // Normal colors for over bets
                    if (pct === 100) {
                      cls = 'pct-full';
                    } else if (pct >= 60) {
                      cls = 'pct-mid';
                    } else if (pct >= 20) {
                      cls = 'pct-low';
                    } else if (pct > 0) {
                      cls = 'pct-vlow';
                    }
                  }
                }
                progressCol = `<div class="progress-bar ${cls}">
                           <div class="progress ${cls}" style="width:${pct}%"></div>
                           <div class="progress-text">${pct}%</div>
                         </div>`;
              }
              
              // Determine win/loss for total points over/under
              if (isTotalPoints && gameData) {
                const totalScore = current;
                // Use stat_add to determine if it's over or under
                // Fall back to old stat names for backward compatibility
                const isUnder = statAdd === 'under' || p.stat === 'total_points_under';
                const isOver = statAdd === 'over' || p.stat === 'total_points_over';
                
                if (isUnder) {
                  isWinningBet = totalScore < p.target;
                } else if (isOver) {
                  isWinningBet = totalScore > p.target;
                }
              }
              
              // Determine win/loss for spread/moneyline based on actual game result
              if (isSpreadOrML && gameData) {
                const scoreDiff = p.score_diff ?? 0;
                console.log(`[Status Check] ${p.team || p.player} - ${p.stat}: scoreDiff=${scoreDiff}, target=${p.target}, gameStatus=${gameData.statusTypeName}`);
                
                if (p.stat === 'moneyline') {
                  // Moneyline: just need to win (positive score difference)
                  isWinningBet = scoreDiff > 0;
                  console.log(`  Moneyline: scoreDiff > 0 = ${isWinningBet}`);
                } else if (p.stat === 'spread') {
                  // Spread: score_diff + spread > 0
                  // Example: -7 spread, win by 10 = 10 + (-7) = 3 > 0 ✓
                  // Example: +3.5 spread, lose by 3 = -3 + 3.5 = 0.5 > 0 ✓
                  isWinningBet = (scoreDiff + p.target) > 0;
                  console.log(`  Spread: (${scoreDiff} + ${p.target}) = ${scoreDiff + p.target} > 0 = ${isWinningBet}`);
                }
              }
              
              // Status logic - check game state FIRST before showing win/loss
              if(gameData && gameData.statusTypeName === 'STATUS_SCHEDULED') {
                txt='🔜 Not Started';
              } else if(gameData && (gameData.statusTypeName === 'STATUS_IN_PROGRESS' || gameData.statusTypeName === 'STATUS_HALFTIME')) {
                txt='⏳ In Progress';
              } else if(!gameData && (areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))) {
                txt='🔜 Not Started';
              } else if((isSpreadOrML || isTotalPoints) && gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                // For spread/moneyline/totals, only show Hit/Miss when game is FINAL
                txt = isWinningBet ? '✅ Hit' : '🚫 Miss';
              } else if(!isSpreadOrML && !isTotalPoints) {
                // For numeric stats (player props), check stat_add for over/under
                let isHit = false;
                
                if (statAdd === 'under') {
                  // Under props: Hit when current < target
                  isHit = current < p.target;
                } else {
                  // Over props (or null/default): Hit when 100%
                  isHit = pct === 100;
                }
                
                if(isHit) txt='✅ Hit';
                else if(areAllGamesFinal) txt='🚫 Miss';
                else txt='⏳ In Progress';
              } else {
                txt='⏳ In Progress'; // Default to in progress
              }
              
              // Format for mobile display
              const playerOrTeam = playerDisplay; // Use the calculated playerDisplay
              const statType = fmtType(p.stat, statAdd);
              const mobileCurrentDisplay = formatStatForMobile(currentDisplay, p.stat);
              const mobileTargetDisplay = formatStatForMobile(targetDisplay, p.stat);
              
              // Get team and position for player props
              const teamPosition = getPlayerTeamPosition(p);
              const playerCellContent = p.player || p.team || 'N/A';
              const playerCellHTML = teamPosition ? 
                `<div>${playerCellContent}</div><div style="font-size:0.65rem;color:#999;margin-top:0.15rem;">${teamPosition}</div>` : 
                playerCellContent;
              
              // Mobile player name with stat type on same line, team/position below
              const mobilePlayerHTML = teamPosition ? 
                `<strong>${playerOrTeam}</strong><span style="font-weight:normal;"> - ${statType}</span><div style="font-size:0.65rem;font-weight:bold;color:#999;margin-top:0.15rem;">${teamPosition}</div>` : 
                `<strong>${playerOrTeam}</strong><span style="font-weight:normal;"> - ${statType}</span>`;
              
              return`
                <tr>
                  <td>
                    <div class="mobile-line-1">
                      <span>${mobilePlayerHTML}</span>
                      <span>${txt}</span>
                    </div>
                  </td>
                  <td>
                    <div class="mobile-line-2">
                      <span>${mobileCurrentDisplay}<div style="font-size:0.65rem;color:#999;margin-top:0.075rem;">Current</div></span>
                      <span>${progressCol}</span>
                      <span>${mobileTargetDisplay}<div style="font-size:0.65rem;color:#999;margin-top:0.075rem;">Target</div></span>
                    </div>
                  </td>
                  <td>${playerCellHTML}</td>
                  <td>${fmtType(p.stat, statAdd)}</td>
                  <td>${currentDisplay}</td>
                  <td>${targetDisplay}</td>
                  <td>${progressCol}</td>
                  <td>${txt}</td>
                </tr>`;
            }).join('')}
          </tbody>`;
        
        // Create footer with bet info
        const footer = document.createElement('div');
        footer.className = 'parlay-footer';
        
        const oddsText = parlay.odds || 'N/A';
        const wagerText = parlay.wager ? `$${parlay.wager}` : 'N/A';
        const betIdText = parlay.bet_id || 'N/A';
        const siteText = parlay.betting_site || 'N/A';
        
        // Calculate winnings if bet won (all games final and all legs hit)
        let winningsText = '$0.00';
        const allGamesFinal = parlay.games && parlay.games.every(g => g.statusTypeName === 'STATUS_FINAL');
        
        if (allGamesFinal && allLegsComplete && parlay.returns && parlay.wager) {
          const winnings = parlay.returns - parlay.wager;
          winningsText = `$${winnings.toFixed(2)}`;
        }
        
        // Determine which logo to use based on theme and betting site
        const isDarkMode = !document.body.classList.contains('light-mode');
        const logoSuffix = isDarkMode ? '1' : '2'; // 1=white (dark mode), 2=colored (light mode)
        
        // Map betting site names to logo filenames
        const logoMap = {
          'DraftKings': 'draftkings',
          'FanDuel': 'fanduel',
          'Dabble': 'dabble'
        };
        
        const logoKey = logoMap[siteText];
        const logoHTML = logoKey ? 
          `<img src="media/logos/${logoKey}-logo-${logoSuffix}.svg" 
                alt="${siteText}" 
                class="footer-logo"
                onerror="this.style.display='none'">` : '';
        
        footer.innerHTML = `
          <div class="footer-left">
            <div class="footer-odds">Odds: ${oddsText}</div>
            <div class="footer-wager">Wager: ${wagerText}</div>
            <div class="footer-winnings">Winnings: ${winningsText}</div>
          </div>
          <div class="footer-right">
            <div class="footer-betid">Bet ID: ${betIdText}</div>
            <div class="footer-site">${siteText}</div>
          </div>
          ${logoHTML}
        `;
        
        // Wrap only table in parlay-body div for collapsing (footer stays visible)
        const parlayBody = document.createElement('div');
        parlayBody.className = 'parlay-body';
        parlayBody.appendChild(table);
        
        section.appendChild(header);
        section.appendChild(parlayBody);
        section.appendChild(footer);
        
        // Add collapse/expand functionality
        header.addEventListener('click', () => {
          section.classList.toggle('collapsed');
        });
        
        // === SORTABLE COLUMNS ===
        // Attach sorting to THIS table's headers only (not all tables on page)
        const currentTable = section.querySelector('table');
        if (currentTable) {
          currentTable.querySelectorAll('thead th').forEach((th, index) => {
            th.addEventListener('click', () => {
              const table = th.closest('table');
              const tbody = table.querySelector('tbody');
              const rows = Array.from(tbody.querySelectorAll('tr'));
              
              // Determine sort direction
              const isAsc = th.classList.contains('sorted') && th.classList.contains('asc');
              
              // Remove sorted class from all headers in this table
              table.querySelectorAll('thead th').forEach(h => {
                h.classList.remove('sorted', 'asc');
              });
              
              // Add sorted class to clicked header
              th.classList.add('sorted');
              if (!isAsc) th.classList.add('asc');
              
              // Sort rows
              rows.sort((a, b) => {
                const aCell = a.querySelectorAll('td')[index]?.textContent.trim() || '';
                const bCell = b.querySelectorAll('td')[index]?.textContent.trim() || '';
                
                // For Player column (index 0), sort by first word only
                if (index === 0) {
                  const aFirstWord = aCell.split(' ')[0];
                  const bFirstWord = bCell.split(' ')[0];
                  return isAsc ? aFirstWord.localeCompare(bFirstWord) : bFirstWord.localeCompare(aFirstWord);
                }
                
                // For Progress column (index 4), extract percentage from progress bar
                if (index === 4) {
                  const aTd = a.querySelectorAll('td')[index];
                  const bTd = b.querySelectorAll('td')[index];
                  
                  // Try to get percentage from progress-text span
                  const aProgressText = aTd?.querySelector('.progress-text')?.textContent || '0%';
                  const bProgressText = bTd?.querySelector('.progress-text')?.textContent || '0%';
                  
                  const aPct = parseFloat(aProgressText.replace('%', '')) || 0;
                  const bPct = parseFloat(bProgressText.replace('%', '')) || 0;
                  
                  return isAsc ? aPct - bPct : bPct - aPct;
                }
                
                // Try numeric comparison first
                const aNum = parseFloat(aCell);
                const bNum = parseFloat(bCell);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                  return isAsc ? aNum - bNum : bNum - aNum;
                }
                
                // String comparison
                return isAsc ? aCell.localeCompare(bCell) : bCell.localeCompare(aCell);
              });
              
              // Re-append sorted rows
              rows.forEach(row => tbody.appendChild(row));
            });
          });
        }
        
        // Append to the container passed into render() so each tab gets its own content
        container.appendChild(section);
      });
      
      // Apply filters after rendering
      applyAllFilters();
      
      // Update tab count
      updateTabCount(container, sortedParlays.length);
    }
    
    // Update tab label with bet count
    function updateTabCount(container, count) {
      const isHistorical = container.id === 'historical-sections' || container.dataset.tab === 'historical';
      const tabButton = document.querySelector(`.tab[data-tab="${isHistorical ? 'historical' : 'current'}"]`);
      
      if (tabButton) {
        const baseText = isHistorical ? 'Historical Bets' : 'Live Bets';
        tabButton.textContent = `${baseText} (${count})`;
      }
    }

    btn.addEventListener('click',update);
    
    // Move completed games button
    const moveBtn = document.getElementById('move-completed-button');
    moveBtn.addEventListener('click', async () => {
      try {
        msg.textContent = 'Moving completed games...';
        moveBtn.disabled = true;
        
        const response = await fetchWithAdminToken(`${API_BASE}/admin/move_completed`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) throw new Error(`Move failed: ${response.status}`);
        
        const result = await response.json();
        msg.textContent = `Moved ${result.moved_count} parlay(s) to history. ${result.remaining_live} still live.`;
        
        // Clear caches (including localStorage for historical since new bets were added)
        cachedLive = null;
        cachedHistorical = null;
        clearHistoricalCache();
        
        // Update twice to ensure all data is refreshed properly
        await update();
        
        // Small delay then update again to show the rearranged bets
        setTimeout(async () => {
          await update();
        }, 500);
      } catch (e) {
        console.error('Error moving completed:', e);
        msg.textContent = `Error: ${e.message}`;
      } finally {
        moveBtn.disabled = false;
      }
    });
    
    update();
    
    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered:', registration.scope);
            
            // Check for updates every hour
            setInterval(() => {
              registration.update();
            }, 3600000);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Parlay & Wager Tracker</title>
  <style>
    :root {
      --bg:#121212;--surface:#1a1a1a;--primary:#140d52;
      --text:#e0e0e0;--border:#ffcc00a4;--green:#4caf50;
      --orange:#ff9800;--yellow:#ffeb3b;--pregame:#ffc107;
      --error:#f44336;--progress-bg:#444;--section-bg:#252525;
      --outline-blue: #03a9f4; --title-color: #e657ff;
      --tab-active: #2a2a2a;
    }
    
    .tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      justify-content: center;
    }
    
    .tab {
      padding: 0.75rem 1.5rem;
      background: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    .tab:hover {
      opacity: 0.9;
    }
    
    .tab.active {
      background: var(--tab-active);
      color: var(--title-color);
    }
    body{background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
      margin:0;padding:1rem;
      zoom: 0.8;}
    .container{max-width:1200px;margin:auto;padding:2rem;
      background:var(--surface);border-radius:12px;
      box-shadow:0 4px 20px rgba(0,0,0,0.25);}
    h1{text-align:center;color:var(--title-color);margin-bottom:1.5rem;}
    button{display:block;margin:0 auto 1.5rem;padding:.75rem 1.5rem;
      background:var(--primary);color:#fff;font-weight:bold;
      border:none;border-radius:8px;cursor:pointer;}
    button:hover{opacity:.9;}
    #status-message{text-align:center;margin-bottom:2rem;color:#aaa;}
    .parlay-section{background:var(--section-bg);margin-bottom:2rem;
      border-radius:12px;padding:1.5rem 1.5rem 1.125rem;border:2px solid var(--border);}
    .parlay-header{background:var(--primary);color:#fff;
      margin:-1.5rem -1.5rem 1.125rem -1.5rem;padding:1rem 1.5rem;
      border-radius:10px 10px 0 0;display:flex; flex-wrap: wrap;
      justify-content:space-between;align-items:flex-start;font-weight:bold;
      position:relative;}
    .parlay-footer{background:var(--primary);color:#fff;
      margin:1.125rem -1.5rem -1.125rem -1.5rem;padding:0.75rem 1.5rem;
      border-radius:0 0 10px 10px;display:flex;
      justify-content:space-between;align-items:center;
      font-size:0.75rem;min-height:3rem;}
    .footer-left{display:flex;flex-direction:column;gap:0.25rem;}
    .footer-right{display:flex;flex-direction:column;gap:0.25rem;text-align:right;}
    .footer-odds{font-weight:bold;color:#FFD700;}
    .footer-wager{color:#ddd;}
    .footer-betid{color:#ddd;}
    .footer-site{color:#fff;font-weight:500;}
    .winning-overlay{
      position:absolute;
      top:0.5rem;
      left:0.75rem;
      right:0.75rem;
      bottom:0.5rem;
      background:rgba(255, 242, 0, 0.622);
      border-radius:8px;
      pointer-events:none;
      z-index:0;}
    .parlay-title{display:flex;flex-direction:column;gap:0.25rem;position:relative;z-index:1;}
    .parlay-date{font-size:0.85rem;font-weight:normal;opacity:0.8;}
    .game-info-wrapper{display:flex;gap:1rem;flex-wrap:wrap;position:relative;z-index:1;}
    .game-info{display:flex;flex-direction:column;align-items:center;
      gap:.25rem;font-size:.9rem;border:1px solid var(--border);
      padding:.5rem;border-radius:6px;background:rgba(0,0,0,0.2);}
    table{width:100%;border-collapse:separate;border-spacing:0;}
    th,td{padding:.75rem;border-bottom:1px solid var(--border);
      vertical-align:middle;text-align:left;}
    td { background: var(--surface); }
    th:first-child { border-top-left-radius: 10px; }
    th:last-child { border-top-right-radius: 10px; }
    th:nth-child(3),td:nth-child(3),
    th:nth-child(4),td:nth-child(4),
    th:nth-child(5),td:nth-child(5),
    th:nth-child(6),td:nth-child(6){text-align:center;}
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:last-child td:first-child { border-bottom-left-radius: 10px; }
    tbody tr:last-child td:last-child { border-bottom-right-radius: 10px; }
    th{background:#2a2a2a;}
    .progress-bar{background:var(--progress-bg);border-radius:13px;position:relative;height:1.5rem;border:2px solid var(--outline-blue);padding:3px;}
    .progress-bar.pct-vlow { border-color: var(--error); }
    .progress-bar.pct-low { border-color: var(--orange); }
    .progress-bar.pct-mid { border-color: var(--yellow); }
    .progress-bar.pct-full { border-color: var(--green); }
    .progress{height:100%;transition:width .5s ease-in-out;border-radius:8px;}
    .progress-text{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;}
    .progress.pct-vlow{background:linear-gradient(to right, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 1));}
    .progress.pct-low{background:linear-gradient(to right, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 1));}
    .progress.pct-mid{background:linear-gradient(to right, rgba(255, 235, 59, 0.2), rgba(255, 235, 59, 1));}
    .progress.pct-full{background:linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 1));}
    .badge{display:inline-block;font-size:.75rem;font-weight:bold;
      margin-bottom:.25rem;padding:2px 6px;border-radius:4px;}
    .status-pregame{background:var(--pregame);color:#ffffff;}
    .status-live{background:var(--error);color:#ffffff;}
    .status-halftime{background:transparent;color:#ffffff;border:1px solid #ffffff;}
    .status-final{background:#808080;color:#ffffff;}
    
    /* Mobile-specific layout classes (hidden on desktop) */
    .mobile-line-1,
    .mobile-line-2,
    .mobile-line-2-header {
      display: none;
    }
    
    /* Hide mobile cells 1-2 on desktop */
    table tbody tr td:nth-child(1),
    table tbody tr td:nth-child(2) {
      display: none;
    }
    
    .mobile-line-1 {
      justify-content: space-between;
      align-items: center;
      font-weight: 500;
    }
    
    .mobile-line-2-header {
      grid-template-columns: auto 1fr auto;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.45rem;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 0.25rem;
      text-align: center;
    }
    
    .mobile-line-2-header span:first-child {
      text-align: left;
    }
    
    .mobile-line-2-header span:last-child {
      text-align: right;
    }
    
    .mobile-line-2 {
      grid-template-columns: auto 1fr auto;
      gap: 0.5rem;
      align-items: center;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 0;
        zoom: 1; /* Reset zoom on mobile for better readability */
      }
      
      .container {
        padding: 0.5rem;
        border-radius: 0;
      }
      
      h1 {
        font-size: 1.5rem;
        padding: 0 0.5rem;
      }
      
      .parlay-section {
        padding: 1rem 0.5rem;
        overflow-x: hidden; /* Prevent horizontal scroll */
        margin: 0.5rem 0;
        border-radius: 8px;
      }
      
      .parlay-header {
        margin: -1rem -0.5rem 1rem -0.5rem;
        padding: 0.75rem 0.5rem;
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .parlay-footer {
        margin: 1rem -0.5rem -1rem -0.5rem;
        padding: 0.75rem 0.5rem;
        font-size: 0.7rem;
      }
      
      /* Adjust winning overlay for mobile padding */
      .winning-overlay {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 8px;
      }

      /* Compact scoreboards - 3 per row */
      .game-info-wrapper {
        gap: 0.5rem;
        justify-content: flex-start;
      }
      
      .game-info {
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        gap: 0.15rem;
        min-width: calc(33.333% - 0.35rem); /* Fit 3 per row */
        flex: 0 0 auto;
      }
      
      .game-info .badge {
        font-size: 0.6rem;
        padding: 1px 4px;
      }

      /* Mobile: Stack bet legs vertically with compact layout */
      table {
        display: block;
      }
      
      thead {
        display: none; /* Hide table headers on mobile */
      }
      
      tbody {
        display: block;
      }
      
      tr {
        display: block;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background: var(--surface);
        border-radius: 8px;
        border: 1px solid var(--border);
      }
      
      td {
        display: block;
        padding: 0.15rem 0;
        border: none;
        background: transparent;
        text-align: left !important;
      }
      
      /* Hide desktop columns 3-8 (individual cells) */
      tr td:nth-child(n+3) {
        display: none !important;
      }
      
      /* Show mobile columns 1-2 */
      tr td:nth-child(1),
      tr td:nth-child(2) {
        display: block !important;
      }
      
      /* Make mobile-specific content visible */
      .mobile-line-1 {
        display: flex !important;
        font-size: 0.9rem;
      }
      
      .mobile-line-2-header {
        display: grid !important;
        font-size: 0.45rem;
      }
      
      .mobile-line-2 {
        display: grid !important;
        font-size: 0.85rem;
      }
      
      /* Line 1 styling */
      tr td:nth-child(1) {
        margin-bottom: 0.5rem;
      }

      .progress-bar {
        height: 2.5rem;
      }
      
      .progress-bar .progress-text {
        font-size: 0.75rem;
      }
      
      .tabs {
        gap: 0.5rem;
        padding: 0 0.5rem;
      }
      
      .tab {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      button {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      #refresh-button,
      #move-completed-button {
        margin-left: 0.5rem !important;
      }
      
      #status-message {
        margin: 0 0.5rem;
      }
    }
    
    /* Extra small screens */
    @media (max-width: 480px) {
      h1 {
        font-size: 1.25rem;
      }
      
      .progress-bar {
        height: 1rem;
        font-size: 0.65rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Parlay & Wager Tracker</h1>
    <div class="tabs">
      <button class="tab active" data-tab="current">Live Bets</button>
      <button class="tab" data-tab="historical">Historical Bets</button>
    </div>
    <button id="refresh-button">Refresh Stats</button>
    <button id="move-completed-button" style="margin-left: 10px;">Move Completed to History</button>
    <div id="status-message"></div>
    <div id="parlay-sections" class="tab-content active" data-tab="current"></div>
    <div id="historical-sections" class="tab-content" data-tab="historical" style="display:none"></div>
  </div>
  <script>
    // Helper to read query params
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // API base precedence: ?api=... (query param) -> window.API_BASE -> default Render backend
    const urlApi = getQueryParam('api');
    const API_BASE = (urlApi ? urlApi.replace(/\/$/, '') : (window.API_BASE && window.API_BASE.replace(/\/$/, ''))) || 'https://parlay-tracker-backend.onrender.com';
    const btn=document.getElementById('refresh-button'),
      sec=document.getElementById('parlay-sections'),
      histSec=document.getElementById('historical-sections'),
      msg=document.getElementById('status-message'),
      statsUrl = `${API_BASE}/stats`,
      liveUrl = `${API_BASE}/live`,
      histUrl = `${API_BASE}/historical`;
    
    // Client-side cache for faster tab switching
    let cachedLive = null;
    let cachedHistorical = null;

    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', async () => {
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show/hide content
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(content => {
          if (content.dataset.tab === tabName) {
            content.style.display = 'block';
          } else {
            content.style.display = 'none';
          }
        });
        
        // Refresh data when switching tabs
        await update();
      });
    });

    // --- Admin Token Modal/Login UI ---
function showTokenModal() {
  let modal = document.getElementById('token-modal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'token-modal';
    modal.style = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:9999;';
    modal.innerHTML = `
      <div style="background:#222;padding:2rem 2.5rem;border-radius:12px;box-shadow:0 2px 16px #000;display:flex;flex-direction:column;align-items:center;min-width:300px;">
        <h2 style='color:#e657ff;margin-bottom:1rem;'>Enter Admin Token</h2>
        <input id='token-input' type='password' placeholder='Admin Token' style='padding:0.5rem 1rem;font-size:1.1rem;border-radius:6px;border:1px solid #888;width:100%;margin-bottom:1rem;'>
        <button id='token-submit' style='padding:0.5rem 1.5rem;background:#140d52;color:#fff;border:none;border-radius:6px;font-weight:bold;cursor:pointer;'>Login</button>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('token-submit').onclick = function() {
      const val = document.getElementById('token-input').value.trim();
      if (val) {
        localStorage.setItem('admin_token', val);
        modal.remove();
        location.reload();
      }
    };
    document.getElementById('token-input').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') document.getElementById('token-submit').click();
    });
  }
}

function getAdminToken() {
  let token = localStorage.getItem('admin_token');
  if (!token) {
    showTokenModal();
    throw new Error('No admin token set');
  }
  return token;
}

function logoutToken() {
  localStorage.removeItem('admin_token');
  location.reload();
}

// Add a logout button to the UI
(function addLogoutButton(){
  const btn = document.createElement('button');
  btn.textContent = 'Logout';
  btn.style = 'position:fixed;top:1rem;right:1rem;z-index:1000;background:#f44336;color:#fff;padding:0.5rem 1.2rem;border:none;border-radius:8px;font-weight:bold;cursor:pointer;opacity:0.85;';
  btn.onclick = logoutToken;
  document.body.appendChild(btn);
})();

    // Prompt for admin token and store in localStorage
    function getAdminToken() {
      let token = localStorage.getItem('admin_token');
      if (!token) {
        token = prompt('Enter Admin Token for backend access:');
        if (token) localStorage.setItem('admin_token', token);
      }
      return token;
    }

    function fetchWithAdminToken(url, options = {}) {
      const token = getAdminToken();
      options.headers = options.headers || {};
      options.headers['X-Admin-Token'] = token;
      return fetch(url, options);
    }

    // Prefetch historical data in the background so it appears instantly on switch
    (async function prefetchHistorical(){
      try{
        const r = await fetchWithAdminToken(histUrl);
        if(r.ok){ cachedHistorical = await r.json(); console.log('Prefetched historical:', cachedHistorical); }
      }catch(e){ console.warn('Prefetch historical failed', e); }
    })();

    function fmtType(stat){
      const m={'passing_yards':'Pass Yds','passing_yards_alt':'Alt Pass Yds','receiving_yards':'Rec Yds','receiving_yards_alt':'Alt Rec Yds','rushing_yards':'Rush Yds','rushing_yards_alt':'Alt Rush Yds','rushing_receiving_yards':'Rush + Rec Yds','anytime_touchdown':'Anytime TD','passing_touchdowns':'Pass TDs','rushing_touchdowns':'Rush TDs','receptions':'Receptions','receptions_alt':'Alt Receptions','longest_reception':'Longest Rec','moneyline':'Moneyline','spread':'Spread'};
      return m[stat]||stat.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase());
    }
    function getQuarter(p){return p===1?'1st Quarter':p===2?'2nd Quarter':p===3?'3rd Quarter':p===4?'4th Quarter':'Overtime';}

    // Get 3-letter team abbreviation from full team name
    function getTeamAbbr(teamName) {
      const abbrevMap = {
        'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
        'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
        'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
        'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
        'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
        'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
        'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
        'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
        'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
        'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
        'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
      };
      return abbrevMap[teamName] || teamName.substring(0, 3).toUpperCase();
    }

    // Format stat value for mobile display
    function formatStatForMobile(value, stat) {
      if (stat === 'moneyline') return value;
      if (stat === 'spread') return value;
      
      // For numeric stats, add unit abbreviations
      if (stat.includes('yards')) return `${value} Yds`;
      if (stat.includes('touchdown')) return `${value} TDs`;
      if (stat.includes('receptions')) return `${value} Rec`;
      if (stat.includes('passing')) return `${value} Pass`;
      if (stat.includes('rushing')) return `${value} Rush`;
      
      return value;
    }

    // Calculate countdown to game start
    function getCountdown(startDateTime) {
      if (!startDateTime) return '';
      
      const now = new Date();
      const gameStart = new Date(startDateTime);
      const diffMs = gameStart - now;
      
      if (diffMs <= 0) return 'Starting soon';
      
      const totalHours = Math.floor(diffMs / (1000 * 60 * 60));
      const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
      
      // If less than 24 hours, show hours and minutes
      if (totalHours < 24) {
        return `Starts in ${totalHours}h ${minutes}m`;
      }
      
      // If 24 hours or more, show days and hours (no minutes)
      const days = Math.floor(totalHours / 24);
      const hours = totalHours % 24;
      return `Starts in ${days}d ${hours}h`;
    }

    function enhanceParlayName(parlay) {
      // If parlay doesn't have legs, return original name
      if (!parlay.legs || parlay.legs.length === 0) {
        return parlay.name;
      }

      // Get unique teams from all legs
      const allTeams = new Set();
      parlay.legs.forEach(leg => {
        if (leg.away) allTeams.add(leg.away);
        if (leg.home) allTeams.add(leg.home);
      });

      // Only proceed if exactly 2 teams are involved
      if (allTeams.size !== 2) {
        return parlay.name;
      }

      // Get away and home teams from the first leg
      const away = parlay.legs[0].away;
      const home = parlay.legs[0].home;

      // Convert full team names to abbreviations
      const teamAbbrevMap = {
        'Atlanta Falcons': 'Falcons', 'Buffalo Bills': 'Bills', 'Carolina Panthers': 'Panthers',
        'Chicago Bears': 'Bears', 'Cincinnati Bengals': 'Bengals', 'Cleveland Browns': 'Browns',
        'Dallas Cowboys': 'Cowboys', 'Denver Broncos': 'Broncos', 'Detroit Lions': 'Lions',
        'Green Bay Packers': 'Packers', 'Houston Texans': 'Texans', 'Indianapolis Colts': 'Colts',
        'Jacksonville Jaguars': 'Jaguars', 'Kansas City Chiefs': 'Chiefs', 'Las Vegas Raiders': 'Raiders',
        'Los Angeles Chargers': 'Chargers', 'Los Angeles Rams': 'Rams', 'Miami Dolphins': 'Dolphins',
        'Minnesota Vikings': 'Vikings', 'New England Patriots': 'Patriots', 'New Orleans Saints': 'Saints',
        'New York Giants': 'Giants', 'New York Jets': 'Jets', 'Philadelphia Eagles': 'Eagles',
        'Pittsburgh Steelers': 'Steelers', 'San Francisco 49ers': '49ers', 'Seattle Seahawks': 'Seahawks',
        'Tampa Bay Buccaneers': 'Buccaneers', 'Tennessee Titans': 'Titans', 'Washington Commanders': 'Commanders',
        'Arizona Cardinals': 'Cardinals', 'Baltimore Ravens': 'Ravens'
      };

      const awayAbbrev = teamAbbrevMap[away] || away;
      const homeAbbrev = teamAbbrevMap[home] || home;
      const matchup = `${awayAbbrev} @ ${homeAbbrev}`;

      // Check if the matchup or team names are already in the parlay name
      const nameContainsMatchup = parlay.name.includes('@') || 
                                   parlay.name.includes(awayAbbrev) || 
                                   parlay.name.includes(homeAbbrev) ||
                                   parlay.name.includes(away) ||
                                   parlay.name.includes(home);

      // If matchup info not already in name, append it
      if (!nameContainsMatchup) {
        return `${parlay.name} - ${matchup}`;
      }

      return parlay.name;
    }

    async function update(){
      msg.textContent='Fetching data...';
      try{
        // First process any new parlays
        await fetchWithAdminToken(statsUrl);
        
        // Get active tab
        const activeTab = document.querySelector('.tab.active').dataset.tab;
        
        // Only fetch data for the active tab; use cache if available
        if(activeTab === 'current') {
          // Fetch both todays and live bets and combine them
          const todaysUrl = `${API_BASE}/todays`;
          const [todaysResponse, liveResponse] = await Promise.all([
            fetchWithAdminToken(todaysUrl),
            fetchWithAdminToken(liveUrl)
          ]);
          
          if(!todaysResponse.ok) throw new Error(`Todays data error: ${todaysResponse.status}`);
          if(!liveResponse.ok) throw new Error(`Live data error: ${liveResponse.status}`);
          
          const todaysParlays = await todaysResponse.json();
          const liveParlays = await liveResponse.json();
          
          // Combine both arrays
          const combinedParlays = [...todaysParlays, ...liveParlays];
          cachedLive = combinedParlays;
          
          console.log('Todays parlays:', todaysParlays);
          console.log('Live parlays:', liveParlays);
          console.log('Combined parlays:', combinedParlays);
          
          render(combinedParlays, sec);
        } else if(activeTab === 'historical') {
          if (cachedHistorical) {
            console.log('Using cached historical data');
            render(cachedHistorical, histSec);
          } else {
            const historicalResponse = await fetchWithAdminToken(histUrl);
            if(!historicalResponse.ok) throw new Error(`Historical data error: ${historicalResponse.status}`);
            const historical = await historicalResponse.json();
            cachedHistorical = historical;
            console.log('Historical parlays:', historical);
            render(historical, histSec);
          }
        }
        
        msg.textContent=`Last updated: ${new Date().toLocaleTimeString()}`;
      }catch(e){
        console.error('Error during update:', e);
        msg.textContent=`Error loading data: ${e.message}`;
      }
    }

    async function loadHistorical(){
      msg.textContent='Loading historical bets...';
      try{
        console.log('Fetching from:', histUrl);
        const r=await fetchWithAdminToken(histUrl);
        if(!r.ok)throw r.status;
        const historical=await r.json();
        console.log('Received historical data:', historical);
        render(historical, histSec);
        msg.textContent=`Historical data loaded: ${new Date().toLocaleTimeString()}`;
      }catch(e){
        console.error('Error loading historical data:', e);
        msg.textContent='Error loading historical data: ' + e.toString();
      }
    }

    function render(parlays, container){
      console.log('Render called with parlays:', parlays);
      console.log('Container:', container);
      container.innerHTML='';
      if (!Array.isArray(parlays)) {
        console.error('parlays is not an array:', parlays);
        return;
      }

      // Show a helpful empty-state when there's no data for the tab
      if (parlays.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'no-data';
        const tabName = container.dataset.tab === 'historical' ? 'Historical Bets' : "Live Bets";
        empty.innerHTML = `
          <div style="text-align:center;padding:2rem;color:#bbb">
            <strong>No parlays found</strong>
            <div style="margin-top:.5rem">There are no ${tabName} to display right now.</div>
            <button id="empty-refresh" style="margin-top:1rem;padding:.5rem 1rem;border-radius:6px;background:#140d52;color:#fff;border:none;cursor:pointer">Refresh</button>
          </div>`;
        container.appendChild(empty);
        // wire the refresh button to re-run update()
        const b = empty.querySelector('#empty-refresh');
        if (b) b.addEventListener('click', update);
        return;
      }
      
      // Only render historical bets in historical section and current bets in current section
      const isHistoricalSection = container.id === 'historical-sections';
      
      // Render all parlays in their respective sections
      parlays.forEach(parlay=>{
        console.log('Processing parlay:', parlay);
        const section=document.createElement('div');
        section.className='parlay-section';
        
        const header=document.createElement('div');
        header.className='parlay-header';
        
        // Enhance parlay name with team matchup if applicable
        const displayName = enhanceParlayName(parlay);
        
        // Check if all legs are at 100% (winning bet)
        const allLegsComplete = parlay.legs && parlay.legs.length > 0 && 
          parlay.legs.every(leg => {
            const pct = leg.target > 0 ? Math.min(100, Math.round(leg.current / leg.target * 100)) : 0;
            return pct === 100;
          });
        
        // Get game date for single game parlays
        let formattedDate = '';
        if (parlay.legs && parlay.legs[0]) {
          // Get unique game dates from all legs
          const uniqueDates = [...new Set(parlay.legs.map(leg => leg.game_date))].filter(d => d);
          
          // If there's only one unique date, it's a single game parlay
          if (uniqueDates.length === 1 && uniqueDates[0]) {
            const dateStr = String(uniqueDates[0]);
            try {
              let gameDate;
              
              // Handle both formats: YYYY-MM-DD (new standard) and YYYYMMDD (legacy)
              if (dateStr.includes('-')) {
                // YYYY-MM-DD format
                gameDate = new Date(dateStr);
              } else if (dateStr.length === 8) {
                // YYYYMMDD format (legacy)
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(4, 6);
                const day = dateStr.substring(6, 8);
                gameDate = new Date(`${year}-${month}-${day}`);
              }
              
              // Check if date is valid
              if (gameDate && !isNaN(gameDate.getTime())) {
                const dayOfWeek = gameDate.toLocaleDateString('en-US', { weekday: 'long' });
                const monthName = gameDate.toLocaleDateString('en-US', { month: 'short' });
                const dayNum = gameDate.getDate();
                const yearNum = gameDate.getFullYear();
                formattedDate = `${dayOfWeek} - ${monthName} ${dayNum}, ${yearNum}`;
              }
            } catch (e) {
              console.error('Error parsing date:', dateStr, e);
            }
          }
        }
        
        header.innerHTML = `
          ${allLegsComplete ? '<div class="winning-overlay"></div>' : ''}
          <div class="parlay-title">
            ${displayName}
            ${formattedDate && `<span class="parlay-date">${formattedDate}</span>`}
          </div>
        `;

        const allGamesDiv=document.createElement('div');
        allGamesDiv.className='game-info-wrapper';

        // Debug logging
        console.log('Parlay:', parlay.name, 'has games:', parlay.games ? parlay.games.length : 'undefined');

        // Show scoreboard if games data exists
        if (parlay.games && parlay.games.length > 0) {
          // For non-SGPs, we want to show all relevant games
          if (parlay.type !== 'SGP') {
            // Create a map of unique games based on away+home team combination
            const uniqueGames = new Map();
            parlay.legs.forEach(leg => {
              const gameKey = `${leg.away}-${leg.home}`;
              const game = parlay.games.find(g => 
                g.teams.away === leg.away && g.teams.home === leg.home
              );
              if (game && !uniqueGames.has(gameKey)) {
                uniqueGames.set(gameKey, game);
              }
            });
            
            // Show all unique games involved in the parlay
            uniqueGames.forEach(g => {
              const stn=g.statusTypeName,isSched=stn==='STATUS_SCHEDULED',isLive=stn==='STATUS_IN_PROGRESS',isHalftime=stn==='STATUS_HALFTIME';
              let gameStatus,gameCls,gameDetails;
              if(isSched){
                gameStatus='🔜 Not Started';
                gameCls='status-pregame';
                const countdown = getCountdown(g.startDateTime);
                gameDetails=`<div>${getTeamAbbr(g.teams.away)} @ ${getTeamAbbr(g.teams.home)}</div><div>${countdown || g.startTime}</div>`;
              }
              else if(isHalftime){gameStatus='HALF';gameCls='status-halftime';gameDetails=`<div>${getQuarter(g.period)}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else if(isLive){gameStatus='LIVE';gameCls='status-live';gameDetails=`<div>${getQuarter(g.period)}, ${g.clock}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else{gameStatus='FINAL';gameCls='status-final';gameDetails=`<div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              
              const gameInfoDiv=document.createElement('div');
              gameInfoDiv.className='game-info';
              gameInfoDiv.innerHTML=`<div class="badge ${gameCls}">${gameStatus}</div>${gameDetails}`;
              allGamesDiv.appendChild(gameInfoDiv);
            });
          } else {
            // For SGPs, show the game info as before
            parlay.games.forEach(g=>{
              const stn=g.statusTypeName,isSched=stn==='STATUS_SCHEDULED',isLive=stn==='STATUS_IN_PROGRESS',isHalftime=stn==='STATUS_HALFTIME';
              let gameStatus,gameCls,gameDetails;
              if(isSched){
                gameStatus='🔜 Not Started';
                gameCls='status-pregame';
                const countdown = getCountdown(g.startDateTime);
                gameDetails=`<div>${getTeamAbbr(g.teams.away)} @ ${getTeamAbbr(g.teams.home)}</div><div>${countdown || g.startTime}</div>`;
              }
              else if(isHalftime){gameStatus='HALF';gameCls='status-halftime';gameDetails=`<div>${getQuarter(g.period)}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else if(isLive){gameStatus='LIVE';gameCls='status-live';gameDetails=`<div>${getQuarter(g.period)}, ${g.clock}</div><div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              else{gameStatus='FINAL';gameCls='status-final';gameDetails=`<div>${g.teams.away.substring(0,3).toUpperCase()} ${g.score.away} - ${g.score.home} ${g.teams.home.substring(0,3).toUpperCase()}</div>`;}
              
              const gameInfoDiv=document.createElement('div');
              gameInfoDiv.className='game-info';
              gameInfoDiv.innerHTML=`<div class="badge ${gameCls}">${gameStatus}</div>${gameDetails}`;
              allGamesDiv.appendChild(gameInfoDiv);
            });
          }
        }
        header.appendChild(allGamesDiv);

        const isAnyGameLive = parlay.games && parlay.games.some(g=>g.statusTypeName==='STATUS_IN_PROGRESS' || g.statusTypeName==='STATUS_HALFTIME');
        const areAllGamesFinal = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_FINAL');
        const areAllGamesScheduled = parlay.games && parlay.games.every(g=>g.statusTypeName==='STATUS_SCHEDULED');

        const table=document.createElement('table');
        table.innerHTML=`
          <thead><tr>
            <th>Player</th><th>Bet Type</th><th>Current</th>
            <th>Target</th><th style="width:25%;">Progress</th><th>Status</th>
          </tr></thead>
          <tbody>
            ${parlay.legs.map(p=>{
              const current = p.current ?? 0; // Handle undefined/null as 0
              const pct = p.target > 0 ? Math.min(100, Math.round(current / p.target * 100)) : 0;
              
              // Check if this is a spread or moneyline bet (no progress bar)
              const isSpreadOrML = p.stat === 'spread' || p.stat === 'moneyline';
              
              // Get game data for this leg
              const gameData = parlay.games ? parlay.games.find(g => 
                g.teams.away === p.away && g.teams.home === p.home
              ) : null;
              
              let progressCol = '';
              let currentDisplay = current;
              let targetDisplay = p.target;
              
              if (isSpreadOrML) {
                // For spread/moneyline, show score with team names only
                const scoreDiff = p.score_diff ?? 0;
                const betTeam = p.team || '';
                const betTeamName = betTeam.split(' ').pop(); // Get last word (e.g., "Cowboys")
                
                // Find opponent team name
                let opponentTeamName = '';
                if (gameData) {
                  const isHome = betTeam === gameData.teams.home;
                  const opponentFull = isHome ? gameData.teams.away : gameData.teams.home;
                  opponentTeamName = opponentFull.split(' ').pop();
                  
                  // Get actual scores
                  const betTeamScore = isHome ? gameData.score.home : gameData.score.away;
                  const oppTeamScore = isHome ? gameData.score.away : gameData.score.home;
                  
                  // Show score in format: "Cowboys 21 - 7 Falcons" (bet team always on left)
                  progressCol = `<div style="text-align:center;padding:0.5rem;font-weight:bold;">${betTeamName} ${betTeamScore} - ${oppTeamScore} ${opponentTeamName}</div>`;
                } else {
                  // No game data yet (scheduled game)
                  progressCol = `<div style="text-align:center;padding:0.5rem;">-</div>`;
                }
                
                // For moneyline: current shows winning/losing status, target shows "Win"
                if (p.stat === 'moneyline') {
                  targetDisplay = 'Win';
                  if (gameData && gameData.statusTypeName !== 'STATUS_SCHEDULED') {
                    const isFinal = gameData.statusTypeName === 'STATUS_FINAL';
                    if (scoreDiff > 0) {
                      currentDisplay = isFinal ? 'Win' : `Winning by ${scoreDiff}`;
                    } else if (scoreDiff < 0) {
                      currentDisplay = isFinal ? 'Loss' : `Losing by ${Math.abs(scoreDiff)}`;
                    } else {
                      currentDisplay = 'Tied';
                    }
                  } else {
                    currentDisplay = '-';
                  }
                }
                
                // For spread: format target with +/- sign
                if (p.stat === 'spread') {
                  targetDisplay = p.target > 0 ? `+${p.target}` : `${p.target}`;
                  // Current shows Win/Loss for final games, 0/1 otherwise
                  if (gameData && gameData.statusTypeName === 'STATUS_FINAL') {
                    currentDisplay = current === 1 ? 'Win' : 'Loss';
                  } else {
                    currentDisplay = current;
                  }
                }
                
              } else {
                // Regular progress bar for numeric stats
                let cls = '';
                if (areAllGamesFinal) {
                  cls = (pct === 100) ? 'pct-full' : 'pct-vlow';
                } else {
                  if (pct === 100) {
                    cls = 'pct-full';
                  } else if (pct >= 60) {
                    cls = 'pct-mid';
                  } else if (pct >= 20) {
                    cls = 'pct-low';
                  } else if (pct > 0) {
                    cls = 'pct-vlow';
                  }
                }
                progressCol = `<div class="progress-bar ${cls}">
                           <div class="progress ${cls}" style="width:${pct}%"></div>
                           <div class="progress-text">${pct}%</div>
                         </div>`;
              }
              
              let txt;
              // Show Hit if 100% reached (for numeric) or current=1 (for spread/ML), even during live game
              if(isSpreadOrML ? current===1 : pct===100) txt='✅ Hit';
              else if(areAllGamesScheduled || (!isAnyGameLive && !areAllGamesFinal))txt='🔜 Not Started';
              else if(isAnyGameLive)txt='⏳ In Progress';
              else txt='🚫 Miss';
              
              // Format for mobile display
              const playerOrTeam = p.player || p.team || 'N/A';
              const statType = fmtType(p.stat);
              const mobileCurrentDisplay = formatStatForMobile(currentDisplay, p.stat);
              const mobileTargetDisplay = formatStatForMobile(targetDisplay, p.stat);
              
              return`
                <tr>
                  <td>
                    <div class="mobile-line-1">
                      <span><strong>${playerOrTeam}</strong><span style="font-weight:normal;"> - ${statType}</span></span>
                      <span>${txt}</span>
                    </div>
                  </td>
                  <td>
                    <div class="mobile-line-2-header">
                      <span>Current</span>
                      <span></span>
                      <span>Target</span>
                    </div>
                    <div class="mobile-line-2">
                      <span>${mobileCurrentDisplay}</span>
                      <span>${progressCol}</span>
                      <span>${mobileTargetDisplay}</span>
                    </div>
                  </td>
                  <td>${p.player || p.team || 'N/A'}</td>
                  <td>${fmtType(p.stat)}</td>
                  <td>${currentDisplay}</td>
                  <td>${targetDisplay}</td>
                  <td>${progressCol}</td>
                  <td>${txt}</td>
                </tr>`;
            }).join('')}
          </tbody>`;
        
        // Create footer with bet info
        const footer = document.createElement('div');
        footer.className = 'parlay-footer';
        
        const oddsText = parlay.odds || 'N/A';
        const wagerText = parlay.wager ? `$${parlay.wager}` : 'N/A';
        const betIdText = parlay.bet_id || 'N/A';
        const siteText = parlay.betting_site || 'N/A';
        
        footer.innerHTML = `
          <div class="footer-left">
            <div class="footer-odds">Odds: ${oddsText}</div>
            <div class="footer-wager">Wager: ${wagerText}</div>
          </div>
          <div class="footer-right">
            <div class="footer-betid">Bet ID: ${betIdText}</div>
            <div class="footer-site">${siteText}</div>
          </div>
        `;
        
        section.appendChild(header);
        section.appendChild(table);
        section.appendChild(footer);
        // Append to the container passed into render() so each tab gets its own content
        container.appendChild(section);
      });
    }

    btn.addEventListener('click',update);
    
    // Move completed games button
    const moveBtn = document.getElementById('move-completed-button');
    moveBtn.addEventListener('click', async () => {
      try {
        msg.textContent = 'Moving completed games...';
        moveBtn.disabled = true;
        
        const response = await fetchWithAdminToken(`${API_BASE}/admin/move_completed`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) throw new Error(`Move failed: ${response.status}`);
        
        const result = await response.json();
        msg.textContent = `Moved ${result.moved_count} parlay(s) to history. ${result.remaining_live} still live.`;
        
        // Clear caches and refresh
        cachedLive = null;
        cachedHistorical = null;
        await update();
      } catch (e) {
        console.error('Error moving completed:', e);
        msg.textContent = `Error: ${e.message}`;
      } finally {
        moveBtn.disabled = false;
      }
    });
    
    update();
  </script>
</body>
</html>